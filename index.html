<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="pageTitle">å®‡å®™è¿·èˆª</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: radial-gradient(ellipse at center, #0a0e2a 0%, #000000 70%);
            color: #ffffff;
            overflow: hidden;
        }
        
        #universe-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            text-align: center;
            background: linear-gradient(180deg, rgba(0,0,0,0.8), transparent);
            z-index: 100;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(0, 242, 254, 0.8);
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #00f2fe;
            opacity: 0.8;
        }
        
        /* è¯­è¨€åˆ‡æ¢æŒ‰é’® */
        #lang-toggle {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 8px 15px;
            background: rgba(0, 30, 60, 0.8);
            border: 1px solid #00f2fe;
            color: #00f2fe;
            cursor: pointer;
            border-radius: 5px;
            font-size: 14px;
            z-index: 200;
            backdrop-filter: blur(10px);
        }
        
        #lang-toggle:hover {
            background: rgba(0, 242, 254, 0.2);
            box-shadow: 0 0 10px rgba(0, 242, 254, 0.5);
        }
        
        /* å¯¼èˆªæŒ‰é’®é€šç”¨æ ·å¼ */
        .nav-button {
            position: absolute;
            left: 20px;
            padding: 10px 20px;
            background: rgba(0, 30, 60, 0.8);
            border: 1px solid #00f2fe;
            color: #00f2fe;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
            display: none;
            z-index: 100;
        }
        
        .nav-button:hover {
            background: rgba(0, 242, 254, 0.2);
            box-shadow: 0 0 10px rgba(0, 242, 254, 0.5);
        }
        
        #back-button {
            top: 20px;
        }
        
        #enter-solar-button {
            top: 70px;
        }
        
        #enter-earth-button {
            top: 120px;
        }
        
        #toggle-panel-button {
            bottom: 90px;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 242, 254, 0.3);
            border-top: 3px solid #00f2fe;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            border: 1px solid #00f2fe;
            z-index: 100;
        }
        
        /* æ§åˆ¶é¢æ¿æ ·å¼ - ä»åŸå§‹åœ°çƒæ¨¡å‹æ•´åˆ */
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 30, 60, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #00f2fe;
            z-index: 100;
            max-width: 250px;
            backdrop-filter: blur(10px);
        }
        
        #controls h3 {
            color: #00f2fe;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 5px rgba(0, 242, 254, 0.5);
        }
        
        #controls label {
            color: #ffffff;
            font-size: 12px;
            display: block;
            margin-bottom: 5px;
        }
        
        #controls input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
            -webkit-appearance: none;
            height: 5px;
            border-radius: 5px;
            background: rgba(0, 242, 254, 0.3);
            outline: none;
        }
        
        #controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #00f2fe;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 242, 254, 0.8);
        }
        
        #controls button {
            background: rgba(0, 242, 254, 0.2);
            color: #00f2fe;
            border: 1px solid #00f2fe;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            display: inline-block;
        }
        
        #controls button:hover {
            background: rgba(0, 242, 254, 0.4);
            box-shadow: 0 0 10px rgba(0, 242, 254, 0.5);
        }
        
        #controls div:last-child {
            text-align: center;
        }
        
        .texture-info {
            font-size: 11px;
            color: #00f2fe;
            margin-top: 10px;
            text-align: center;
            opacity: 0.8;
        }
        
        .credits-info {
            font-size: 12px;
            color: #00f2fe;
            margin-top: 10px;
            text-align: center;
            line-height: 1.8;
        }
        
        .credits-info div {
            padding: 3px 0;
        }
        
        /* ä»‹ç»å¼¹çª—æ ·å¼ */
        .sci-fi-tooltip {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 30, 60, 0.3);
            border: none;
            border-radius: 15px;
            padding: 25px;
            color: #ffffff;
            font-family: 'Arial', sans-serif;
            max-width: 400px;
            z-index: 1000;
            box-shadow: 0 0 40px rgba(0, 242, 254, 0.6);
            backdrop-filter: blur(15px);
            animation: fadeIn 0.3s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        
        /* éšè—åœ°çƒå±‚çº§çš„æ§åˆ¶é¢æ¿ */
        .earth-controls {
            display: none;
        }
        
        .earth-controls.visible {
            display: block;
        }
        
        /* ä½ç½®æ ‡è®°åŠŸèƒ½æ ·å¼ */

        
        #getCurrentLocation:hover, #clearCustomMarkers:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }
        
        #getCurrentLocation:active, #clearCustomMarkers:active {
            transform: translateY(1px);
        }
        
        #locationStatus.success {
            color: #4caf50;
        }
        
        #locationStatus.error {
            color: #f44336;
        }
        
        #locationStatus.info {
            color: #2196f3;
        }
    </style>
</head>
<body>
    <div id="universe-container">
        <div id="header">
            <h1 id="mainTitle">å®‡å®™è¿·èˆª</h1>
            <div class="subtitle" id="mainSubtitle">é£å‘æ— è¾¹çš„æ˜Ÿé™…</div>
        </div>
        
        <button id="lang-toggle" onclick="toggleLanguage()">English/ä¸­æ–‡</button>
        
        <button id="back-button" class="nav-button" onclick="goBack()">è¿”å›</button>
        <button id="enter-solar-button" class="nav-button" onclick="enterSolarSystem()">è¿›å…¥å¤ªé˜³ç³»â˜€</button>
        <button id="enter-earth-button" class="nav-button" onclick="enterEarth()">è¿›å…¥åœ°çƒğŸŒ</button>
        <button id="toggle-panel-button" class="nav-button" onclick="toggleControlPanel()">éšè—æ§åˆ¶é¢æ¿</button>
        
        <div id="loading" class="loading">
            <div class="loading-spinner"></div>
            <div id="loadingText">æ­£åœ¨åŠ è½½å®‡å®™...</div>
        </div>
        
        <div class="instructions" id="instructions">
            ç§»åŠ¨é¼ æ ‡åˆ°å¤ªé˜³ç³»æ ‡è®°å¤„ç‚¹å‡»
        </div>
        
        <!-- é“¶æ²³ç³»æ§åˆ¶é¢æ¿ -->
        <div id="galaxy-controls" class="earth-controls">
            <div id="controls">
                <h3 id="galaxyControlTitle">é“¶æ²³ç³»æ§åˆ¶</h3>
                <label><span id="galaxySpeedLabel">é“¶æ²³ç³»è½¬é€Ÿ</span>: <span id="galaxySpeedValue">1.0</span></label>
                <input type="range" id="galaxySpeed" min="0" max="3" step="0.1" value="1">
            </div>
        </div>
        
        <!-- å¤ªé˜³ç³»æ§åˆ¶é¢æ¿ -->
        <div id="solar-controls" class="earth-controls">
            <div id="controls">
                <h3 id="solarControlTitle">å¤ªé˜³ç³»æ§åˆ¶</h3>
                <label><span id="solarSpeedLabel">ç³»ç»Ÿè½¬é€Ÿ</span>: <span id="solarSpeedValue">0.25</span></label>
                <input type="range" id="solarSpeed" min="0" max="3" step="0.1" value="0.25">
            </div>
        </div>
        
        <!-- åœ°çƒå±‚çº§æ§åˆ¶é¢æ¿ -->
        <div id="earth-controls" class="earth-controls">
            <div id="controls">
                <h3 id="earthControlTitle">åœ°çƒæ§åˆ¶é¢æ¿</h3>
                <label><span id="rotationSpeedLabel">æ—‹è½¬é€Ÿåº¦</span>: <span id="speedValue">0.25</span></label>
                <input type="range" id="rotationSpeed" min="0" max="3" step="0.1" value="0.25">
                
                <label><span id="cloudOpacityLabel">äº‘å±‚é€æ˜åº¦</span>: <span id="cloudValue">0.4</span></label>
                <input type="range" id="cloudOpacity" min="0" max="1" step="0.1" value="0.4">
                
                <div>
                    <button id="toggleRotation">æš‚åœæ—‹è½¬</button>
                    <button id="resetView">é‡ç½®è§†å›¾</button>
                </div>

                <div>
					<button id="toggleEquator">æ˜¾ç¤ºèµ¤é“</button>
                    <button id="toggleLatLon">æ˜¾ç¤ºç»çº¬çº¿</button>
                    <button id="toggleArcAnt">æ˜¾ç¤ºæåœˆ</button>
                    <button id="toggleCanCap">æ˜¾ç¤ºå›å½’çº¿</button>
                </div>

                <div>
                    <button id="toggleCities">éšè—åŸå¸‚</button>
                    <button id="togglePeaks">éšè—å±±å³°</button>
                    <button id="toggleLakes">éšè—æ¹–æ³Š</button>
                    <button id="toggleRivers">éšè—æ²³æµ</button>
                </div>

                <div class="texture-info" id="normalInfo">
                    <span id="peaksStatus">å±±å³°: å·²æ˜¾ç¤º</span> | 
                    <span id="citiesStatus">åŸå¸‚: å·²æ˜¾ç¤º</span>
                </div>
				
                <div class="texture-info" id="normalInfo2">
                    <span id="lakesStatus">æ¹–æ³Š: å·²æ˜¾ç¤º</span> | 
                    <span id="riversStatus">æ²³æµ: å·²æ˜¾ç¤º</span>
                </div>
                
                <div class="credits-info" id="creditsInfo" style="display: none;">
                    <div id="supervisorText">ç›‘åˆ¶ã€€ç™½çˆ±å¨ƒ</div>
                    <div id="developerText">å¼€å‘ã€€æã€€åš</div>
                    <div id="testerText">æµ‹è¯•ã€€æä¸€æ˜•</div>
                    <div id="softwareText">AI: CodeBuddy</div>
                </div>
                
                <div style="margin-top: 15px; border-top: 1px solid #444; padding-top: 15px;">
                    <h4 id="locationMarkersTitle" style="margin-bottom: 10px; color: #4a9eff;">å½“å‰ä½ç½®æ ‡è®°</h4>
                    <div style="margin-bottom: 10px;">
                        <button id="getCurrentLocation" style="width: 100%; padding: 8px; background: #2a7f5c; color: white; border: none; border-radius: 4px; cursor: pointer;">è·å–å½“å‰ä½ç½®</button>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <button id="clearCustomMarkers" style="width: 100%; padding: 8px; background: #aa3a2a; color: white; border: none; border-radius: 4px; cursor: pointer;">æ¸…é™¤è‡ªå®šä¹‰æ ‡è®°</button>
                    </div>
                    <div id="locationStatus" style="font-size: 12px; color: #aaa; margin-top: 5px; min-height: 16px;"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // è¯­è¨€çŠ¶æ€
        let currentLang = 'zh'; // é»˜è®¤ä¸­æ–‡
        
        // æ–‡æœ¬æ˜ å°„
        const texts = {
            zh: {
                pageTitle: 'å®‡å®™è¿·èˆª',
                mainTitle: 'å®‡å®™è¿·èˆª',
                mainSubtitle: 'é£å‘æ— è¾¹çš„æ˜Ÿé™…',
                loadingText: 'æ­£åœ¨åŠ è½½å®‡å®™...',
                instructions: {
                    galaxy: 'ç§»åŠ¨é¼ æ ‡åˆ°å¤ªé˜³ç³»æ ‡è®°å¤„ç‚¹å‡»',
                    solar: 'ç§»åŠ¨é¼ æ ‡åˆ°åœ°çƒæ ‡è®°å¤„ç‚¹å‡»',
                    earth: 'ä½¿ç”¨é¼ æ ‡æ‹–æ‹½æ—‹è½¬ï¼Œæ»šè½®ç¼©æ”¾',
                    hover: 'æ‚¬åœ: %s | ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…',
                    click: 'ç‚¹å‡»æ¢ç´¢: %s'
                },
                navButtons: {
                    back: 'è¿”å›',
                    enterSolar: 'è¿›å…¥å¤ªé˜³ç³»â˜€',
                    enterEarth: 'è¿›å…¥åœ°çƒğŸŒ',
                    togglePanel: 'éšè—æ§åˆ¶é¢æ¿'
                },
                controlPanels: {
                    galaxy: {
                        title: 'é“¶æ²³ç³»æ§åˆ¶',
                        speedLabel: 'é“¶æ²³ç³»è½¬é€Ÿ'
                    },
                    solar: {
                        title: 'å¤ªé˜³ç³»æ§åˆ¶',
                        speedLabel: 'ç³»ç»Ÿè½¬é€Ÿ'
                    },
                    earth: {
                        title: 'åœ°çƒæ§åˆ¶é¢æ¿',
                        rotationSpeed: 'æ—‹è½¬é€Ÿåº¦',
                        cloudOpacity: 'äº‘å±‚é€æ˜åº¦'
                    }
                },
                toggleButtons: {
                    rotation: ['æš‚åœæ—‹è½¬', 'ç»§ç»­æ—‹è½¬', 'æ¢å¤æ—‹è½¬'],
                    reset: 'é‡ç½®è§†å›¾',
                    latLon: ['æ˜¾ç¤ºç»çº¬çº¿', 'éšè—ç»çº¬çº¿'],
                    equator: ['æ˜¾ç¤ºèµ¤é“', 'éšè—èµ¤é“'],
                    tropic: ['æ˜¾ç¤ºå›å½’çº¿', 'éšè—å›å½’çº¿'],
                    arcAnt: ['æ˜¾ç¤ºæåœˆ', 'éšè—æåœˆ'],
                    cities: ['éšè—åŸå¸‚', 'æ˜¾ç¤ºåŸå¸‚'],
                    peaks: ['éšè—å±±å³°', 'æ˜¾ç¤ºå±±å³°'],
                    lakes: ['éšè—æ¹–æ³Š', 'éšè—æ¹–æ³Š'],
                    rivers: ['éšè—æ²³æµ', 'æ˜¾ç¤ºæ²³æµ'],
                    getLocation: 'è·å–å½“å‰ä½ç½®',
                    clearMarkers: 'æ¸…é™¤è‡ªå®šä¹‰æ ‡è®°',
                    locationMarkersTitle: 'å½“å‰ä½ç½®æ ‡è®°'
                },
                statusText: {
                    peaks: ['å±±å³°: å·²æ˜¾ç¤º', 'å±±å³°: æœªæ˜¾ç¤º'],
                    cities: ['åŸå¸‚: å·²æ˜¾ç¤º', 'åŸå¸‚: æœªæ˜¾ç¤º'],
                    lakes: ['æ¹–æ³Š: å·²æ˜¾ç¤º', 'æ¹–æ³Š: æœªæ˜¾ç¤º'],
                    rivers: ['æ²³æµ: å·²æ˜¾ç¤º', 'æ²³æµ: æœªæ˜¾ç¤º']
                },
                credits: {
                    supervisor: 'ç›‘åˆ¶    ç™½çˆ±å¨ƒ',
                    developer: 'å¼€å‘    æåš',
                    tester: 'æµ‹è¯•    æä¸€æ˜•'
                }
            },
            en: {
                pageTitle: 'Journey to the Universe',
                mainTitle: 'Journey to the Universe',
                mainSubtitle: 'Soaring into the distant stars',
                loadingText: 'Loading universe...',
                instructions: {
                    galaxy: 'Move mouse to Solar System marker and click',
                    solar: 'Move mouse to Earth marker and click',
                    earth: 'Drag mouse to rotate, scroll to zoom',
                    hover: 'Hover: %s | Click for details',
                    click: 'Click to explore: %s'
                },
                navButtons: {
                    back: 'Back',
                    enterSolar: 'Enter Solar Systemâ˜€',
                    enterEarth: 'Enter EarthğŸŒ',
                    togglePanel: 'Hide Panel'
                },
                controlPanels: {
                    galaxy: {
                        title: 'Galaxy Controls',
                        speedLabel: 'Galaxy Rotation Speed'
                    },
                    solar: {
                        title: 'Solar System Controls',
                        speedLabel: 'System Rotation Speed'
                    },
                    earth: {
                        title: 'Earth Control Panel',
                        rotationSpeed: 'Rotation Speed',
                        cloudOpacity: 'Cloud Opacity'
                    }
                },
                toggleButtons: {
                    rotation: ['Pause Rotation', 'Resume Rotation', 'Resume Rotation'],
                    reset: 'Reset View',
                    latLon: ['Show Lat/Lon Lines', 'Hide Lat/Lon Lines'],
                    equator: ['Show Equator', 'Hide Equator'],
                    tropic: ['Show Tropics', 'Hide Tropics'],
                    arcAnt: ['Show Polar Circles', 'Hide Polar Circles'],
                    cities: ['Hide Cities', 'Show Cities'],
                    peaks: ['Hide Peaks', 'Show Peaks'],
                    lakes: ['Hide Lakes', 'Show Lakes'],
                    rivers: ['Hide Rivers', 'Show Rivers'],
                    getLocation: 'Get Current Location',
                    clearMarkers: 'Clear Custom Markers',
                    locationMarkersTitle: 'Current Location Markers'
                },
                statusText: {
                    peaks: ['Peaks: Shown', 'Peaks: Hidden'],
                    cities: ['Cities: Shown', 'Cities: Hidden'],
                    lakes: ['Lakes: Shown', 'Lakes: Hidden'],
                    rivers: ['Rivers: Shown', 'Rivers: Hidden']
                },
                credits: {
                    supervisor: 'Supervisor Bai Aiewa',
                    developer: 'Developer Li Bo',
                    tester: 'Tester Li Yixin'
                }
            }
        };
        
        // åˆ‡æ¢è¯­è¨€å‡½æ•°
        function toggleLanguage() {
            currentLang = currentLang === 'zh' ? 'en' : 'zh';
            panelToggleFlag = true;
            // æ›´æ–°é¡µé¢æ ‡é¢˜
            document.title = texts[currentLang].pageTitle;
            document.getElementById('pageTitle').textContent = texts[currentLang].pageTitle;
            
            // æ›´æ–°ä¸»æ ‡é¢˜
            document.getElementById('mainTitle').textContent = texts[currentLang].mainTitle;
            document.getElementById('mainSubtitle').textContent = texts[currentLang].mainSubtitle;
            
            // æ›´æ–°åŠ è½½æ–‡æœ¬
            document.getElementById('loadingText').textContent = texts[currentLang].loadingText;
            
            // æ›´æ–°å¯¼èˆªæŒ‰é’®æ–‡æœ¬
            document.getElementById('back-button').textContent = texts[currentLang].navButtons.back;
            document.getElementById('enter-solar-button').textContent = texts[currentLang].navButtons.enterSolar;
            document.getElementById('enter-earth-button').textContent = texts[currentLang].navButtons.enterEarth;
            document.getElementById('toggle-panel-button').textContent = texts[currentLang].navButtons.togglePanel;
            
            // æ›´æ–°æ§åˆ¶é¢æ¿æ ‡é¢˜
            document.getElementById('galaxyControlTitle').textContent = texts[currentLang].controlPanels.galaxy.title;
            document.getElementById('galaxySpeedLabel').textContent = texts[currentLang].controlPanels.galaxy.speedLabel;
            document.getElementById('solarControlTitle').textContent = texts[currentLang].controlPanels.solar.title;
            document.getElementById('solarSpeedLabel').textContent = texts[currentLang].controlPanels.solar.speedLabel;
            document.getElementById('earthControlTitle').textContent = texts[currentLang].controlPanels.earth.title;
            document.getElementById('rotationSpeedLabel').textContent = texts[currentLang].controlPanels.earth.rotationSpeed;
            document.getElementById('cloudOpacityLabel').textContent = texts[currentLang].controlPanels.earth.cloudOpacity;
            
            // æ›´æ–°æ§åˆ¶æŒ‰é’®æ–‡æœ¬
            updateControlButtonText();
            
            // æ›´æ–°åˆ¶ä½œäººå‘˜ä¿¡æ¯
            if (document.getElementById('supervisorText')) {
                document.getElementById('supervisorText').textContent = texts[currentLang].credits.supervisor;
            }
            if (document.getElementById('developerText')) {
                document.getElementById('developerText').textContent = texts[currentLang].credits.developer;
            }
            if (document.getElementById('testerText')) {
                document.getElementById('testerText').textContent = texts[currentLang].credits.tester;
            }

            // æ›´æ–°çŠ¶æ€æ–‡æœ¬
            updateStatusText();

            // æ›´æ–°è¯´æ˜æ–‡å­—
            updateInstructionsText();

            // æ›´æ–°æ‰€æœ‰æ ‡ç­¾æ–‡æœ¬
            updateAllLabels();
            
            // æ›´æ–°éŸ³ä¹ç•Œé¢æ–‡æœ¬ï¼ˆæ·»åŠ åˆ°åŸæœ‰è¯­è¨€åˆ‡æ¢å‡½æ•°ä¸­ï¼‰
            updateMusicInterfaceText();
        }

        // æ›´æ–°æ‰€æœ‰æ ‡ç­¾æ–‡æœ¬
        function updateAllLabels() {
            // æ›´æ–°åŸå¸‚æ ‡ç­¾
            cityLabels.forEach(label => {
                const data = label.userData.data;
                const text = currentLang === 'zh' ? data.name : data.englishName;
                updateLabelText(label, text);
            });

            // æ›´æ–°å±±å³°æ ‡ç­¾
            peakLabels.forEach(label => {
                const data = label.userData.data;
                const text = currentLang === 'zh' ? data.name : data.englishName;
                const isPole = label.userData.key === 'northpole' || label.userData.key === 'southpole';
                const color = isPole ? '#ff8800' : '#ff0000';
                updateLabelText(label, text, color);
            });

            // æ›´æ–°æ¹–æ³Šæ ‡ç­¾
            lakeLabels.forEach(label => {
                const data = label.userData.data;
                const text = currentLang === 'zh' ? data.name : data.englishName;
                updateLabelText(label, text, '#0099ff');
            });

            // æ›´æ–°æ²³æµæ ‡ç­¾
            riverLabels.forEach(label => {
                const data = label.userData.data;
                const text = currentLang === 'zh' ? data.name : data.englishName;
                updateLabelText(label, text, '#00ff00');
            });

            // æ›´æ–°è‡ªå®šä¹‰æ ‡è®°æ ‡ç­¾
            if (customMarkers) {
                customMarkers.forEach(marker => {
                    if (marker.userData && marker.userData.isCustomMarker) {
                        const originalName = marker.userData.originalName;
                        let displayText = marker.userData.name;
                        let textColor = '#ffffff';
                        // å¦‚æœæ˜¯å½“å‰ä½ç½®æ ‡è®°ï¼ˆåŸå§‹åç§°ä¸º'here/è¿™é‡Œ'ï¼‰
                        if (originalName === 'here/è¿™é‡Œ') {
                            displayText = currentLang === 'zh' ? 'è¿™é‡Œ' : 'here';
                            textColor = '#ffff00';
                            // æ›´æ–°å­˜å‚¨çš„åç§°
                            marker.userData.name = displayText;
                        }
                        // æŸ¥æ‰¾æ–‡æœ¬sprite
                        const textSprite = marker.children.find(child => child.isSprite);
                        if (textSprite) {
                            updateLabelText(textSprite, displayText, textColor);
                        }
                    }
                });
            }
        }

        // æ›´æ–°æ ‡ç­¾æ–‡æœ¬
        function updateLabelText(label, text, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;

            // æ¸…é™¤ç”»å¸ƒï¼Œä¿æŒé€æ˜èƒŒæ™¯
            context.clearRect(0, 0, canvas.width, canvas.height);

            // æ·»åŠ æ–‡å­—é˜´å½±æ•ˆæœï¼Œæé«˜å¯è¯»æ€§
            context.shadowColor = 'rgba(0, 0, 0, 0.8)';
            context.shadowBlur = 4;
            context.shadowOffsetX = 2;
            context.shadowOffsetY = 2;

            context.font = 'Bold 24px Arial';
            context.fillStyle = color || '#ffffff';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;

            if (label.material && label.material.map) {
                label.material.map.dispose();
                label.material.map = texture;
                label.material.needsUpdate = true;
            }
        }

        // æ›´æ–°æ§åˆ¶æŒ‰é’®æ–‡æœ¬
        function updateControlButtonText() {
            const langTexts = texts[currentLang];
            
            // æ—‹è½¬æŒ‰é’®
            const toggleRotationBtn = document.getElementById('toggleRotation');
            if (toggleRotationBtn) {
                // æ ¹æ®å½“å‰çŠ¶æ€å†³å®šæ˜¾ç¤ºå“ªä¸ªæ–‡æœ¬
                if (toggleRotationBtn.textContent.includes(texts['zh'].toggleButtons.rotation[0]) || 
                    toggleRotationBtn.textContent.includes(texts['en'].toggleButtons.rotation[0])) {
                    toggleRotationBtn.textContent = langTexts.toggleButtons.rotation[0]; // æš‚åœ/æš‚åœæ—‹è½¬
                } else if (toggleRotationBtn.textContent.includes(texts['zh'].toggleButtons.rotation[1]) || 
                          toggleRotationBtn.textContent.includes(texts['en'].toggleButtons.rotation[1])) {
                    toggleRotationBtn.textContent = langTexts.toggleButtons.rotation[1]; // ç»§ç»­/ç»§ç»­æ—‹è½¬
                } else if (toggleRotationBtn.textContent.includes(texts['zh'].toggleButtons.rotation[2]) || 
                          toggleRotationBtn.textContent.includes(texts['en'].toggleButtons.rotation[2])) {
                    toggleRotationBtn.textContent = langTexts.toggleButtons.rotation[2]; // æ¢å¤/æ¢å¤æ—‹è½¬
                }
            }
            
            // é‡ç½®æŒ‰é’®
            const resetViewBtn = document.getElementById('resetView');
            if (resetViewBtn) {
                resetViewBtn.textContent = langTexts.toggleButtons.reset;
            }
            
            // æ˜¾ç¤º/éšè—æŒ‰é’® - ç›´æ¥æ ¹æ®æ˜¾ç¤ºçŠ¶æ€æ›´æ–°
            const toggleLatLonBtn = document.getElementById('toggleLatLon');
            if (toggleLatLonBtn) {
                const isVisible = !toggleLatLonBtn.textContent.includes(texts['zh'].toggleButtons.latLon[1]) &&
                                    !toggleLatLonBtn.textContent.includes(texts['en'].toggleButtons.latLon[1]);
                toggleLatLonBtn.textContent = isVisible ? langTexts.toggleButtons.latLon[1] : langTexts.toggleButtons.latLon[0];
            }

            const toggleEquatorBtn = document.getElementById('toggleEquator');
            if (toggleEquatorBtn) {
                const isVisible = !toggleEquatorBtn.textContent.includes(texts['zh'].toggleButtons.equator[1]) &&
                                    !toggleEquatorBtn.textContent.includes(texts['en'].toggleButtons.equator[1]);
                toggleEquatorBtn.textContent = isVisible ? langTexts.toggleButtons.equator[1] : langTexts.toggleButtons.equator[0];
            }

            const toggleCanCapBtn = document.getElementById('toggleCanCap');
            if (toggleCanCapBtn) {
                const isVisible = !toggleCanCapBtn.textContent.includes(texts['zh'].toggleButtons.tropic[1]) &&
                                    !toggleCanCapBtn.textContent.includes(texts['en'].toggleButtons.tropic[1]);
                toggleCanCapBtn.textContent = isVisible ? langTexts.toggleButtons.tropic[1] : langTexts.toggleButtons.tropic[0];
            }

            const toggleArcAntBtn = document.getElementById('toggleArcAnt');
            if (toggleArcAntBtn) {
                const isVisible = !toggleArcAntBtn.textContent.includes(texts['zh'].toggleButtons.arcAnt[1]) &&
                                    !toggleArcAntBtn.textContent.includes(texts['en'].toggleButtons.arcAnt[1]);
                toggleArcAntBtn.textContent = isVisible ? langTexts.toggleButtons.arcAnt[1] : langTexts.toggleButtons.arcAnt[0];
            }
            
            // åŸå¸‚ã€å±±å³°ã€æ¹–æ³Šã€æ²³æµæŒ‰é’®
            updateVisibilityButton('toggleCities', langTexts.toggleButtons.cities);
            updateVisibilityButton('togglePeaks', langTexts.toggleButtons.peaks);
            updateVisibilityButton('toggleLakes', langTexts.toggleButtons.lakes);
            updateVisibilityButton('toggleRivers', langTexts.toggleButtons.rivers);
            
            // ä½ç½®æ ‡è®°åŠŸèƒ½æŒ‰é’®
            const getLocationBtn = document.getElementById('getCurrentLocation');
            if (getLocationBtn) {
                getLocationBtn.textContent = langTexts.toggleButtons.getLocation;
            }
            
            const clearMarkersBtn = document.getElementById('clearCustomMarkers');
            if (clearMarkersBtn) {
                clearMarkersBtn.textContent = langTexts.toggleButtons.clearMarkers;
            }
            
            // æ›´æ–°å½“å‰ä½ç½®æ ‡è®°æ ‡é¢˜
            const locationMarkersTitle = document.getElementById('locationMarkersTitle');
            if (locationMarkersTitle) {
                locationMarkersTitle.textContent = langTexts.toggleButtons.locationMarkersTitle;
            }
        }
        
        // è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°æ˜¾ç¤º/éšè—æŒ‰é’®æ–‡æœ¬
        function updateVisibilityButton(buttonId, textsArray) {
            const btn = document.getElementById(buttonId);
            if (btn) {
                // æ£€æŸ¥å½“å‰æŒ‰é’®æ–‡æœ¬æ˜¯å¦åŒ…å«æ˜¾ç¤ºæˆ–éšè—çš„æ–‡æœ¬
                const hasValidText = btn.textContent.includes(texts['zh'].toggleButtons.cities[0]) ||
                    btn.textContent.includes(texts['en'].toggleButtons.cities[0]) ||
                    btn.textContent.includes(texts['zh'].toggleButtons.cities[1]) ||
                    btn.textContent.includes(texts['en'].toggleButtons.cities[1]) ||
                    btn.textContent.includes(texts['zh'].toggleButtons.peaks[0]) ||
                    btn.textContent.includes(texts['en'].toggleButtons.peaks[0]) ||
                    btn.textContent.includes(texts['zh'].toggleButtons.peaks[1]) ||
                    btn.textContent.includes(texts['en'].toggleButtons.peaks[1]) ||
                    btn.textContent.includes(texts['zh'].toggleButtons.lakes[0]) ||
                    btn.textContent.includes(texts['en'].toggleButtons.lakes[0]) ||
                    btn.textContent.includes(texts['zh'].toggleButtons.lakes[1]) ||
                    btn.textContent.includes(texts['en'].toggleButtons.lakes[1]) ||
                    btn.textContent.includes(texts['zh'].toggleButtons.rivers[0]) ||
                    btn.textContent.includes(texts['en'].toggleButtons.rivers[0]) ||
                    btn.textContent.includes(texts['zh'].toggleButtons.rivers[1]) ||
                    btn.textContent.includes(texts['en'].toggleButtons.rivers[1]);

                if (hasValidText) {
                    // åˆ¤æ–­å½“å‰æ˜¯å¦ä¸ºéšè—çŠ¶æ€(åŒ…å«"éšè—"æˆ–"Hide"æ–‡æœ¬)
                    const isHidden = btn.textContent.includes(texts['zh'].toggleButtons.cities[0]) ||
                                    btn.textContent.includes(texts['en'].toggleButtons.cities[0]) ||
                                    btn.textContent.includes(texts['zh'].toggleButtons.peaks[0]) ||
                                    btn.textContent.includes(texts['en'].toggleButtons.peaks[0]) ||
                                    btn.textContent.includes(texts['zh'].toggleButtons.lakes[0]) ||
                                    btn.textContent.includes(texts['en'].toggleButtons.lakes[0]) ||
                                    btn.textContent.includes(texts['zh'].toggleButtons.rivers[0]) ||
                                    btn.textContent.includes(texts['en'].toggleButtons.rivers[0]);

                    // ç›´æ¥æ ¹æ®æ˜¾ç¤ºçŠ¶æ€æ›´æ–°ä¸ºå¯¹åº”çš„è¯­è¨€æ–‡æœ¬
                    btn.textContent = isHidden ? textsArray[0] : textsArray[1];
                }
            }
        }
        
        // æ›´æ–°è¯´æ˜æ–‡å­—
        function updateInstructionsText() {
            const instructionsEl = document.getElementById('instructions');
            if (instructionsEl) {
                // æ ¹æ®å½“å‰å±‚çº§æ›´æ–°è¯´æ˜æ–‡å­—
                if (currentLevel === 'galaxy') {
                    instructionsEl.innerHTML = texts[currentLang].instructions.galaxy;
                } else if (currentLevel === 'solar') {
                    instructionsEl.innerHTML = texts[currentLang].instructions.solar;
                } else if (currentLevel === 'earth') {
                    instructionsEl.innerHTML = texts[currentLang].instructions.earth;
                }
            }
        }

        // æ›´æ–°çŠ¶æ€æ–‡æœ¬
        function updateStatusText() {
            const peaksStatus = document.getElementById('peaksStatus');
            const citiesStatus = document.getElementById('citiesStatus');
            const lakesStatus = document.getElementById('lakesStatus');
            const riversStatus = document.getElementById('riversStatus');

            if (peaksStatus) {
                const isShown = showPeaks;
                peaksStatus.textContent = texts[currentLang].statusText.peaks[isShown ? 0 : 1];
            }

            if (citiesStatus) {
                const isShown = showCities;
                citiesStatus.textContent = texts[currentLang].statusText.cities[isShown ? 0 : 1];
            }

            if (lakesStatus) {
                const isShown = showLakes;
                lakesStatus.textContent = texts[currentLang].statusText.lakes[isShown ? 0 : 1];
            }

            if (riversStatus) {
                const isShown = showRivers;
                riversStatus.textContent = texts[currentLang].statusText.rivers[isShown ? 0 : 1];
            }
        }
        
        // ===== å…¨å±€å˜é‡ =====
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let currentLevel = 'galaxy'; // galaxy, solar, earth
        let earthControlsInitialized = false; // æ ‡å¿—ï¼šåœ°çƒæ§åˆ¶é¢æ¿æ˜¯å¦å·²åˆå§‹åŒ–
        let animationId;
        
        // æ§åˆ¶é¢æ¿çŠ¶æ€å˜é‡
        let panelToggleCount = 0;
		let panelToggleFlag = true;
        let isPanelVisible = true;
        let showingCredits = false;
        
        // å±‚çº§å¯¹è±¡
        let galaxy, solarSystem, earthSystem;
        let galaxyStars = [];
        let planets = [];
        let moon = null;
        let asteroidBelt = [];
        let comets = []; // å½—æ˜Ÿæ•°ç»„
        let kuiperBelt = []; // æŸ¯ä¼Šä¼¯å¸¦æ•°ç»„
        let oortCloud = []; // å¥¥å°”ç‰¹äº‘æ•°ç»„
        let earthStarfield = null;
        let solarStarfield = null;
        
        // åˆ›å»ºçƒå‹ç²’å­çº¹ç†
        function createSphereTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            // åˆ›å»ºå¾„å‘æ¸å˜ï¼Œæ¨¡æ‹Ÿçƒä½“æ•ˆæœ
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // åˆ›å»ºè¡Œæ˜Ÿçº¹ç†
        function createPlanetTexture(planetName) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // æ ¹æ®è¡Œæ˜Ÿç±»å‹ç”Ÿæˆä¸åŒçº¹ç†
            switch(planetName) {
                case 'æ°´æ˜Ÿ':
                case 'Mercury':
                    // æ°´æ˜Ÿï¼šç°è‰²ã€å¸ƒæ»¡é™¨çŸ³å‘
                    createMercuryTexture(ctx);
                    break;
                case 'é‡‘æ˜Ÿ':
                case 'Venus':
                    // é‡‘æ˜Ÿï¼šé»„ç™½è‰²ã€äº‘å±‚è¦†ç›–
                    createVenusTexture(ctx);
                    break;
                case 'ç«æ˜Ÿ':
                case 'Mars':
                    // ç«æ˜Ÿï¼šçº¢è‰²ã€æœ‰æå† å’Œæš—è‰²åŒºåŸŸ
                    createMarsTexture(ctx);
                    break;
                case 'æœ¨æ˜Ÿ':
                case 'Jupiter':
                    // æœ¨æ˜Ÿï¼šæ¡çº¹çŠ¶ã€å¤§çº¢æ–‘
                    createJupiterTexture(ctx);
                    break;
                case 'åœŸæ˜Ÿ':
                case 'Saturn':
                    // åœŸæ˜Ÿï¼šæ·¡é»„è‰²æ¡çº¹
                    createSaturnTexture(ctx);
                    break;
                case 'å¤©ç‹æ˜Ÿ':
                case 'Uranus':
                    // å¤©ç‹æ˜Ÿï¼šé’è‰²
                    createUranusTexture(ctx);
                    break;
                case 'æµ·ç‹æ˜Ÿ':
                case 'Neptune':
                    // æµ·ç‹æ˜Ÿï¼šæ·±è“è‰²
                    createNeptuneTexture(ctx);
                    break;
                default:
                    ctx.fillStyle = '#888888';
                    ctx.fillRect(0, 0, 512, 512);
            }
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // æ°´æ˜Ÿçº¹ç†ï¼šç°è‰²ã€é™¨çŸ³å‘
        function createMercuryTexture(ctx) {
            // åŸºç¡€ç°è‰²
            const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            gradient.addColorStop(0, '#a0a0a0');
            gradient.addColorStop(1, '#606060');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // é™¨çŸ³å‘
            for (let i = 0; i < 150; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const radius = Math.random() * 20 + 5;
                
                const craterGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                craterGradient.addColorStop(0, '#505050');
                craterGradient.addColorStop(0.7, '#707070');
                craterGradient.addColorStop(1, '#808080');
                ctx.fillStyle = craterGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // é‡‘æ˜Ÿçº¹ç†ï¼šé»„ç™½è‰²äº‘å±‚
        function createVenusTexture(ctx) {
            // åŸºç¡€é»„ç™½è‰²
            ctx.fillStyle = '#f5e6d3';
            ctx.fillRect(0, 0, 512, 512);
            
            // äº‘å±‚çº¹ç†
            for (let i = 0; i < 300; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const width = Math.random() * 100 + 50;
                const height = Math.random() * 30 + 10;
                
                ctx.fillStyle = `rgba(${200 + Math.random() * 50}, ${180 + Math.random() * 50}, ${140 + Math.random() * 40}, 0.3)`;
                ctx.beginPath();
                ctx.ellipse(x, y, width, height, Math.random() * Math.PI, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // ç«æ˜Ÿçº¹ç†ï¼šçº¢è‰²ã€æå† ã€æš—åŒº
        function createMarsTexture(ctx) {
            // åŸºç¡€çº¢è‰²
            const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            gradient.addColorStop(0, '#cd5c5c');
            gradient.addColorStop(1, '#8b3a3a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // æš—è‰²åŒºåŸŸï¼ˆå¤ä»£æµ·æ´‹ï¼‰
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const radius = Math.random() * 80 + 40;
                
                ctx.fillStyle = `rgba(100, 50, 40, ${0.3 + Math.random() * 0.3})`;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // æå† ï¼ˆç™½è‰²ï¼‰
            const polarGradient1 = ctx.createRadialGradient(256, 50, 0, 256, 50, 60);
            polarGradient1.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            polarGradient1.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = polarGradient1;
            ctx.beginPath();
            ctx.arc(256, 50, 60, 0, Math.PI * 2);
            ctx.fill();
            
            const polarGradient2 = ctx.createRadialGradient(256, 462, 0, 256, 462, 60);
            polarGradient2.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            polarGradient2.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = polarGradient2;
            ctx.beginPath();
            ctx.arc(256, 462, 60, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // æœ¨æ˜Ÿçº¹ç†ï¼šæ¡çº¹ã€å¤§çº¢æ–‘
        function createJupiterTexture(ctx) {
            // ç»˜åˆ¶æ¡çº¹
            const stripes = 20;
            for (let i = 0; i < stripes; i++) {
                const y = (i / stripes) * 512;
                const height = 512 / stripes;
                
                // äº¤æ›¿é¢œè‰²
                const colors = ['#c9b791', '#b8926a', '#dcc8a0', '#a67c52'];
                ctx.fillStyle = colors[i % colors.length];
                ctx.fillRect(0, y, 512, height);
                
                // æ·»åŠ å™ªç‚¹
                for (let j = 0; j < 100; j++) {
                    const x = Math.random() * 512;
                    const py = y + Math.random() * height;
                    ctx.fillStyle = `rgba(${180 + Math.random() * 50}, ${140 + Math.random() * 50}, ${100 + Math.random() * 40}, 0.3)`;
                    ctx.fillRect(x, py, 3, 3);
                }
            }
            
            // å¤§çº¢æ–‘
            const spotX = 380;
            const spotY = 300;
            const spotGradient = ctx.createRadialGradient(spotX, spotY, 0, spotX, spotY, 50);
            spotGradient.addColorStop(0, '#d4645c');
            spotGradient.addColorStop(0.5, '#b85450');
            spotGradient.addColorStop(1, 'rgba(184, 84, 80, 0)');
            ctx.fillStyle = spotGradient;
            ctx.beginPath();
            ctx.ellipse(spotX, spotY, 60, 40, 0.3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // åœŸæ˜Ÿçº¹ç†ï¼šæ·¡é»„è‰²æ¡çº¹
        function createSaturnTexture(ctx) {
            // ç»˜åˆ¶æ¡çº¹
            const stripes = 25;
            for (let i = 0; i < stripes; i++) {
                const y = (i / stripes) * 512;
                const height = 512 / stripes;
                
                // æ·¡é»„è‰²è°ƒ
                const brightness = 220 + Math.random() * 35;
                ctx.fillStyle = `rgb(${brightness}, ${brightness - 20}, ${brightness - 40})`;
                ctx.fillRect(0, y, 512, height);
            }
        }
        
        // å¤©ç‹æ˜Ÿçº¹ç†ï¼šé’è‰²
        function createUranusTexture(ctx) {
            const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            gradient.addColorStop(0, '#b0e0e6');
            gradient.addColorStop(1, '#5f9ea0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // æ·¡æ·¡çš„äº‘å±‚
            for (let i = 0; i < 50; i++) {
                const y = Math.random() * 512;
                ctx.fillStyle = `rgba(160, 200, 210, ${0.1 + Math.random() * 0.2})`;
                ctx.fillRect(0, y, 512, Math.random() * 20 + 5);
            }
        }
        
        // æµ·ç‹æ˜Ÿçº¹ç†ï¼šæ·±è“è‰²
        function createNeptuneTexture(ctx) {
            const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            gradient.addColorStop(0, '#4169e1');
            gradient.addColorStop(1, '#191970');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // æ·±è‰²é£æš´
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const radius = Math.random() * 40 + 20;
                
                const stormGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                stormGradient.addColorStop(0, 'rgba(25, 25, 112, 0.6)');
                stormGradient.addColorStop(1, 'rgba(25, 25, 112, 0)');
                ctx.fillStyle = stormGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // åˆ›å»ºæœˆçƒçº¹ç†
        function createMoonTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // åŸºç¡€ç°è‰²
            const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            gradient.addColorStop(0, '#c0c0c0');
            gradient.addColorStop(1, '#808080');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // ç¯å½¢å±±ï¼ˆé™¨çŸ³å‘ï¼‰
            for (let i = 0; i < 200; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const radius = Math.random() * 30 + 5;
                
                // å¤–ç¯
                const craterGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                craterGradient.addColorStop(0, '#606060');
                craterGradient.addColorStop(0.6, '#909090');
                craterGradient.addColorStop(0.8, '#b0b0b0');
                craterGradient.addColorStop(1, '#808080');
                ctx.fillStyle = craterGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // ä¸­å¿ƒå‡¹é™·
                ctx.fillStyle = '#505050';
                ctx.beginPath();
                ctx.arc(x, y, radius * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // æœˆæµ·ï¼ˆæš—è‰²åŒºåŸŸï¼‰
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const radius = Math.random() * 100 + 50;
                
                ctx.fillStyle = `rgba(70, 70, 70, ${0.3 + Math.random() * 0.3})`;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        const sphereParticleTexture = createSphereTexture();
        
        // ç›¸æœºå‚æ•°
        const cameraPositions = {
            galaxy: { position: new THREE.Vector3(0, 50, 100), target: new THREE.Vector3(0, 0, 0) },
            solar: { position: new THREE.Vector3(0, 20, 40), target: new THREE.Vector3(0, 0, 0) },
            earth: { position: new THREE.Vector3(0, 0, 10), target: new THREE.Vector3(0, 0, 0) }
        };
        
        // è½¬é€Ÿæ§åˆ¶å˜é‡
        let galaxyRotationSpeed = 1.0;
        let solarRotationSpeed = 0.25;
        
        // åœ°çƒç›¸å…³å˜é‡ï¼ˆä»åŸå§‹åœ°çƒæ¨¡å‹æ•´åˆï¼‰
        let earth, clouds, earthGroup;
        let isRotating = true;
        let rotationSpeed = 0.25; // åˆå§‹è½¬é€Ÿè®¾ç½®ä¸º25%
        let showCities = true, showPeaks = true, showLakes = true, showRivers = true;
        
        // è‡ªå®šä¹‰æ ‡è®°å˜é‡
        let customMarkersGroup = null;
        let customMarkers = [];
        let animationUpdates = [];
        let showEquator = false, showTropic = false, showTonLat = false, showArcAnt = false, showNames = false;
        let citiesGroup, peaksGroup, lakesGroup, riversGroup, equatorGroup, tropicGroup, arcAntGroup, latLonGroup, timezoneLabelsGroup, bordersGroup;
        let namesGroup;
        // å­˜å‚¨æ‰€æœ‰æ ‡ç­¾å¼•ç”¨,ç”¨äºè¯­è¨€åˆ‡æ¢æ—¶æ›´æ–°
        let cityLabels = [], peakLabels = [], lakeLabels = [], riverLabels = [];
        // ===== åˆå§‹åŒ– =====
        function init() {
            const container = document.getElementById('universe-container');
            
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            
            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.copy(cameraPositions.galaxy.position);
            
            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            // æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 500;
            
            // å…‰æº
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);
            
            // å°„çº¿æ£€æµ‹
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // æ·»åŠ äº‹ä»¶ç›‘å¬
            container.addEventListener('mousemove', onMouseMove);
            container.addEventListener('click', onClick);
            window.addEventListener('resize', onWindowResize);
            
            // åˆ›å»ºå®‡å®™å±‚çº§
            createGalaxy();
            createSolarSystem();
            createEarthSystem(); // è¿™å°†åŒ…å«å®Œæ•´çš„åœ°çƒæ¨¡å‹
            
            // éšè—åŠ è½½ç•Œé¢
            document.getElementById('loading').style.display = 'none';
            
            // è®¾ç½®é“¶æ²³ç³»å±‚çº§æ§åˆ¶ï¼ˆåˆå§‹åŒ–æ—¶è°ƒç”¨ï¼‰
            setupGalaxyControls();
            
            // å¼€å§‹åŠ¨ç”»
            animate();
            
            // æ›´æ–°å¯¼èˆªæŒ‰é’®æ˜¾ç¤º
            updateNavButtons();
        }
        
        // ===== é“¶æ²³ç³»åˆ›å»º =====
        function createGalaxy() {
            galaxy = new THREE.Group();

            // åˆ›å»ºã€Šæ˜Ÿé™…ç©¿è¶Šã€‹é£æ ¼çš„é»‘æ´æ¨¡å‹ - ä¸‰ç»´ç«‹ä½“ç‰ˆ
            const blackHoleGroup = new THREE.Group();

            // 1. äº‹ä»¶è§†ç•Œï¼ˆEvent Horizonï¼‰- çº¯é»‘è‰²çƒä½“ï¼Œç»å¯¹é»‘æš—
            const eventHorizonGeometry = new THREE.SphereGeometry(5, 128, 128);
            const eventHorizonMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: false,
                opacity: 1.0
            });
            const eventHorizon = new THREE.Mesh(eventHorizonGeometry, eventHorizonMaterial);
            blackHoleGroup.add(eventHorizon);

            // 2. å…‰å­çƒå±‚ï¼ˆPhoton Sphereï¼‰- æœ€é è¿‘äº‹ä»¶è§†ç•Œçš„æäº®å…‰ç¯
            const photonSphereGeometry = new THREE.RingGeometry(5.5, 6.5, 128);
            const photonSphereMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const photonSphere = new THREE.Mesh(photonSphereGeometry, photonSphereMaterial);
            photonSphere.rotation.x = Math.PI / 2;
            blackHoleGroup.add(photonSphere);

            // 3. ä¸‰ç»´æ‰­æ›²å¸ç§¯ç›˜ - å†…ç›˜ï¼ˆæœ€çƒ­åŒºåŸŸï¼‰
            function createTwistedDisk(innerRadius, outerRadius, color, opacity, tiltAngle) {
                const segments = 256;
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    for (let j = 0; j <= 32; j++) {
                        const radius = innerRadius + (outerRadius - innerRadius) * (j / 32);
                        // æ ¹æ®è§’åº¦æ·»åŠ é«˜åº¦å˜åŒ–ï¼Œåˆ›å»ºæ‰­æ›²æ•ˆæœ
                        const heightOffset = Math.sin(angle * 2) * radius * 0.08;
                        const x = Math.cos(angle) * radius;
                        const y = heightOffset;
                        const z = Math.sin(angle) * radius;
                        
                        positions.push(x, y, z);
                        
                        // æ ¹æ®åŠå¾„è°ƒæ•´é¢œè‰²äº®åº¦
                        const brightness = 1 - (j / 32) * 0.3;
                        const c = new THREE.Color(color);
                        c.multiplyScalar(brightness);
                        colors.push(c.r, c.g, c.b);
                    }
                }
                
                const indices = [];
                for (let i = 0; i < segments; i++) {
                    for (let j = 0; j < 32; j++) {
                        const a = i * 33 + j;
                        const b = i * 33 + j + 1;
                        const c = (i + 1) * 33 + j + 1;
                        const d = (i + 1) * 33 + j;
                        
                        indices.push(a, b, d);
                        indices.push(b, c, d);
                    }
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                const material = new THREE.MeshBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: opacity,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = tiltAngle;
                return mesh;
            }
            
            const innerDisk = createTwistedDisk(6.8, 11, 0xffddaa, 1.0, Math.PI / 2.2);
            blackHoleGroup.add(innerDisk);

            const mainDisk = createTwistedDisk(11, 17, 0xffaa44, 0.95, Math.PI / 2.1);
            blackHoleGroup.add(mainDisk);

            const outerDisk = createTwistedDisk(17, 26, 0xff9933, 0.75, Math.PI / 2);
            blackHoleGroup.add(outerDisk);

            // 4. ä¸‰ç»´å¸ç§¯ç²’å­æµ - æ¨¡æ‹Ÿç‰©è´¨èºæ—‹è½å…¥é»‘æ´ï¼ˆå¢å¼ºç‰ˆï¼‰
            const accretionParticleCount = 8000; // ä»3000å¢åŠ åˆ°8000
            const accretionGeometry = new THREE.BufferGeometry();
            const accretionPositions = new Float32Array(accretionParticleCount * 3);
            const accretionColors = new Float32Array(accretionParticleCount * 3);
            const accretionAngles = new Float32Array(accretionParticleCount);
            const accretionRadii = new Float32Array(accretionParticleCount);
            const accretionHeights = new Float32Array(accretionParticleCount);
            
            for (let i = 0; i < accretionParticleCount; i++) {
                const radius = 7 + Math.random() * 25;
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * radius * 0.3;
                
                accretionAngles[i] = angle;
                accretionRadii[i] = radius;
                accretionHeights[i] = height;
                
                accretionPositions[i * 3] = Math.cos(angle) * radius;
                accretionPositions[i * 3 + 1] = height;
                accretionPositions[i * 3 + 2] = Math.sin(angle) * radius;
                
                // å†…éƒ¨æ›´äº®
                const brightness = 1 - (radius / 32);
                const c = new THREE.Color(0xffaa44);
                c.multiplyScalar(brightness * 1.5);
                accretionColors[i * 3] = c.r;
                accretionColors[i * 3 + 1] = c.g;
                accretionColors[i * 3 + 2] = c.b;
            }
            
            accretionGeometry.setAttribute('position', new THREE.Float32BufferAttribute(accretionPositions, 3));
            accretionGeometry.setAttribute('color', new THREE.Float32BufferAttribute(accretionColors, 3));
            accretionGeometry.userData = {
                angles: accretionAngles,
                radii: accretionRadii,
                heights: accretionHeights
            };
            
            const accretionMaterial = new THREE.PointsMaterial({
                size: 1.0, // ç¨å¾®å¢å¤§ä»¥é…åˆçƒå‹çº¹ç†
                vertexColors: true,
                transparent: true,
                opacity: 0.85,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                map: sphereParticleTexture, // ä½¿ç”¨çƒå‹çº¹ç†
                alphaTest: 0.01
            });
            
            const accretionParticles = new THREE.Points(accretionGeometry, accretionMaterial);
            blackHoleGroup.add(accretionParticles);

            // 5. å¼•åŠ›é€é•œä¸‰ç»´å…‰ç¯ - æ›´å¤šå±‚æ¬¡çš„ç¯å½¢ç»“æ„
            for (let i = 0; i < 5; i++) {
                const radius = 8 + i * 1.5;
                const yPos = 3 + i * 0.8;
                const lensingGeometry = new THREE.TorusGeometry(radius, 0.8 - i * 0.1, 16, 100);
                const lensingMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffcc66,
                    transparent: true,
                    opacity: 0.4 - i * 0.06,
                    blending: THREE.AdditiveBlending
                });
                const lensingRing = new THREE.Mesh(lensingGeometry, lensingMaterial);
                lensingRing.position.y = yPos;
                lensingRing.rotation.x = Math.PI * 0.1 * i;
                blackHoleGroup.add(lensingRing);
                
                // æ·»åŠ ä¸‹æ–¹å¯¹ç§°ç¯
                const lensingRingBottom = lensingRing.clone();
                lensingRingBottom.position.y = -yPos;
                lensingRingBottom.rotation.x = -Math.PI * 0.1 * i;
                blackHoleGroup.add(lensingRingBottom);
            }

            // 6. ä¸‰ç»´å–·æµç²’å­ç³»ç»Ÿï¼ˆå¢å¼ºç‰ˆ - æ›´é•¿æ›´å£®è§‚ï¼‰
            function createJetParticles(direction) {
                const jetParticleCount = 6000; // ä»4000å¢åŠ åˆ°6000
                const jetGeometry = new THREE.BufferGeometry();
                const jetPositions = new Float32Array(jetParticleCount * 3);
                const jetColors = new Float32Array(jetParticleCount * 3);
                const jetSpeeds = new Float32Array(jetParticleCount);
                const jetSizes = new Float32Array(jetParticleCount); // æ–°å¢ï¼šå­˜å‚¨ç²’å­å¤§å°
                
                for (let i = 0; i < jetParticleCount; i++) {
                    const height = Math.random() * 80; // ä»35å¢åŠ åˆ°80ï¼Œå¢åŠ é•¿åº¦
                    // é”¥å½¢å–·æµï¼šåº•éƒ¨ç»†ï¼Œé¡¶éƒ¨é€æ¸æ‰©æ•£
                    const baseRadius = 0.3;
                    const topRadius = 5;
                    const radius = baseRadius + (height / 80) * topRadius;
                    const angle = Math.random() * Math.PI * 2;
                    
                    // æ·»åŠ å¾„å‘åç§»ï¼Œä½¿å–·æµæ›´è‡ªç„¶
                    const radialVariation = (Math.random() - 0.5) * radius * 0.3;
                    const finalRadius = radius + radialVariation;
                    
                    jetPositions[i * 3] = Math.cos(angle) * finalRadius;
                    jetPositions[i * 3 + 1] = height * direction;
                    jetPositions[i * 3 + 2] = Math.sin(angle) * finalRadius;
                    
                    jetSpeeds[i] = 0.3 + Math.random() * 1.2;
                    
                    // ç²’å­å¤§å°éšé«˜åº¦å˜åŒ–
                    jetSizes[i] = 1.2 + (height / 80) * 0.8;
                    
                    // é¢œè‰²æ¸å˜ï¼šåº•éƒ¨äº®è“ç™½è‰²ï¼Œé¡¶éƒ¨æš—è“è‰²
                    const brightness = 1.2 - (height / 80) * 0.8;
                    const hue = 0.55 + (height / 80) * 0.05; // ä»é’è“åˆ°æ·±è“
                    const c = new THREE.Color();
                    c.setHSL(hue, 0.8, brightness * 0.6);
                    jetColors[i * 3] = c.r;
                    jetColors[i * 3 + 1] = c.g;
                    jetColors[i * 3 + 2] = c.b;
                }
                
                jetGeometry.setAttribute('position', new THREE.Float32BufferAttribute(jetPositions, 3));
                jetGeometry.setAttribute('color', new THREE.Float32BufferAttribute(jetColors, 3));
                jetGeometry.userData = { 
                    speeds: jetSpeeds, 
                    direction: direction,
                    sizes: jetSizes
                };
                
                const jetMaterial = new THREE.PointsMaterial({
                    size: 1.8, // å¢å¤§åŸºç¡€ç²’å­å¤§å°
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.75,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    map: sphereParticleTexture,
                    alphaTest: 0.01
                });
                
                return new THREE.Points(jetGeometry, jetMaterial);
            }
            
            const jetTop = createJetParticles(1);
            blackHoleGroup.add(jetTop);
            
            const jetBottom = createJetParticles(-1);
            blackHoleGroup.add(jetBottom);
            
            // 6.5 å–·æµæ ¸å¿ƒå…‰æŸ± - å¢å¼ºå–·æµä¸­å¿ƒ
            function createJetCore(direction) {
                const coreGeometry = new THREE.CylinderGeometry(0.2, 1.5, 70, 16, 1, true);
                const coreMaterial = new THREE.MeshBasicMaterial({
                    color: 0xaaddff,
                    transparent: true,
                    opacity: 0.5,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                core.position.y = 35 * direction;
                return core;
            }
            
            const jetCoreTop = createJetCore(1);
            blackHoleGroup.add(jetCoreTop);
            
            const jetCoreBottom = createJetCore(-1);
            blackHoleGroup.add(jetCoreBottom);

            // 7. ä½“ç§¯é›¾æ•ˆæœ - å¢å¼ºæ·±åº¦æ„Ÿ
            const fogSphereCount = 8;
            for (let i = 0; i < fogSphereCount; i++) {
                const radius = 8 + i * 4;
                const fogGeometry = new THREE.SphereGeometry(radius, 32, 32);
                const fogMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff8844,
                    transparent: true,
                    opacity: 0.03 - i * 0.003,
                    side: THREE.BackSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const fogSphere = new THREE.Mesh(fogGeometry, fogMaterial);
                blackHoleGroup.add(fogSphere);
            }

            // 8. å¤–éƒ¨å…‰æ™•ï¼ˆå¼±å¼•åŠ›åœºæ•ˆåº”ï¼‰
            const outerHaloGeometry = new THREE.RingGeometry(28, 45, 128);
            const outerHaloMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa66,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const outerHalo = new THREE.Mesh(outerHaloGeometry, outerHaloMaterial);
            outerHalo.rotation.x = Math.PI / 2;
            blackHoleGroup.add(outerHalo);

            galaxy.add(blackHoleGroup);
            
            // åˆ›å»ºé“¶æ²³ç›˜é¢çš„æ˜Ÿæ˜Ÿï¼ˆå¤§å¹…å¢åŠ æ•°é‡ä»¥æ¨¡æ‹ŸçœŸå®é“¶æ²³ç³»ï¼‰
            const starCount = 25000; // ä»15000å¢åŠ åˆ°25000
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = new Float32Array(starCount * 3);
            const starColors = new Float32Array(starCount * 3);
            const starDistances = new Float32Array(starCount); // å­˜å‚¨æ¯é¢—æ’æ˜Ÿçš„è·ç¦»
            const starAngles = new Float32Array(starCount); // å­˜å‚¨æ¯é¢—æ’æ˜Ÿçš„å½“å‰è§’åº¦
            const starOffsets = new Float32Array(starCount * 2); // å­˜å‚¨æ¯é¢—æ’æ˜Ÿçš„éšæœºåç§»ï¼ˆä¿æŒç›¸å¯¹ä½ç½®ï¼‰

            for (let i = 0; i < starCount; i++) {
                const armIndex = Math.floor(Math.random() * 4);
                const armAngle = (armIndex * Math.PI * 2) / 4;
                const radius = Math.random() * 80 + 10;
                const spiralAngle = armAngle + radius * 0.1;

                const offsetX = (Math.random() - 0.5) * 10;
                const offsetZ = (Math.random() - 0.5) * 10;

                const x = Math.cos(spiralAngle) * radius + offsetX;
                const z = Math.sin(spiralAngle) * radius + offsetZ;
                const y = (Math.random() - 0.5) * 5;

                starPositions[i * 3] = x;
                starPositions[i * 3 + 1] = y;
                starPositions[i * 3 + 2] = z;

                // å­˜å‚¨è·ç¦»ï¼ˆç”¨äºå¼€æ™®å‹’æ—‹è½¬ï¼‰
                starDistances[i] = radius;
                // å­˜å‚¨åˆå§‹è§’åº¦
                starAngles[i] = spiralAngle;
                // å­˜å‚¨åç§»é‡ï¼Œä¿æŒç›¸å¯¹ä½ç½®
                starOffsets[i * 2] = offsetX;
                starOffsets[i * 2 + 1] = offsetZ;

                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.2 + 0.5, 0.5, Math.random() * 0.5 + 0.5);
                starColors[i * 3] = color.r;
                starColors[i * 3 + 1] = color.g;
                starColors[i * 3 + 2] = color.b;
            }

            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
            starGeometry.userData = {
                distances: starDistances,
                angles: starAngles,
                offsets: starOffsets
            };
            
            const starMaterial = new THREE.PointsMaterial({
                size: 0.6, // ç¨å¾®å¢å¤§ä¸€ç‚¹
                vertexColors: true,
                transparent: true,
                opacity: 0.85,
                map: sphereParticleTexture, // ä½¿ç”¨ç»Ÿä¸€çš„çƒå‹çº¹ç†
                blending: THREE.AdditiveBlending,
                alphaTest: 0.01
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            galaxy.add(stars);

            // æ·»åŠ å¤ªé˜³ç³»æ ‡è®°ï¼ˆé»„è‰²ï¼‰
            const solarSystemMarker = createMarker(
                new THREE.Vector3(60, 0, 20),
                0xffff00,  // é»„è‰²
                'å¤ªé˜³ç³»',
                'solar'
            );
            galaxy.add(solarSystemMarker);

            scene.add(galaxy);
        }
        
        // ===== å¤ªé˜³ç³»åˆ›å»º =====
        function createSolarSystem() {
            solarSystem = new THREE.Group();
            solarSystem.visible = false;
            
            // åˆ›å»ºå¤ªé˜³ç³»å±‚çº§æ˜Ÿç©ºèƒŒæ™¯
            createSolarStarfieldBackground();
            
            // ===== åˆ›å»ºçœŸå®å¤ªé˜³ç³»ç»Ÿ =====
            const sunGroup = new THREE.Group();
            
            // 1. å¤ªé˜³æ ¸å¿ƒï¼ˆå…‰çƒå±‚ï¼‰
            const sunGeometry = new THREE.SphereGeometry(3, 64, 64);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xfff5e6,
                transparent: true,
                opacity: 1.0
            });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sunGroup.add(sun);
            
            // 2. å¤ªé˜³è¡¨é¢çº¹ç†å±‚ï¼ˆæ¨¡æ‹Ÿå¯¹æµå±‚å’Œé¢—ç²’ç»“æ„ï¼‰
            const surfaceGeometry = new THREE.SphereGeometry(3.05, 64, 64);
            const surfaceMaterial = new THREE.MeshBasicMaterial({
                color: 0xffdd66,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            const surface = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
            sunGroup.add(surface);
            
            // 3. å¤šå±‚æ—¥å†•ï¼ˆCoronaï¼‰- 7å±‚æ¸å˜å…‰æ™•
            const coronaLayers = [
                { radius: 3.3, color: 0xffcc44, opacity: 0.4 },
                { radius: 3.6, color: 0xffaa33, opacity: 0.35 },
                { radius: 4.0, color: 0xff9922, opacity: 0.3 },
                { radius: 4.5, color: 0xff8811, opacity: 0.25 },
                { radius: 5.2, color: 0xff7700, opacity: 0.18 },
                { radius: 6.0, color: 0xff6600, opacity: 0.12 },
                { radius: 7.0, color: 0xff5500, opacity: 0.08 }
            ];
            
            coronaLayers.forEach((layer, index) => {
                const coronaGeometry = new THREE.SphereGeometry(layer.radius, 32, 32);
                const coronaMaterial = new THREE.MeshBasicMaterial({
                    color: layer.color,
                    transparent: true,
                    opacity: layer.opacity,
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide,
                    depthWrite: false
                });
                const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
                corona.userData.layerIndex = index;
                sunGroup.add(corona);
            });
            
            // 4. å¤ªé˜³é»‘å­ç²’å­ç³»ç»Ÿï¼ˆè¡¨é¢æš—æ–‘ï¼‰
            const sunspotCount = 200;
            const sunspotGeometry = new THREE.BufferGeometry();
            const sunspotPositions = new Float32Array(sunspotCount * 3);
            const sunspotColors = new Float32Array(sunspotCount * 3);
            
            for (let i = 0; i < sunspotCount; i++) {
                // åœ¨çƒé¢ä¸Šå‡åŒ€åˆ†å¸ƒ
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 3.02;
                
                sunspotPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                sunspotPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                sunspotPositions[i * 3 + 2] = radius * Math.cos(phi);
                
                const c = new THREE.Color(0x442200);
                sunspotColors[i * 3] = c.r;
                sunspotColors[i * 3 + 1] = c.g;
                sunspotColors[i * 3 + 2] = c.b;
            }
            
            sunspotGeometry.setAttribute('position', new THREE.BufferAttribute(sunspotPositions, 3));
            sunspotGeometry.setAttribute('color', new THREE.BufferAttribute(sunspotColors, 3));
            
            const sunspotMaterial = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                map: sphereParticleTexture,
                blending: THREE.NormalBlending
            });
            
            const sunspots = new THREE.Points(sunspotGeometry, sunspotMaterial);
            sunGroup.add(sunspots);
            
            // 5. å¤ªé˜³è€€æ–‘ç²’å­ç³»ç»Ÿï¼ˆè¡¨é¢æ´»åŠ¨åŒºï¼‰
            const flareCount = 800;
            const flareGeometry = new THREE.BufferGeometry();
            const flarePositions = new Float32Array(flareCount * 3);
            const flareColors = new Float32Array(flareCount * 3);
            const flareAngles = new Float32Array(flareCount * 2); // theta, phi
            
            for (let i = 0; i < flareCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 3.08 + Math.random() * 0.3;
                
                flareAngles[i * 2] = theta;
                flareAngles[i * 2 + 1] = phi;
                
                flarePositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                flarePositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                flarePositions[i * 3 + 2] = radius * Math.cos(phi);
                
                const brightness = 0.8 + Math.random() * 0.4;
                const c = new THREE.Color(0xffff88);
                c.multiplyScalar(brightness);
                flareColors[i * 3] = c.r;
                flareColors[i * 3 + 1] = c.g;
                flareColors[i * 3 + 2] = c.b;
            }
            
            flareGeometry.setAttribute('position', new THREE.BufferAttribute(flarePositions, 3));
            flareGeometry.setAttribute('color', new THREE.BufferAttribute(flareColors, 3));
            flareGeometry.userData = { angles: flareAngles };
            
            const flareMaterial = new THREE.PointsMaterial({
                size: 0.4,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                map: sphereParticleTexture,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const flares = new THREE.Points(flareGeometry, flareMaterial);
            sunGroup.add(flares);
            
            // 6. æ—¥ç¥ï¼ˆProminencesï¼‰- ä»å¤ªé˜³è¡¨é¢å–·å‘çš„ç«ç„°å¼§
            function createProminence(angle, height) {
                const prominenceParticles = 150;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(prominenceParticles * 3);
                const colors = new Float32Array(prominenceParticles * 3);
                const speeds = new Float32Array(prominenceParticles);
                
                for (let i = 0; i < prominenceParticles; i++) {
                    const t = i / prominenceParticles;
                    const arcHeight = Math.sin(t * Math.PI) * height;
                    const radius = 3 + arcHeight;
                    
                    const theta = angle + (Math.random() - 0.5) * 0.3;
                    const phi = Math.PI / 2 + (t - 0.5) * 0.8;
                    
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                    
                    speeds[i] = Math.random() * 0.02;
                    
                    const brightness = 1.2 - t * 0.5;
                    const c = new THREE.Color(0xff6633);
                    c.multiplyScalar(brightness);
                    colors[i * 3] = c.r;
                    colors[i * 3 + 1] = c.g;
                    colors[i * 3 + 2] = c.b;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.userData = { angle: angle, speeds: speeds };
                
                const material = new THREE.PointsMaterial({
                    size: 0.5,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    map: sphereParticleTexture,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                return new THREE.Points(geometry, material);
            }
            
            // åˆ›å»º4-6ä¸ªæ—¥ç¥
            const prominenceCount = 5;
            for (let i = 0; i < prominenceCount; i++) {
                const angle = (i / prominenceCount) * Math.PI * 2 + Math.random() * 0.5;
                const height = 1.5 + Math.random() * 1.0;
                const prominence = createProminence(angle, height);
                sunGroup.add(prominence);
            }
            
            // 7. å¤ªé˜³é£ç²’å­æµï¼ˆå‘å¤–è¾å°„ï¼‰
            const solarWindCount = 2000;
            const solarWindGeometry = new THREE.BufferGeometry();
            const solarWindPositions = new Float32Array(solarWindCount * 3);
            const solarWindColors = new Float32Array(solarWindCount * 3);
            const solarWindSpeeds = new Float32Array(solarWindCount);
            
            for (let i = 0; i < solarWindCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 3.5 + Math.random() * 8;
                
                solarWindPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                solarWindPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                solarWindPositions[i * 3 + 2] = radius * Math.cos(phi);
                
                solarWindSpeeds[i] = 0.02 + Math.random() * 0.03;
                
                const brightness = 1 - (radius / 11.5) * 0.7;
                const c = new THREE.Color(0xffcc88);
                c.multiplyScalar(brightness);
                solarWindColors[i * 3] = c.r;
                solarWindColors[i * 3 + 1] = c.g;
                solarWindColors[i * 3 + 2] = c.b;
            }
            
            solarWindGeometry.setAttribute('position', new THREE.BufferAttribute(solarWindPositions, 3));
            solarWindGeometry.setAttribute('color', new THREE.BufferAttribute(solarWindColors, 3));
            solarWindGeometry.userData = { speeds: solarWindSpeeds };
            
            const solarWindMaterial = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                map: sphereParticleTexture,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const solarWind = new THREE.Points(solarWindGeometry, solarWindMaterial);
            sunGroup.add(solarWind);
            
            // å°†å¤ªé˜³ç»„æ·»åŠ åˆ°å¤ªé˜³ç³»
            solarSystem.add(sunGroup);
            
            // åˆ›å»ºè¡Œæ˜Ÿ
            const planetData = [
                { name: 'æ°´æ˜Ÿ', englishName: 'Mercury', distance: 8, size: 0.3, color: 0x888888 },
                { name: 'é‡‘æ˜Ÿ', englishName: 'Venus', distance: 12, size: 0.5, color: 0xffff88 },
                { name: 'åœ°çƒ', englishName: 'Earth', distance: 16, size: 0.6, color: 0x4488ff },
                { name: 'ç«æ˜Ÿ', englishName: 'Mars', distance: 20, size: 0.4, color: 0xff4444 },
                { name: 'æœ¨æ˜Ÿ', englishName: 'Jupiter', distance: 28, size: 1.5, color: 0xffaa44 },
                { name: 'åœŸæ˜Ÿ', englishName: 'Saturn', distance: 36, size: 1.2, color: 0xffdd88 },
                { name: 'å¤©ç‹æ˜Ÿ', englishName: 'Uranus', distance: 44, size: 0.8, color: 0x44ffff },
                { name: 'æµ·ç‹æ˜Ÿ', englishName: 'Neptune', distance: 52, size: 0.8, color: 0x4444ff }
            ];
            
            planetData.forEach((data, index) => {
                // è¡Œæ˜Ÿè½¨é“
                const orbitGeometry = new THREE.RingGeometry(data.distance - 0.05, data.distance + 0.05, 64);
                const orbitMaterial = new THREE.MeshBasicMaterial({
                    color: 0x444444,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
                orbit.rotation.x = Math.PI / 2;
                solarSystem.add(orbit);
                
                // è¡Œæ˜Ÿ - ä½¿ç”¨æ›´é«˜åˆ†è¾¨ç‡
                const planetGeometry = new THREE.SphereGeometry(data.size, 64, 64);

                let planetMaterial;
                if (data.name === 'åœ°çƒ' || data.englishName === 'Earth') {
                    // åœ°çƒä½¿ç”¨NASAé«˜è´¨é‡çº¹ç†
                    const textureLoader = new THREE.TextureLoader();
                    const earthTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_atmos_2048.jpg');
                    const specularTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg');
                    const normalTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg');

                    planetMaterial = new THREE.MeshPhongMaterial({
                        map: earthTexture,
                        specularMap: specularTexture,
                        specular: new THREE.Color(0x666666),
                        shininess: 10,
                        normalMap: normalTexture,
                        normalScale: new THREE.Vector2(0.85, 0.85)
                    });
                } else {
                    // å…¶ä»–è¡Œæ˜Ÿä½¿ç”¨ç¨‹åºåŒ–çº¹ç†
                    const planetTexture = createPlanetTexture(data.name);
                    planetMaterial = new THREE.MeshPhongMaterial({
                        map: planetTexture,
                        shininess: 5,
                        specular: new THREE.Color(0x333333)
                    });
                    
                    // ä¸ºæ°”æ€å·¨è¡Œæ˜Ÿæ·»åŠ è½»å¾®é€æ˜åº¦
                    if (data.name === 'æœ¨æ˜Ÿ' || data.name === 'åœŸæ˜Ÿ' || 
                        data.name === 'å¤©ç‹æ˜Ÿ' || data.name === 'æµ·ç‹æ˜Ÿ' ||
                        data.englishName === 'Jupiter' || data.englishName === 'Saturn' || 
                        data.englishName === 'Uranus' || data.englishName === 'Neptune') {
                        planetMaterial.transparent = true;
                        planetMaterial.opacity = 0.95;
                    }
                }

                const planet = new THREE.Mesh(planetGeometry, planetMaterial);
                planet.position.x = data.distance;
                planet.userData = {
                    name: data.name,
                    englishName: data.englishName,
                    type: 'planet',
                    distance: data.distance,
                    angle: Math.random() * Math.PI * 2,
                    rotationSpeed: 0.05 // é»˜è®¤è‡ªè½¬é€Ÿåº¦
                };

                if (data.name === 'åœ°çƒ' || data.englishName === 'Earth') {
                    planet.userData.isEarth = true;
                }

                planets.push(planet);
                solarSystem.add(planet);
                
                // ä¸ºåœŸæ˜Ÿæ·»åŠ å…‰ç¯
                if (data.name === 'åœŸæ˜Ÿ' || data.englishName === 'Saturn') {
                    createSaturnRings(planet, data.size);
                }
            });
            
            // åˆ›å»ºåœŸæ˜Ÿå…‰ç¯
            function createSaturnRings(planet, planetSize) {
                const ringGeometry = new THREE.RingGeometry(planetSize * 1.3, planetSize * 2.0, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xc9b587,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const rings = new THREE.Mesh(ringGeometry, ringMaterial);
                rings.rotation.x = Math.PI / 2.2; // ç¨å¾®å€¾æ–œ
                planet.add(rings);
            }
            
            // æ·»åŠ æœˆçƒï¼ˆå›´ç»•åœ°çƒï¼‰- ä½¿ç”¨çº¹ç†
            const moonGeometry = new THREE.SphereGeometry(0.15, 32, 32);
            const moonTexture = createMoonTexture();
            const moonMaterial = new THREE.MeshPhongMaterial({
                map: moonTexture,
                shininess: 5
            });
            moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.userData = {
                name: 'æœˆçƒ',
                englishName: 'Moon',
                type: 'moon',
                distance: 1.5,
                angle: 0
            };
            solarSystem.add(moon);
            
            // æ·»åŠ å°è¡Œæ˜Ÿå¸¦ï¼ˆåœ¨ç«æ˜Ÿå’Œæœ¨æ˜Ÿä¹‹é—´ï¼‰
            createAsteroidBelt();

            // æ·»åŠ å½—æ˜Ÿç³»ç»Ÿï¼ˆåœ¨å¤ªé˜³ç³»å¤–å›´è¿è¡Œï¼‰
            createComets();

            // æ·»åŠ æŸ¯ä¼Šä¼¯å¸¦ï¼ˆæµ·ç‹æ˜Ÿè½¨é“ä¹‹å¤–ï¼‰
            createKuiperBelt();

            // æ·»åŠ å¥¥å°”ç‰¹äº‘ï¼ˆå¤ªé˜³ç³»æœ€å¤–å›´ï¼‰
            createOortCloud();

            scene.add(solarSystem);
        }
        
        // åˆ›å»ºå°è¡Œæ˜Ÿå¸¦ï¼ˆå¢å¼ºç‰ˆï¼‰
        function createAsteroidBelt() {
            const innerRadius = 22;
            const outerRadius = 26;
            
            // 1. åˆ›å»ºå¤§å‹å°è¡Œæ˜Ÿï¼ˆä½¿ç”¨ä¸è§„åˆ™ç½‘æ ¼ï¼‰
            const largeAsteroidCount = 50;
            for (let i = 0; i < largeAsteroidCount; i++) {
                const asteroid = createIrregularAsteroid();
                
                // éšæœºä½ç½®åœ¨å°è¡Œæ˜Ÿå¸¦åŒºåŸŸ
                const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 2;
                
                asteroid.position.x = Math.cos(angle) * radius;
                asteroid.position.z = Math.sin(angle) * radius;
                asteroid.position.y = height;
                
                // éšæœºæ—‹è½¬
                asteroid.rotation.x = Math.random() * Math.PI * 2;
                asteroid.rotation.y = Math.random() * Math.PI * 2;
                asteroid.rotation.z = Math.random() * Math.PI * 2;
                
                asteroid.userData = {
                    type: 'asteroid',
                    size: 'large',
                    distance: radius,
                    angle: angle,
                    speed: Math.random() * 0.008 + 0.004,
                    rotationSpeedX: (Math.random() - 0.5) * 0.02,
                    rotationSpeedY: (Math.random() - 0.5) * 0.02,
                    rotationSpeedZ: (Math.random() - 0.5) * 0.02
                };
                
                asteroidBelt.push(asteroid);
                solarSystem.add(asteroid);
            }
            
            // 2. åˆ›å»ºä¸­å‹å°è¡Œæ˜Ÿç¾¤ï¼ˆç®€å•çƒä½“ï¼‰
            const mediumAsteroidCount = 150;
            for (let i = 0; i < mediumAsteroidCount; i++) {
                const size = Math.random() * 0.08 + 0.04;
                const asteroidGeometry = new THREE.SphereGeometry(size, 8, 8);
                
                // éšæœºå˜å½¢
                const positions = asteroidGeometry.attributes.position.array;
                for (let j = 0; j < positions.length; j += 3) {
                    const scale = 0.7 + Math.random() * 0.6;
                    positions[j] *= scale;
                    positions[j + 1] *= scale;
                    positions[j + 2] *= scale;
                }
                asteroidGeometry.computeVertexNormals();
                
                const asteroidMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(0.08 + Math.random() * 0.05, 0.3, 0.3 + Math.random() * 0.2),
                    shininess: 5,
                    flatShading: true
                });
                const asteroid = new THREE.Mesh(asteroidGeometry, asteroidMaterial);
                
                const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 2.5;
                
                asteroid.position.x = Math.cos(angle) * radius;
                asteroid.position.z = Math.sin(angle) * radius;
                asteroid.position.y = height;
                
                asteroid.rotation.x = Math.random() * Math.PI * 2;
                asteroid.rotation.y = Math.random() * Math.PI * 2;
                
                asteroid.userData = {
                    type: 'asteroid',
                    size: 'medium',
                    distance: radius,
                    angle: angle,
                    speed: Math.random() * 0.01 + 0.005,
                    rotationSpeedX: (Math.random() - 0.5) * 0.03,
                    rotationSpeedY: (Math.random() - 0.5) * 0.03
                };
                
                asteroidBelt.push(asteroid);
                solarSystem.add(asteroid);
            }
            
            // 3. åˆ›å»ºå°è¡Œæ˜Ÿå°˜åŸƒäº‘ï¼ˆç²’å­ç³»ç»Ÿï¼‰
            const dustParticleCount = 3000;
            const dustGeometry = new THREE.BufferGeometry();
            const dustPositions = new Float32Array(dustParticleCount * 3);
            const dustColors = new Float32Array(dustParticleCount * 3);
            const dustAngles = new Float32Array(dustParticleCount);
            const dustRadii = new Float32Array(dustParticleCount);
            
            for (let i = 0; i < dustParticleCount; i++) {
                const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 3;
                
                dustAngles[i] = angle;
                dustRadii[i] = radius;
                
                dustPositions[i * 3] = Math.cos(angle) * radius;
                dustPositions[i * 3 + 1] = height;
                dustPositions[i * 3 + 2] = Math.sin(angle) * radius;
                
                // è¤è‰²å°˜åŸƒ
                const brightness = 0.3 + Math.random() * 0.3;
                const c = new THREE.Color().setHSL(0.08, 0.4, brightness);
                dustColors[i * 3] = c.r;
                dustColors[i * 3 + 1] = c.g;
                dustColors[i * 3 + 2] = c.b;
            }
            
            dustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
            dustGeometry.setAttribute('color', new THREE.BufferAttribute(dustColors, 3));
            dustGeometry.userData = {
                angles: dustAngles,
                radii: dustRadii
            };
            
            const dustMaterial = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                transparent: true,
                opacity: 0.4,
                map: sphereParticleTexture,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const dustCloud = new THREE.Points(dustGeometry, dustMaterial);
            dustCloud.userData = { type: 'asteroidDust' };
            solarSystem.add(dustCloud);
            asteroidBelt.push(dustCloud); // æ·»åŠ åˆ°æ•°ç»„ä»¥ä¾¿åŠ¨ç”»
            
            // 4. åˆ›å»ºå¾®å°ç¢ç‰‡ç²’å­ï¼ˆæ›´å¯†é›†ï¼‰
            const debrisParticleCount = 1500;
            const debrisGeometry = new THREE.BufferGeometry();
            const debrisPositions = new Float32Array(debrisParticleCount * 3);
            const debrisColors = new Float32Array(debrisParticleCount * 3);
            const debrisAngles = new Float32Array(debrisParticleCount);
            const debrisRadii = new Float32Array(debrisParticleCount);
            
            for (let i = 0; i < debrisParticleCount; i++) {
                const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 2;
                
                debrisAngles[i] = angle;
                debrisRadii[i] = radius;
                
                debrisPositions[i * 3] = Math.cos(angle) * radius;
                debrisPositions[i * 3 + 1] = height;
                debrisPositions[i * 3 + 2] = Math.sin(angle) * radius;
                
                // ç°è¤è‰²
                const brightness = 0.4 + Math.random() * 0.2;
                const c = new THREE.Color().setHSL(0.1, 0.2, brightness);
                debrisColors[i * 3] = c.r;
                debrisColors[i * 3 + 1] = c.g;
                debrisColors[i * 3 + 2] = c.b;
            }
            
            debrisGeometry.setAttribute('position', new THREE.BufferAttribute(debrisPositions, 3));
            debrisGeometry.setAttribute('color', new THREE.BufferAttribute(debrisColors, 3));
            debrisGeometry.userData = {
                angles: debrisAngles,
                radii: debrisRadii
            };
            
            const debrisMaterial = new THREE.PointsMaterial({
                size: 0.08,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                map: sphereParticleTexture,
                depthWrite: false
            });
            
            const debrisField = new THREE.Points(debrisGeometry, debrisMaterial);
            debrisField.userData = { type: 'asteroidDebris' };
            solarSystem.add(debrisField);
            asteroidBelt.push(debrisField);
        }
        
        // åˆ›å»ºå½—æ˜Ÿç³»ç»Ÿ
        function createComets() {
            const cometCount = 1; // åˆ›å»º1é¢—å½—æ˜Ÿ

            for (let i = 0; i < cometCount; i++) {
                const cometGroup = new THREE.Group();

                // 1. å½—æ ¸ï¼ˆäº®ç™½è‰²æ ¸å¿ƒï¼‰- ç¼©å°åˆ°10%
                const nucleusGeometry = new THREE.SphereGeometry(0.015, 16, 16);
                const nucleusMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    emissive: 0xaaccff,
                    emissiveIntensity: 0.6,
                    shininess: 100
                });
                const nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
                cometGroup.add(nucleus);
                
                // 2. å½—å‘ï¼ˆæ°”ä½“äº‘ï¼Œå›´ç»•å½—æ ¸çš„å‘å…‰äº‘å›¢ï¼‰- ç¼©å°åˆ°10%
                const comaGeometry = new THREE.SphereGeometry(0.08, 32, 32);
                const comaMaterial = new THREE.MeshBasicMaterial({
                    color: 0x88ccff,
                    transparent: true,
                    opacity: 0.25,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const coma = new THREE.Mesh(comaGeometry, comaMaterial);
                cometGroup.add(coma);
                
                // 3. å†…å±‚å½—å‘ï¼ˆæ›´äº®ï¼‰- ç¼©å°åˆ°10%
                const innerComaGeometry = new THREE.SphereGeometry(0.04, 32, 32);
                const innerComaMaterial = new THREE.MeshBasicMaterial({
                    color: 0xccddff,
                    transparent: true,
                    opacity: 0.4,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const innerComa = new THREE.Mesh(innerComaGeometry, innerComaMaterial);
                cometGroup.add(innerComa);
                
                // 4. ç¦»å­å°¾ï¼ˆè“è‰²ï¼Œç¬”ç›´æŒ‡å‘å¤ªé˜³ç›¸åæ–¹å‘ï¼‰
                // é¦–å…ˆè®¡ç®—å½—æ˜Ÿè½¨é“å‚æ•°å’Œåˆå§‹ä½ç½®ï¼Œä»¥ä¾¿ç¡®å®šå½—å°¾æ–¹å‘
                const semiMajorAxis = 70 + Math.random() * 20; // åŠé•¿è½´ 70-90
                const eccentricity = 0.6 + Math.random() * 0.3; // ç¦»å¿ƒç‡ 0.6-0.9ï¼ˆé«˜ç¦»å¿ƒç‡ï¼‰
                const inclination = (Math.random() - 0.5) * Math.PI * 0.3; // å€¾è§’ Â±27åº¦
                const initialAngle = Math.random() * Math.PI * 2; // åˆå§‹è§’åº¦
                
                // è®¡ç®—åˆå§‹è½¨é“ä½ç½®ï¼ˆç”¨äºç¡®å®šå½—å°¾æ–¹å‘ï¼‰
                const r = semiMajorAxis * (1 - eccentricity * eccentricity) / (1 + eccentricity * Math.cos(initialAngle));
                const orbitX = Math.cos(initialAngle) * r;
                const orbitZ = Math.sin(initialAngle) * r;
                const orbitY = Math.sin(inclination) * orbitZ;
                
                // å½—å°¾æ–¹å‘ï¼šæŒ‡å‘è¿œç¦»å¤ªé˜³çš„æ–¹å‘ï¼ˆå¤ªé˜³åœ¨åŸç‚¹ï¼‰
                const tailDirection = new THREE.Vector3(orbitX, orbitY, orbitZ).normalize().multiplyScalar(-1); // æŒ‡å‘è¿œç¦»å¤ªé˜³çš„æ–¹å‘ï¼ˆä»å½—æ ¸å‘å¤–ï¼‰
                
                const ionTailParticleCount = 500;
                const ionTailGeometry = new THREE.BufferGeometry();
                const ionTailPositions = new Float32Array(ionTailParticleCount * 3);
                const ionTailColors = new Float32Array(ionTailParticleCount * 3);
                const ionTailOpacities = new Float32Array(ionTailParticleCount);
                
                for (let j = 0; j < ionTailParticleCount; j++) {
                    // å°¾å·´ä»å½—æ ¸å‘åå»¶ä¼¸ï¼ˆæ²¿å½—å°¾æ–¹å‘ï¼‰- ç¼©å°åˆ°10%
                    const distance = Math.pow(Math.random(), 0.5) * 2.5; // 2.5å•ä½é•¿åº¦
                    const spread = Math.random() * 0.3 * distance; // æ‰©æ•£åº¦
                    
                    // è®¡ç®—æ²¿å½—å°¾æ–¹å‘çš„åŸºæœ¬ä½ç½®
                    const tailPos = tailDirection.clone().multiplyScalar(distance);
                    
                    // æ·»åŠ å‚ç›´æ–¹å‘çš„éšæœºæ‰©æ•£
                    const perpendicular = new THREE.Vector3(
                        Math.random() - 0.5,
                        Math.random() - 0.5,
                        Math.random() - 0.5
                    ).cross(tailDirection).normalize().multiplyScalar(spread);
                    
                    ionTailPositions[j * 3] = tailPos.x + perpendicular.x;
                    ionTailPositions[j * 3 + 1] = tailPos.y + perpendicular.y;
                    ionTailPositions[j * 3 + 2] = tailPos.z + perpendicular.z;
                    
                    // è“ç™½è‰²ç¦»å­å°¾
                    const c = new THREE.Color().setHSL(0.55 + Math.random() * 0.1, 0.8, 0.6 + Math.random() * 0.2);
                    ionTailColors[j * 3] = c.r;
                    ionTailColors[j * 3 + 1] = c.g;
                    ionTailColors[j * 3 + 2] = c.b;
                    
                    // è·ç¦»è¶Šè¿œè¶Šé€æ˜
                    ionTailOpacities[j] = 1 - (distance / 2.5) * 0.8;
                }
                
                ionTailGeometry.setAttribute('position', new THREE.BufferAttribute(ionTailPositions, 3));
                ionTailGeometry.setAttribute('color', new THREE.BufferAttribute(ionTailColors, 3));
                ionTailGeometry.setAttribute('opacity', new THREE.BufferAttribute(ionTailOpacities, 1));
                
                const ionTailMaterial = new THREE.PointsMaterial({
                    size: 0.04, // ç¼©å°åˆ°10%
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.7,
                    map: sphereParticleTexture,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const ionTail = new THREE.Points(ionTailGeometry, ionTailMaterial);
                ionTail.userData.type = 'ionTail';
                cometGroup.add(ionTail);
                
                // 5. å°˜åŸƒå°¾ï¼ˆé»„ç™½è‰²ï¼Œå¼¯æ›²æ‰©æ•£ï¼‰
                const dustTailParticleCount = 600;
                const dustTailGeometry = new THREE.BufferGeometry();
                const dustTailPositions = new Float32Array(dustTailParticleCount * 3);
                const dustTailColors = new Float32Array(dustTailParticleCount * 3);
                const dustTailCurves = new Float32Array(dustTailParticleCount); // è®°å½•å¼¯æ›²å‚æ•°
                
                for (let j = 0; j < dustTailParticleCount; j++) {
                    const distance = Math.pow(Math.random(), 0.4) * 3; // 3å•ä½é•¿åº¦ï¼ˆç¼©å°åˆ°10%ï¼‰
                    const spread = Math.random() * 0.5 * distance; // æ›´å¤§çš„æ‰©æ•£
                    const curve = Math.random() * 0.3; // å¼¯æ›²åº¦
                    
                    dustTailCurves[j] = curve;
                    
                    // è®¡ç®—æ²¿å½—å°¾æ–¹å‘çš„åŸºæœ¬ä½ç½®
                    const tailPos = tailDirection.clone().multiplyScalar(distance);
                    
                    // æ·»åŠ å‚ç›´æ–¹å‘çš„éšæœºæ‰©æ•£å’Œå¼¯æ›²æ•ˆæœ
                    const perpendicular = new THREE.Vector3(
                        Math.random() - 0.5,
                        Math.random() - 0.5,
                        Math.random() - 0.5
                    ).cross(tailDirection).normalize().multiplyScalar(spread);
                    
                    // å¼¯æ›²æ•ˆæœï¼šå‚ç›´äºå½—å°¾æ–¹å‘å’Œå‚ç›´æ–¹å‘
                    const bendDirection = new THREE.Vector3(0, 1, 0).cross(tailDirection).normalize();
                    const bendAmount = distance * 0.1 * curve;
                    
                    dustTailPositions[j * 3] = tailPos.x + perpendicular.x + bendDirection.x * bendAmount;
                    dustTailPositions[j * 3 + 1] = tailPos.y + perpendicular.y + bendDirection.y * bendAmount;
                    dustTailPositions[j * 3 + 2] = tailPos.z + perpendicular.z + bendDirection.z * bendAmount;
                    
                    // é»„ç™½è‰²å°˜åŸƒå°¾
                    const c = new THREE.Color().setHSL(0.1 + Math.random() * 0.05, 0.5, 0.7 + Math.random() * 0.2);
                    dustTailColors[j * 3] = c.r;
                    dustTailColors[j * 3 + 1] = c.g;
                    dustTailColors[j * 3 + 2] = c.b;
                }
                
                dustTailGeometry.setAttribute('position', new THREE.BufferAttribute(dustTailPositions, 3));
                dustTailGeometry.setAttribute('color', new THREE.BufferAttribute(dustTailColors, 3));
                dustTailGeometry.userData.curves = dustTailCurves;
                
                const dustTailMaterial = new THREE.PointsMaterial({
                    size: 0.05, // ç¼©å°åˆ°10%
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    map: sphereParticleTexture,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const dustTail = new THREE.Points(dustTailGeometry, dustTailMaterial);
                dustTail.userData.type = 'dustTail';
                cometGroup.add(dustTail);
                
                // å­˜å‚¨è½¨é“å‚æ•°åˆ°å½—æ˜Ÿç»„
                cometGroup.userData = {
                    type: 'comet',
                    semiMajorAxis: semiMajorAxis,
                    eccentricity: eccentricity,
                    inclination: inclination,
                    angle: initialAngle,
                    speed: 0.001 + Math.random() * 0.002, // å…¬è½¬é€Ÿåº¦
                    rotationSpeed: 0.02 + Math.random() * 0.03, // å½—æ ¸è‡ªè½¬é€Ÿåº¦
                    ionTail: ionTail,
                    dustTail: dustTail
                };
                
                comets.push(cometGroup);
                solarSystem.add(cometGroup);

                // åˆ›å»ºå½—æ˜Ÿçš„é’è‰²è½¨è¿¹çº¿
                createCometTrajectory(cometGroup, semiMajorAxis, eccentricity, inclination);
            }
        }

        // åˆ›å»ºå½—æ˜Ÿè½¨è¿¹çº¿
        function createCometTrajectory(cometGroup, semiMajorAxis, eccentricity, inclination) {
            const segments = 128; // è½¨è¿¹çº¿åˆ†æ®µæ•°
            const points = [];

            // è®¡ç®—æ¤­åœ†è½¨é“ä¸Šçš„ç‚¹
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2; // 0åˆ°2Ï€
                const r = semiMajorAxis * (1 - eccentricity * eccentricity) / (1 + eccentricity * Math.cos(angle));
                
                // è®¡ç®—è½¨é“å¹³é¢ä¸Šçš„ç‚¹
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                const y = Math.sin(inclination) * z; // è€ƒè™‘è½¨é“å€¾è§’
                
                points.push(new THREE.Vector3(x, y, z));
            }

            // åˆ›å»ºè½¨è¿¹çº¿å‡ ä½•ä½“
            const trajectoryGeometry = new THREE.BufferGeometry().setFromPoints(points);
            
            // é’è‰²è½¨è¿¹çº¿æè´¨
            const trajectoryMaterial = new THREE.LineBasicMaterial({
                color: 0x004444, // é’è‰²
                transparent: true,
                opacity: 0.6,
                linewidth: 1
            });

            // åˆ›å»ºè½¨è¿¹çº¿
            const trajectoryLine = new THREE.Line(trajectoryGeometry, trajectoryMaterial);
            trajectoryLine.userData = { type: 'cometTrajectory' };
            
            // æ·»åŠ åˆ°å¤ªé˜³ç³»
            solarSystem.add(trajectoryLine);
        }
        
        // åˆ›å»ºæŸ¯ä¼Šä¼¯å¸¦ï¼ˆæµ·ç‹æ˜Ÿè½¨é“ä¹‹å¤–çš„å†°ä½“å¸¦ï¼‰
        function createKuiperBelt() {
            const innerRadius = 60; // çº¦60å¤©æ–‡å•ä½ï¼ˆç¼©æ”¾åï¼‰
            const outerRadius = 100; // çº¦100å¤©æ–‡å•ä½
            
            // 1. åˆ›å»ºå¤§å‹æŸ¯ä¼Šä¼¯å¸¦å¤©ä½“ï¼ˆå†°è´¨çŸ®è¡Œæ˜Ÿï¼‰
            const largeKBOCount = 20;
            for (let i = 0; i < largeKBOCount; i++) {
                // ä½¿ç”¨å½—æ ¸ç±»ä¼¼çš„å¤–è§‚ï¼Œä½†æ›´å¤§
                const kboGeometry = new THREE.SphereGeometry(0.04 + Math.random() * 0.03, 16, 16);
                const kboMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(0.6 + Math.random() * 0.1, 0.5, 0.4 + Math.random() * 0.2), // è“ç°è‰²
                    shininess: 30,
                    specular: new THREE.Color(0x333333)
                });
                const kbo = new THREE.Mesh(kboGeometry, kboMaterial);
                
                // éšæœºä½ç½®åœ¨æŸ¯ä¼Šä¼¯å¸¦åŒºåŸŸï¼ˆç›˜çŠ¶åˆ†å¸ƒï¼Œä¸»è¦åœ¨é»„é“é¢é™„è¿‘ï¼‰
                const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 5; // è½»å¾®å‚ç›´åˆ†æ•£
                
                kbo.position.x = Math.cos(angle) * radius;
                kbo.position.z = Math.sin(angle) * radius;
                kbo.position.y = height;
                
                // éšæœºæ—‹è½¬
                kbo.rotation.x = Math.random() * Math.PI * 2;
                kbo.rotation.y = Math.random() * Math.PI * 2;
                
                kbo.userData = {
                    type: 'kuiperBeltObject',
                    size: 'large',
                    distance: radius,
                    angle: angle,
                    speed: (0.002 + Math.random() * 0.002), // æ¯”å°è¡Œæ˜Ÿå¸¦æ…¢å¾—å¤š
                    rotationSpeedX: (Math.random() - 0.5) * 0.01,
                    rotationSpeedY: (Math.random() - 0.5) * 0.01
                };
                
                kuiperBelt.push(kbo);
                solarSystem.add(kbo);
            }
            
            // 2. åˆ›å»ºæŸ¯ä¼Šä¼¯å¸¦å†°ç²’äº‘ï¼ˆç²’å­ç³»ç»Ÿï¼‰
            const iceParticleCount = 2000;
            const iceGeometry = new THREE.BufferGeometry();
            const icePositions = new Float32Array(iceParticleCount * 3);
            const iceColors = new Float32Array(iceParticleCount * 3);
            const iceAngles = new Float32Array(iceParticleCount);
            const iceRadii = new Float32Array(iceParticleCount);
            
            for (let i = 0; i < iceParticleCount; i++) {
                const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 8; // æŸ¯ä¼Šä¼¯å¸¦æœ‰ä¸€å®šåšåº¦
                
                iceAngles[i] = angle;
                iceRadii[i] = radius;
                
                icePositions[i * 3] = Math.cos(angle) * radius;
                icePositions[i * 3 + 1] = height;
                icePositions[i * 3 + 2] = Math.sin(angle) * radius;
                
                // å†°ç²’é¢œè‰²ï¼šè“ç™½è‰²
                const brightness = 0.2 + Math.random() * 0.3;
                const h = 0.6 + Math.random() * 0.1; // è“è‰²è°ƒ
                const s = 0.3 + Math.random() * 0.3;
                const c = new THREE.Color().setHSL(h, s, brightness);
                iceColors[i * 3] = c.r;
                iceColors[i * 3 + 1] = c.g;
                iceColors[i * 3 + 2] = c.b;
            }
            
            iceGeometry.setAttribute('position', new THREE.BufferAttribute(icePositions, 3));
            iceGeometry.setAttribute('color', new THREE.BufferAttribute(iceColors, 3));
            iceGeometry.userData = {
                angles: iceAngles,
                radii: iceRadii
            };
            
            const iceMaterial = new THREE.PointsMaterial({
                size: 0.12,
                vertexColors: true,
                transparent: true,
                opacity: 0.5,
                map: sphereParticleTexture,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const iceCloud = new THREE.Points(iceGeometry, iceMaterial);
            iceCloud.userData = { type: 'kuiperBeltIce' };
            kuiperBelt.push(iceCloud);
            solarSystem.add(iceCloud);
        }
        
        // åˆ›å»ºå¥¥å°”ç‰¹äº‘ï¼ˆå¤ªé˜³ç³»æœ€å¤–å›´çš„çƒå½¢äº‘ï¼‰
        function createOortCloud() {
            const innerRadius = 150; // çº¦150å¤©æ–‡å•ä½ï¼ˆç¼©æ”¾åï¼‰
            const outerRadius = 300; // çº¦300å¤©æ–‡å•ä½
            
            // åˆ›å»ºå¥¥å°”ç‰¹äº‘ç²’å­ï¼ˆçƒå½¢åˆ†å¸ƒï¼‰
            const oortParticleCount = 3000;
            const oortGeometry = new THREE.BufferGeometry();
            const oortPositions = new Float32Array(oortParticleCount * 3);
            const oortColors = new Float32Array(oortParticleCount * 3);
            const oortAngles = new Float32Array(oortParticleCount * 2); // ç»åº¦å’Œçº¬åº¦
            const oortDistances = new Float32Array(oortParticleCount);
            
            for (let i = 0; i < oortParticleCount; i++) {
                // çƒé¢éšæœºåˆ†å¸ƒ
                const distance = innerRadius + Math.random() * (outerRadius - innerRadius);
                const theta = Math.random() * Math.PI * 2; // ç»åº¦
                const phi = Math.acos(2 * Math.random() - 1); // çº¬åº¦
                
                oortAngles[i * 2] = theta;
                oortAngles[i * 2 + 1] = phi;
                oortDistances[i] = distance;
                
                oortPositions[i * 3] = distance * Math.sin(phi) * Math.cos(theta);
                oortPositions[i * 3 + 1] = distance * Math.cos(phi); // Yè½´
                oortPositions[i * 3 + 2] = distance * Math.sin(phi) * Math.sin(theta);
                
                // å¥¥å°”ç‰¹äº‘å†°æ ¸é¢œè‰²ï¼šéå¸¸æš—çš„è“ç°è‰²
                const brightness = 0.1 + Math.random() * 0.15;
                const h = 0.55 + Math.random() * 0.1; // å†·è‰²è°ƒ
                const s = 0.2 + Math.random() * 0.2;
                const c = new THREE.Color().setHSL(h, s, brightness);
                oortColors[i * 3] = c.r;
                oortColors[i * 3 + 1] = c.g;
                oortColors[i * 3 + 2] = c.b;
            }
            
            oortGeometry.setAttribute('position', new THREE.BufferAttribute(oortPositions, 3));
            oortGeometry.setAttribute('color', new THREE.BufferAttribute(oortColors, 3));
            oortGeometry.userData = {
                angles: oortAngles,
                distances: oortDistances
            };
            
            const oortMaterial = new THREE.PointsMaterial({
                size: 0.08,
                vertexColors: true,
                transparent: true,
                opacity: 0.4,
                map: sphereParticleTexture,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const oortCloudObj = new THREE.Points(oortGeometry, oortMaterial);
            oortCloudObj.userData = { type: 'oortCloud' };
            oortCloudObj.visible = false; // é»˜è®¤éšè—ï¼Œé¿å…é®æŒ¡å†…å¤ªé˜³ç³»
            oortCloudObj.userData.visibleThreshold = 0.3; // ç¼©æ”¾é˜ˆå€¼
            oortCloudObj.userData.baseOpacity = 0.4;
            oortCloudObj.userData.baseSize = 0.08;
            oortCloudObj.userData.baseDistance = (innerRadius + outerRadius) / 2;
            
            oortCloud.push(oortCloudObj);
            solarSystem.add(oortCloudObj);
        }
        
        // åˆ›å»ºä¸è§„åˆ™å°è¡Œæ˜Ÿ
        function createIrregularAsteroid() {
            const baseSize = 0.12 + Math.random() * 0.08;
            const geometry = new THREE.DodecahedronGeometry(baseSize, 0);
            
            // éšæœºå˜å½¢ä½¿å…¶ä¸è§„åˆ™
            const positions = geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const scale = 0.6 + Math.random() * 0.8;
                positions[i] *= scale;
                positions[i + 1] *= scale * (0.7 + Math.random() * 0.6);
                positions[i + 2] *= scale;
            }
            geometry.computeVertexNormals();
            
            // åˆ›å»ºå°è¡Œæ˜Ÿçº¹ç†
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // åŸºç¡€ç°è¤è‰²
            const baseColor = `rgb(${100 + Math.random() * 40}, ${80 + Math.random() * 30}, ${60 + Math.random() * 20})`;
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, 128, 128);
            
            // æ·»åŠ é™¨çŸ³å‘å’Œçº¹ç†
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * 128;
                const y = Math.random() * 128;
                const radius = Math.random() * 8 + 3;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, `rgba(40, 30, 20, 0.6)`);
                gradient.addColorStop(1, `rgba(80, 60, 40, 0.2)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            
            const material = new THREE.MeshPhongMaterial({
                map: texture,
                color: new THREE.Color().setHSL(0.08 + Math.random() * 0.05, 0.4, 0.35),
                shininess: 3,
                flatShading: true
            });
            
            return new THREE.Mesh(geometry, material);
        }
        
        // ===== åœ°çƒç³»ç»Ÿåˆ›å»ºï¼ˆæ•´åˆåŸå§‹åœ°çƒæ¨¡å‹ï¼‰ =====
        function createEarthSystem() {
            earthSystem = new THREE.Group();
            earthSystem.visible = false;

            // åˆ›å»ºæ˜Ÿç©ºèƒŒæ™¯ï¼ˆä»…åœ¨åœ°çƒå±‚çº§æ˜¾ç¤ºï¼‰
            createStarfieldBackground();

            // åˆ›å»ºåœ°çƒç»„
            earthGroup = new THREE.Group();
            
            // çº¹ç†URLï¼ˆä½¿ç”¨åœ¨çº¿çº¹ç†ï¼‰
            const textureUrls = {
                earth: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_atmos_2048.jpg',
                earthSpecular: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg',
                earthNormal: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg',
                clouds: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_clouds_1024.png'
            };
            
            // åŠ è½½çº¹ç†
            const textureLoader = new THREE.TextureLoader();
            
            const earthTexture = textureLoader.load(textureUrls.earth);
            const specularTexture = textureLoader.load(textureUrls.earthSpecular);
            const normalTexture = textureLoader.load(textureUrls.earthNormal);
            const cloudTexture = textureLoader.load(textureUrls.clouds);
            
            // åˆ›å»ºåœ°çƒæè´¨ï¼ˆæé«˜äº®åº¦ï¼‰
            const earthMaterial = new THREE.MeshPhongMaterial({
                map: earthTexture,
                specularMap: specularTexture,
                specular: new THREE.Color(0x666666), // æé«˜äº®åº¦
                shininess: 10, // æé«˜å…‰æ³½
                normalMap: normalTexture,
                normalScale: new THREE.Vector2(0.85, 0.85)
            });
            
            // åˆ›å»ºåœ°çƒå‡ ä½•ä½“
            const earthGeometry = new THREE.SphereGeometry(5, 64, 64);
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            earthGroup.add(earth);
            
            // åˆ›å»ºäº‘å±‚
            const cloudMaterial = new THREE.MeshPhongMaterial({
                map: cloudTexture,
                transparent: true,
                opacity: 0.4,
                depthWrite: false
            });
            
            const cloudGeometry = new THREE.SphereGeometry(5.1, 64, 64);
            clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
            earthGroup.add(clouds);
            
            earthSystem.add(earthGroup);
            
            // åˆ›å»ºæ‰€æœ‰åœ°çƒç‰¹å¾ï¼ˆåŸå¸‚ã€å±±å³°ã€æ¹–æ³Šç­‰ï¼‰
            createAllEarthFeatures();
            
            scene.add(earthSystem);
            
            // åˆå§‹åŒ–è‡ªå®šä¹‰æ ‡è®°ç»„
            customMarkersGroup = new THREE.Group();
            earthGroup.add(customMarkersGroup);
        }

        // åˆ›å»ºæ˜Ÿç©ºèƒŒæ™¯ï¼ˆä»…ç”¨äºåœ°çƒå±‚çº§ï¼Œä½¿ç”¨çƒå‹ç²’å­ï¼‰
        function createStarfieldBackground() {
            const starCount = 20000; // ä»10000å¢åŠ åˆ°20000
            const starsGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 2000;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 2000;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 2000;

                // æ·»åŠ é¢œè‰²å˜åŒ–ï¼Œæ¨¡æ‹Ÿä¸åŒç±»å‹çš„æ’æ˜Ÿ
                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.2 + 0.5, 0.3, Math.random() * 0.4 + 0.6);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const starsMaterial = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.85,
                map: sphereParticleTexture, // ä½¿ç”¨çƒå‹çº¹ç†
                blending: THREE.AdditiveBlending,
                alphaTest: 0.01,
                depthWrite: false
            });

            earthStarfield = new THREE.Points(starsGeometry, starsMaterial);
            earthStarfield.visible = false; // é»˜è®¤éšè—ï¼Œåªåœ¨åœ°çƒå±‚çº§æ˜¾ç¤º
            scene.add(earthStarfield);

            // åˆ›å»ºæœˆçƒï¼ˆå›´ç»•åœ°çƒï¼‰- ä½¿ç”¨é«˜è´¨é‡çº¹ç†
            const moonGeometry = new THREE.SphereGeometry(1, 64, 64);
            const moonTexture = createMoonTexture();
            const moonMaterial = new THREE.MeshPhongMaterial({
                map: moonTexture,
                shininess: 5,
                specular: new THREE.Color(0x222222)
            });
            const moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.set(80, 0, 0); // è·ç¦»åœ°çƒ80ï¼ˆåŸæ¥çš„8å€ï¼‰
            moon.userData = {
                name: 'æœˆçƒ',
                englishName: 'Moon',
                orbitRadius: 80,
                orbitSpeed: 0.001, // è½¬é€Ÿé™ä½åˆ°åŸæ¥çš„10%ï¼ˆ0.01 * 0.1ï¼‰
                angle: 0
            };
            moon.visible = false; // é»˜è®¤éšè—ï¼Œåªåœ¨åœ°çƒå±‚çº§æ˜¾ç¤º
            scene.add(moon);

            // å°†æœˆçƒæ·»åŠ åˆ°åŠ¨ç”»æ›´æ–°ä¸­
            window.earthMoon = moon;
        }

        // åˆ›å»ºå¤ªé˜³ç³»å±‚çº§æ˜Ÿç©ºèƒŒæ™¯
        function createSolarStarfieldBackground() {
            const starCount = 15000; // ä»8000å¢åŠ åˆ°15000
            const starsGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 1500;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 1500;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 1500;

                // æ·»åŠ é¢œè‰²å˜åŒ–
                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.2 + 0.5, 0.3, Math.random() * 0.4 + 0.6);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const starsMaterial = new THREE.PointsMaterial({
                size: 0.4,
                vertexColors: true,
                transparent: true,
                opacity: 0.85,
                map: sphereParticleTexture, // ä½¿ç”¨çƒå‹çº¹ç†
                blending: THREE.AdditiveBlending,
                alphaTest: 0.01,
                depthWrite: false
            });

            solarStarfield = new THREE.Points(starsGeometry, starsMaterial);
            solarStarfield.visible = false; // é»˜è®¤éšè—ï¼Œåªåœ¨å¤ªé˜³ç³»å±‚çº§æ˜¾ç¤º
            scene.add(solarStarfield);
        }

        // åˆ›å»ºæ‰€æœ‰åœ°çƒç‰¹å¾
        function createAllEarthFeatures() {
            // åŸå¸‚
            createCityMarkers();
            
            // å±±å³°å’Œæç‚¹
            createPeakMarkers();
            
            // æ¹–æ³Š
            createLakeMarkers();
            
            // æ²³æµ
            createRiverMarkers();
            
            // èµ¤é“å’Œå›å½’çº¿
            createEquatorAndTropics();
        }
        
        // å›å½’çº¿è½¬ä¸‰ç»´åæ ‡
        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);
            
            return new THREE.Vector3(x, y, z);
        }
        
        // åˆ›å»ºæ–‡å­—æ ‡ç­¾Sprite
        function createTextSprite(text, color = '#ffffff') {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            // æ¸…é™¤ç”»å¸ƒï¼Œä¿æŒé€æ˜èƒŒæ™¯
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // æ·»åŠ æ–‡å­—é˜´å½±æ•ˆæœï¼Œæé«˜å¯è¯»æ€§
            context.shadowColor = 'rgba(0, 0, 0, 0.8)';
            context.shadowBlur = 4;
            context.shadowOffsetX = 2;
            context.shadowOffsetY = 2;
            
            context.font = 'Bold 24px Arial';
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                depthTest: true,  // å¯ç”¨æ·±åº¦æµ‹è¯•ï¼Œè¢«é®æŒ¡æ—¶ä¸æ˜¾ç¤º
                depthWrite: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(0.8, 0.2, 1);
            sprite.renderOrder = 1;  // æ”¹ä¸º1ï¼Œä¸æ ‡è®°ç›¸åŒçš„æ¸²æŸ“é¡ºåº
            
            return sprite;
        }
        
        // åˆ›å»ºåŸå¸‚æ ‡è®°ï¼ˆæ•´åˆåŸå§‹ä»£ç ï¼‰
        function createCityMarkers() {
            citiesGroup = new THREE.Group();
            namesGroup = new THREE.Group();
            
            const majorCities = {
                beijing: { name: "åŒ—äº¬", englishName: "Beijing", country: "ä¸­å›½", englishCountry: "China", continent: "äºšæ´²", englishContinent: "Asia", coordinates: [116.4074, 39.9042], population: 21540000 },
                shanghai: { name: "ä¸Šæµ·", englishName: "Shanghai", country: "ä¸­å›½", englishCountry: "China", continent: "äºšæ´²", englishContinent: "Asia", coordinates: [121.4737, 31.2304], population: 24281400 },
                xian: { name: "è¥¿å®‰", englishName: "Xi'an", country: "ä¸­å›½", englishCountry: "China", continent: "äºšæ´²", englishContinent: "Asia", coordinates: [108.9398, 34.3416], population: 12952000 },
                chengdu: { name: "æˆéƒ½", englishName: "Chengdu", country: "ä¸­å›½", englishCountry: "China", continent: "äºšæ´²", englishContinent: "Asia", coordinates: [104.0665, 30.5728], population: 21070000 },
                hongkong: { name: "é¦™æ¸¯", englishName: "Hong Kong", country: "ä¸­å›½", englishCountry: "China", continent: "äºšæ´²", englishContinent: "Asia", coordinates: [114.1694, 22.3193], population: 7481000 },
                macau: { name: "æ¾³é—¨", englishName: "Macau", country: "ä¸­å›½", englishCountry: "China", continent: "äºšæ´²", englishContinent: "Asia", coordinates: [113.5491, 22.1987], population: 683000 },
                taipei: { name: "å°åŒ—", englishName: "Taipei", country: "ä¸­å›½", englishCountry: "China", continent: "äºšæ´²", englishContinent: "Asia", coordinates: [121.5654, 25.0330], population: 2657000 },
                tokyo: { name: "ä¸œäº¬", englishName: "Tokyo", country: "æ—¥æœ¬", englishCountry: "Japan", continent: "äºšæ´²", englishContinent: "Asia", coordinates: [139.6917, 35.6895], population: 37400068 },
                newyork: { name: "çº½çº¦", englishName: "New York", country: "ç¾å›½", englishCountry: "USA", continent: "åŒ—ç¾æ´²", englishContinent: "North America", coordinates: [-74.0060, 40.7128], population: 8336817 },
                london: { name: "ä¼¦æ•¦", englishName: "London", country: "è‹±å›½", englishCountry: "UK", continent: "æ¬§æ´²", englishContinent: "Europe", coordinates: [-0.1276, 51.5074], population: 9002488 },
                paris: { name: "å·´é»", englishName: "Paris", country: "æ³•å›½", englishCountry: "France", continent: "æ¬§æ´²", englishContinent: "Europe", coordinates: [2.3522, 48.8566], population: 2161000 },
                moscow: { name: "è«æ–¯ç§‘", englishName: "Moscow", country: "ä¿„ç½—æ–¯", englishCountry: "Russia", continent: "æ¬§æ´²", englishContinent: "Europe", coordinates: [37.6173, 55.7558], population: 12506400 },
                sydney: { name: "æ‚‰å°¼", englishName: "Sydney", country: "æ¾³å¤§åˆ©äºš", englishCountry: "Australia", continent: "å¤§æ´‹æ´²", englishContinent: "Oceania", coordinates: [151.2093, -33.8688], population: 5312000 },
                cairo: { name: "å¼€ç½—", englishName: "Cairo", country: "åŸƒåŠ", englishCountry: "Egypt", continent: "éæ´²", englishContinent: "Africa", coordinates: [31.2357, 30.0444], population: 20076000 },
                mumbai: { name: "å­Ÿä¹°", englishName: "Mumbai", country: "å°åº¦", englishCountry: "India", continent: "äºšæ´²", englishContinent: "Asia", coordinates: [72.8777, 19.0760], population: 20411000 },
                saopaulo: { name: "åœ£ä¿ç½—", englishName: "Sao Paulo", country: "å·´è¥¿", englishCountry: "Brazil", continent: "å—ç¾æ´²", englishContinent: "South America", coordinates: [-46.6333, -23.5505], population: 12325200 },
                losangeles: { name: "æ´›æ‰çŸ¶", englishName: "Los Angeles", country: "ç¾å›½", englishCountry: "USA", continent: "åŒ—ç¾æ´²", englishContinent: "North America", coordinates: [-118.2437, 34.0522], population: 3990000 },
                chicago: { name: "èŠåŠ å“¥", englishName: "Chicago", country: "ç¾å›½", englishCountry: "USA", continent: "åŒ—ç¾æ´²", englishContinent: "North America", coordinates: [-87.6298, 41.8781], population: 2697000 },
                toronto: { name: "å¤šä¼¦å¤š", englishName: "Toronto", country: "åŠ æ‹¿å¤§", englishCountry: "Canada", continent: "åŒ—ç¾æ´²", englishContinent: "North America", coordinates: [-79.3832, 43.6532], population: 2930000 },
                mexicocity: { name: "å¢¨è¥¿å“¥åŸ", englishName: "Mexico City", country: "å¢¨è¥¿å“¥", englishCountry: "Mexico", continent: "åŒ—ç¾æ´²", englishContinent: "North America", coordinates: [-99.1332, 19.4326], population: 21581000 },
                buenosaires: { name: "å¸ƒå®œè¯ºæ–¯è‰¾åˆ©æ–¯", englishName: "Buenos Aires", country: "é˜¿æ ¹å»·", englishCountry: "Argentina", continent: "å—ç¾æ´²", englishContinent: "South America", coordinates: [-58.3816, -34.6037], population: 15153000 },
                lagos: { name: "æ‹‰å„æ–¯", englishName: "Lagos", country: "å°¼æ—¥åˆ©äºš", englishCountry: "Nigeria", continent: "éæ´²", englishContinent: "Africa", coordinates: [3.3792, 6.5244], population: 15388000 },
                kinshasa: { name: "é‡‘æ²™è¨", englishName: "Kinshasa", country: "åˆšæœæ°‘ä¸»å…±å’Œå›½", englishCountry: "DRC", continent: "éæ´²", englishContinent: "Africa", coordinates: [15.2663, -4.4419], population: 16154000 },
                jakarta: { name: "é›…åŠ è¾¾", englishName: "Jakarta", country: "å°åº¦å°¼è¥¿äºš", englishCountry: "Indonesia", continent: "äºšæ´²", englishContinent: "Asia", coordinates: [106.8456, -6.2088], population: 10770400 },
                seoul: { name: "é¦–å°”", englishName: "Seoul", country: "éŸ©å›½", englishCountry: "South Korea", continent: "äºšæ´²", englishContinent: "Asia", coordinates: [126.9780, 37.5665], population: 9776000 },
                bangkok: { name: "æ›¼è°·", englishName: "Bangkok", country: "æ³°å›½", englishCountry: "Thailand", continent: "äºšæ´²", englishContinent: "Asia", coordinates: [100.5018, 13.7563], population: 10539000 },
                singapore: { name: "æ–°åŠ å¡", englishName: "Singapore", country: "æ–°åŠ å¡", englishCountry: "Singapore", continent: "äºšæ´²", englishContinent: "Asia", coordinates: [103.8198, 1.3521], population: 5850000 },
                dubai: { name: "è¿ªæ‹œ", englishName: "Dubai", country: "é˜¿è”é…‹", englishCountry: "UAE", continent: "äºšæ´²", englishContinent: "Asia", coordinates: [55.2708, 25.2048], population: 3331000 },
                istanbul: { name: "ä¼Šæ–¯å¦å¸ƒå°”", englishName: "Istanbul", country: "åœŸè€³å…¶", englishCountry: "Turkey", continent: "æ¬§æ´²", englishContinent: "Europe", coordinates: [28.9784, 41.0082], population: 15462400 },
                berlin: { name: "æŸæ—", englishName: "Berlin", country: "å¾·å›½", englishCountry: "Germany", continent: "æ¬§æ´²", englishContinent: "Europe", coordinates: [13.4050, 52.5200], population: 3769495 },
                rome: { name: "ç½—é©¬", englishName: "Rome", country: "æ„å¤§åˆ©", englishCountry: "Italy", continent: "æ¬§æ´²", englishContinent: "Europe", coordinates: [12.4964, 41.9028], population: 2873000 },
                madrid: { name: "é©¬å¾·é‡Œ", englishName: "Madrid", country: "è¥¿ç­ç‰™", englishCountry: "Spain", continent: "æ¬§æ´²", englishContinent: "Europe", coordinates: [-3.7038, 40.4168], population: 6671000 }
            };
            
            Object.keys(majorCities).forEach(cityKey => {
                const city = majorCities[cityKey];
                const position = latLonToVector3(city.coordinates[1], city.coordinates[0], 5.08);
                
                // åŸå¸‚çƒä½“ï¼ˆç™½è‰²ï¼‰
                const sphereGeometry = new THREE.SphereGeometry(0.06, 16, 16);
                const sphereMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.9,
                    depthTest: true,   // å¯ç”¨æ·±åº¦æµ‹è¯•
                    depthWrite: true   // å¯ç”¨æ·±åº¦å†™å…¥
                });
                
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.copy(position);
                sphere.userData = {
                    cityKey: cityKey,
                    cityData: city,
                    type: 'city'
                };
                sphere.renderOrder = 1;
                citiesGroup.add(sphere);
                
                // ç¢°æ’ä½“
                const hitSphereGeometry = new THREE.SphereGeometry(0.072, 16, 16);
                const hitSphereMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0,
                    depthWrite: false,
                    side: THREE.FrontSide
                });
                const hitSphere = new THREE.Mesh(hitSphereGeometry, hitSphereMaterial);
                hitSphere.position.copy(position);
                hitSphere.userData = {
                    cityKey: cityKey,
                    cityData: city,
                    isHitTest: true
                };
                hitSphere.renderOrder = 1;
                citiesGroup.add(hitSphere);
                
                // å…‰ç¯
                const ringGeometry = new THREE.RingGeometry(0.1, 0.15, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true, 
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(position);
                ring.lookAt(new THREE.Vector3(0, 0, 0));
                citiesGroup.add(ring);
                
                // å‘å…‰ç‚¹
                const glowGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(position);
                citiesGroup.add(glow);
                
                // æ·»åŠ åç§°æ ‡ç­¾
                const label = createTextSprite(currentLang === 'zh' ? city.name : city.englishName, '#ffffff');
                const labelPosition = position.clone().normalize().multiplyScalar(5.3);
                label.position.copy(labelPosition);
                label.userData = {
                    type: 'city',
                    key: cityKey,
                    data: city
                };
                namesGroup.visible = false;
                namesGroup.add(label);
                citiesGroup.add(label);
                cityLabels.push(label);
            });

            earthGroup.add(citiesGroup); // æ”¹ä¸ºæ·»åŠ åˆ°earthGroupï¼Œè·Ÿéšåœ°çƒæ—‹è½¬
        }
        
        // åˆ›å»ºå±±å³°æ ‡è®°ï¼ˆæ•´åˆåŸå§‹ä»£ç ï¼‰
        function createPeakMarkers() {
            peaksGroup = new THREE.Group();
            
            const highestPeaks = {
                everest: { name: "ç ç©†æœ—ç›å³°", englishName: "Mount Everest", elevation: 8848.86, coordinates: [86.9250, 27.9881], description: "ä¸–ç•Œç¬¬1é«˜å³°ï¼Œæµ·æ‹”8848.86ç±³ï¼Œä½äºä¸­å›½-å°¼æ³Šå°”è¾¹å¢ƒ", englishDescription: "The world's highest peak, with an elevation of 8,848.86 meters, located on the China-Nepal border" },
                k2: { name: "ä¹”æˆˆé‡Œå³°", englishName: "K2", elevation: 8611, coordinates: [76.5133, 35.8816], description: "ä¸–ç•Œç¬¬2é«˜å³°ï¼Œæµ·æ‹”8611ç±³ï¼Œä½äºä¸­å›½-å·´åŸºæ–¯å¦è¾¹å¢ƒ", englishDescription: "The world's second highest peak, with an elevation of 8,611 meters, located on the China-Pakistan border" },
                kangchenjunga: { name: "å¹²åŸç« å˜‰å³°", englishName: "Kangchenjunga", elevation: 8586, coordinates: [88.1475, 27.7025], description: "ä¸–ç•Œç¬¬3é«˜å³°ï¼Œæµ·æ‹”8586ç±³ï¼Œä½äºä¸­å›½-å°¼æ³Šå°”è¾¹å¢ƒ", englishDescription: "The world's third highest peak, with an elevation of 8,586 meters, located on the China-Nepal border" },
                acconcagua: { name: "é˜¿ç©ºåŠ ç“œå±±", englishName: "Aconcagua", elevation: 6961, coordinates: [-70.0109, -32.6532], description: "å—ç¾æ´²æœ€é«˜å³°ï¼Œæµ·æ‹”6961ç±³ï¼Œä½äºé˜¿æ ¹å»·", englishDescription: "The highest peak in South America, with an elevation of 6,961 meters, located in Argentina" },
                denali: { name: "è¿ªçº³åˆ©å³°", englishName: "Denali", elevation: 6190, coordinates: [-151.0074, 63.0692], description: "åŒ—ç¾æ´²æœ€é«˜å³°ï¼Œæµ·æ‹”6190ç±³ï¼Œä½äºç¾å›½é˜¿æ‹‰æ–¯åŠ ", englishDescription: "The highest peak in North America, with an elevation of 6,190 meters, located in Alaska, USA" },
                kilimanjaro: { name: "ä¹åŠ›é©¬æ‰ç½—å±±", englishName: "Kilimanjaro", elevation: 5895, coordinates: [37.3556, -3.0674], description: "éæ´²æœ€é«˜å³°ï¼Œæµ·æ‹”5895ç±³ï¼Œä½äºå¦æ¡‘å°¼äºš", englishDescription: "The highest peak in Africa, with an elevation of 5,895 meters, located in Tanzania" },
                elbrus: { name: "å„å°”å¸ƒé²å£«å±±", englishName: "Mount Elbrus", elevation: 5642, coordinates: [42.4392, 43.3499], description: "æ¬§æ´²æœ€é«˜å³°ï¼Œæµ·æ‹”5642ç±³ï¼Œä½äºä¿„ç½—æ–¯", englishDescription: "The highest peak in Europe, with an elevation of 5,642 meters, located in Russia" },
                vinson: { name: "æ–‡æ£®å³°", englishName: "Vinson Massif", elevation: 4892, coordinates: [-85.6172, -78.5254], description: "å—ææ´²æœ€é«˜å³°ï¼Œæµ·æ‹”4892ç±³ï¼Œä½äºå—ææ´²", englishDescription: "The highest peak in Antarctica, with an elevation of 4,892 meters, located in Antarctica" },
                puncakjaya: { name: "æŸ¥äºšå³°", englishName: "Puncak Jaya", elevation: 4884, coordinates: [137.1583, -4.0783], description: "å¤§æ´‹æ´²åŠæ¾³å¤§åˆ©äºšæœ€é«˜å³°ï¼Œæµ·æ‹”4884ç±³ï¼Œä½äºå°åº¦å°¼è¥¿äºš", englishDescription: "The highest peak in Oceania and Australia, with an elevation of 4,884 meters, located in Indonesia" },
                maunakea: { name: "å†’çº³å‡¯é˜¿ç«å±±", englishName: "Mauna Kea", elevation: 4207, coordinates: [-155.4681, 19.8207], description: "ä»æµ·åº•ç®—èµ·çš„æœ€é«˜å³°ï¼Œæµ·æ‹”4207ç±³ï¼Œæ€»é«˜åº¦è¶…10000ç±³ï¼Œä½äºå¤å¨å¤·", englishDescription: "The highest peak measured from the ocean floor, with an elevation of 4,207 meters, total height over 10,000 meters, located in Hawaii" },
                montblanc: { name: "å‹ƒæœ—å³°", englishName: "Mont Blanc", elevation: 4807, coordinates: [6.8649, 45.8326], description: "é˜¿å°”å‘æ–¯å±±è„‰æœ€é«˜å³°ï¼Œæµ·æ‹”4807ç±³ï¼Œä½äºæ³•-æ„è¾¹å¢ƒ", englishDescription: "The highest peak in the Alps, with an elevation of 4,807 meters, located on the France-Italy border" },
                northpole: { name: "åŒ—æç‚¹", englishName: "North Pole", elevation: 0, coordinates: [0, 90], description: "åœ°çƒæœ€åŒ—ç«¯ï¼Œåœ°ç†åŒ—æç‚¹ï¼Œä½äºåŒ—å†°æ´‹ä¸­å¿ƒï¼Œå…¨å¹´è¢«æµ·å†°è¦†ç›–", englishDescription: "The northernmost point on Earth, the geographic North Pole, located at the center of the Arctic Ocean, covered by sea ice year-round" },
                southpole: { name: "å—æç‚¹", englishName: "South Pole", elevation: 2800, coordinates: [0, -90], description: "åœ°çƒæœ€å—ç«¯ï¼Œåœ°ç†å—æç‚¹ï¼Œä½äºå—æé«˜åŸä¸Šï¼Œæµ·æ‹”çº¦2800ç±³ï¼Œæ˜¯é˜¿è’™æ£®-æ–¯ç§‘ç‰¹å—æè€ƒå¯Ÿç«™æ‰€åœ¨åœ°", englishDescription: "The southernmost point on Earth, the geographic South Pole, located on the Antarctic Plateau at an elevation of approximately 2,800 meters, home to the Amundsen-Scott South Pole Station" }
            };
            
            Object.keys(highestPeaks).forEach(peakKey => {
                const peak = highestPeaks[peakKey];
                const position = latLonToVector3(peak.coordinates[1], peak.coordinates[0], 5.08);
                
                const isPole = peakKey === 'northpole' || peakKey === 'southpole';
                const sphereColor = isPole ? 0xff8800 : 0xff0000;
                
                // å±±å³°çƒä½“
                const sphereGeometry = new THREE.SphereGeometry(0.06, 16, 16);
                const sphereMaterial = new THREE.MeshPhongMaterial({
                    color: sphereColor,
                    transparent: true,
                    opacity: 0.9,
                    emissive: isPole ? 0x442200 : 0x330000,
                    shininess: 100,
                    depthTest: true,   // å¯ç”¨æ·±åº¦æµ‹è¯•
                    depthWrite: true   // å¯ç”¨æ·±åº¦å†™å…¥
                });
                
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.copy(position);
                sphere.userData = {
                    peakKey: peakKey,
                    peakData: peak,
                    type: 'peak'
                };
                sphere.renderOrder = 1;
                peaksGroup.add(sphere);
                
                // ç¢°æ’ä½“
                const hitSphereGeometry = new THREE.SphereGeometry(0.072, 16, 16);
                const hitSphereMaterial = new THREE.MeshBasicMaterial({
                    color: sphereColor,
                    transparent: true,
                    opacity: 0,
                    depthWrite: false,
                    side: THREE.FrontSide
                });
                const hitSphere = new THREE.Mesh(hitSphereGeometry, hitSphereMaterial);
                hitSphere.position.copy(position);
                hitSphere.userData = {
                    peakKey: peakKey,
                    peakData: peak,
                    isHitTest: true
                };
                hitSphere.renderOrder = 1;
                peaksGroup.add(hitSphere);
                
                // å…‰ç¯
                const ringGeometry = new THREE.RingGeometry(0.12, 0.18, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: sphereColor,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(position);
                ring.lookAt(new THREE.Vector3(0, 0, 0));
                peaksGroup.add(ring);
                
                // å‘å…‰ç‚¹
                const glowGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: sphereColor,
                    transparent: true,
                    opacity: 0.8
                });
                
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(position);
                peaksGroup.add(glow);
                
                // æ·»åŠ åç§°æ ‡ç­¾
                const label = createTextSprite(currentLang === 'zh' ? peak.name : peak.englishName, sphereColor === 0xff8800 ? '#ff8800' : '#ff0000');
                const labelPosition = position.clone().normalize().multiplyScalar(5.3);
                label.position.copy(labelPosition);
                label.userData = {
                    type: 'peak',
                    key: peakKey,
                    data: peak
                };
                peaksGroup.add(label);
                peakLabels.push(label);
            });
            
            peaksGroup.visible = showPeaks; // è®¾ç½®åˆå§‹å¯è§çŠ¶æ€
            earthGroup.add(peaksGroup); // æ”¹ä¸ºæ·»åŠ åˆ°earthGroupï¼Œè·Ÿéšåœ°çƒæ—‹è½¬
        }
        
        // åˆ›å»ºæ¹–æ³Šæ ‡è®°ï¼ˆæ•´åˆåŸå§‹ä»£ç ï¼‰
        function createLakeMarkers() {
            lakesGroup = new THREE.Group();
            
            const majorLakes = {
                caspian: { name: "é‡Œæµ·", englishName: "Caspian Sea", area: 371000, maxDepth: 1025, coordinates: [52, 42], description: "ä¸–ç•Œæœ€å¤§å†…é™†æ¹–ï¼Œé¢ç§¯37.1ä¸‡å¹³æ–¹å…¬é‡Œï¼Œæœ€å¤§æ·±åº¦1025ç±³ï¼Œä½äºæ¬§æ´²å’Œäºšæ´²ä¹‹é—´", englishDescription: "The largest inland lake in the world, with an area of 371,000 square kilometers, maximum depth of 1,025 meters, located between Europe and Asia" },
                baikal: { name: "è´åŠ å°”æ¹–", englishName: "Lake Baikal", area: 31500, maxDepth: 1642, coordinates: [108, 53], description: "ä¸–ç•Œæœ€æ·±æ¹–æ³Šï¼Œé¢ç§¯3.15ä¸‡å¹³æ–¹å…¬é‡Œï¼Œæœ€å¤§æ·±åº¦1642ç±³ï¼Œä½äºä¿„ç½—æ–¯è¥¿ä¼¯åˆ©äºšï¼Œè“„æ°´é‡ä¸–ç•Œæœ€å¤§", englishDescription: "The world's deepest lake, with an area of 31,500 square kilometers, maximum depth of 1,642 meters, located in Siberia, Russia, with the largest water storage in the world" },
                victoria: { name: "ç»´å¤šåˆ©äºšæ¹–", englishName: "Lake Victoria", area: 68800, maxDepth: 84, coordinates: [33, -1], description: "éæ´²æœ€å¤§æ¹–æ³Šï¼Œé¢ç§¯6.88ä¸‡å¹³æ–¹å…¬é‡Œï¼Œæœ€å¤§æ·±åº¦84ç±³ï¼Œä½äºä¸œéé«˜åŸï¼Œæ˜¯å°¼ç½—æ²³å‘æºåœ°", englishDescription: "The largest lake in Africa, with an area of 68,800 square kilometers, maximum depth of 84 meters, located on the East African Plateau, the source of the Nile River" },
                tanganyika: { name: "å¦å™¶å°¼å–€æ¹–", englishName: "Lake Tanganyika", area: 32900, maxDepth: 1470, coordinates: [29, -6], description: "ä¸–ç•Œç¬¬äºŒæ·±æ¹–ï¼Œé¢ç§¯3.29ä¸‡å¹³æ–¹å…¬é‡Œï¼Œæœ€å¤§æ·±åº¦1470ç±³ï¼Œä½äºä¸œéå¤§è£‚è°·", englishDescription: "The second deepest lake in the world, with an area of 32,900 square kilometers, maximum depth of 1,470 meters, located in the East African Rift Valley" },
                superior: { name: "è‹å¿…åˆ©å°”æ¹–", englishName: "Lake Superior", area: 82100, maxDepth: 406, coordinates: [-87, 47], description: "åŒ—ç¾æ´²æœ€å¤§æ¹–ï¼Œé¢ç§¯8.21ä¸‡å¹³æ–¹å…¬é‡Œï¼Œæœ€å¤§æ·±åº¦406ç±³ï¼Œä½äºç¾å›½-åŠ æ‹¿å¤§è¾¹å¢ƒ", englishDescription: "The largest lake in North America, with an area of 82,100 square kilometers, maximum depth of 406 meters, located on the US-Canada border" },
                huron: { name: "ä¼‘ä¼¦æ¹–", englishName: "Lake Huron", area: 59600, maxDepth: 229, coordinates: [-81, 44], description: "åŒ—ç¾æ´²ç¬¬äºŒå¤§æ¹–ï¼Œé¢ç§¯5.96ä¸‡å¹³æ–¹å…¬é‡Œï¼Œæœ€å¤§æ·±åº¦229ç±³ï¼Œä½äºç¾å›½-åŠ æ‹¿å¤§è¾¹å¢ƒ", englishDescription: "The second largest lake in North America, with an area of 59,600 square kilometers, maximum depth of 229 meters, located on the US-Canada border" },
                michigan: { name: "å¯†æ­‡æ ¹æ¹–", englishName: "Lake Michigan", area: 58000, maxDepth: 281, coordinates: [-87, 43], description: "å®Œå…¨ä½äºç¾å›½å¢ƒå†…çš„æœ€å¤§æ¹–ï¼Œé¢ç§¯5.8ä¸‡å¹³æ–¹å…¬é‡Œï¼Œæœ€å¤§æ·±åº¦281ç±³", englishDescription: "The largest lake entirely within the United States, with an area of 58,000 square kilometers, maximum depth of 281 meters" }
            };
            
            Object.keys(majorLakes).forEach(lakeKey => {
                const lake = majorLakes[lakeKey];
                const position = latLonToVector3(lake.coordinates[1], lake.coordinates[0], 5.08);
                
                // æ¹–æ³Šçƒä½“ï¼ˆè“è‰²ï¼‰
                const lakeGeometry = new THREE.SphereGeometry(0.06, 16, 16);
                const lakeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x0000ff,
                    transparent: true,
                    opacity: 0.9,
                    emissive: 0x000033,
                    shininess: 100,
                    depthTest: true,   // å¯ç”¨æ·±åº¦æµ‹è¯•
                    depthWrite: true   // å¯ç”¨æ·±åº¦å†™å…¥
                });
                
                const lakeMesh = new THREE.Mesh(lakeGeometry, lakeMaterial);
                lakeMesh.position.copy(position);
                lakeMesh.userData = {
                    lakeKey: lakeKey,
                    lakeData: lake,
                    type: 'lake'
                };
                lakeMesh.renderOrder = 1;
                lakesGroup.add(lakeMesh);
                
                // ç¢°æ’ä½“
                const hitSphereGeometry = new THREE.SphereGeometry(0.072, 16, 16);
                const hitSphereMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0000ff,
                    transparent: true,
                    opacity: 0,
                    depthWrite: false,
                    side: THREE.FrontSide
                });
                const hitSphere = new THREE.Mesh(hitSphereGeometry, hitSphereMaterial);
                hitSphere.position.copy(position);
                hitSphere.userData = {
                    lakeKey: lakeKey,
                    lakeData: lake,
                    isHitTest: true
                };
                hitSphere.renderOrder = 1;
                lakesGroup.add(hitSphere);
                
                // è“è‰²å…‰ç¯
                const ringGeometry = new THREE.RingGeometry(0.12, 0.18, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0000ff,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(position);
                ring.lookAt(new THREE.Vector3(0, 0, 0));
                lakesGroup.add(ring);
                
                // è“è‰²å‘å…‰ç‚¹
                const glowGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0000ff,
                    transparent: true,
                    opacity: 0.8
                });
                
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(position);
                lakesGroup.add(glow);
                
                // æ·»åŠ åç§°æ ‡ç­¾
                const label = createTextSprite(currentLang === 'zh' ? lake.name : lake.englishName, '#0099ff');
                const labelPosition = position.clone().normalize().multiplyScalar(5.3);
                label.position.copy(labelPosition);
                label.userData = {
                    type: 'lake',
                    key: lakeKey,
                    data: lake
                };
                lakesGroup.add(label);
                lakeLabels.push(label);
            });
            
            lakesGroup.visible = showLakes; // è®¾ç½®åˆå§‹å¯è§çŠ¶æ€
            earthGroup.add(lakesGroup); // æ”¹ä¸ºæ·»åŠ åˆ°earthGroupï¼Œè·Ÿéšåœ°çƒæ—‹è½¬
        }
        
        // åˆ›å»ºæ²³æµæ ‡è®°ï¼ˆæ•´åˆåŸå§‹ä»£ç ï¼‰
        function createRiverMarkers() {
            riversGroup = new THREE.Group();
            
            const majorRivers = {
                nile: { name: "å°¼ç½—æ²³", englishName: "Nile River", length: 6650, coordinates: [32.0, 30.0], description: "ä¸–ç•Œæœ€é•¿æ²³æµï¼Œå…¨é•¿6650å…¬é‡Œï¼Œæµç»11ä¸ªå›½å®¶ï¼Œæ˜¯å¤åŸƒåŠæ–‡æ˜çš„æ‘‡ç¯®", englishDescription: "The world's longest river, stretching 6,650 kilometers, flowing through 11 countries, the cradle of ancient Egyptian civilization" },
                amazon: { name: "äºšé©¬é€Šæ²³", englishName: "Amazon River", length: 6400, coordinates: [-60.0, -3.0], description: "ä¸–ç•Œç¬¬äºŒé•¿æ²³ï¼Œæµé‡æœ€å¤§ï¼Œå…¨é•¿6400å…¬é‡Œï¼Œæµç»å—ç¾æ´²7ä¸ªå›½å®¶", englishDescription: "The world's second longest river with the largest water flow, stretching 6,400 kilometers, flowing through 7 countries in South America" },
                yangtze: { name: "é•¿æ±Ÿ", englishName: "Yangtze River", length: 6300, coordinates: [117.0, 30.0], description: "äºšæ´²ç¬¬ä¸€é•¿æ²³ï¼Œå…¨é•¿6300å…¬é‡Œï¼Œä¸­å›½æ¯äº²æ²³ï¼Œä¸–ç•Œç¬¬ä¸‰é•¿æ²³", englishDescription: "The longest river in Asia, stretching 6,300 kilometers, the mother river of China, the third longest river in the world" },
                mississippi: { name: "å¯†è¥¿è¥¿æ¯”æ²³", englishName: "Mississippi River", length: 6275, coordinates: [-90.0, 35.0], description: "åŒ—ç¾æ´²ç¬¬ä¸€é•¿æ²³ï¼Œå…¨é•¿6275å…¬é‡Œï¼Œç¾å›½æœ€é‡è¦çš„æ²³æµç³»ç»Ÿ", englishDescription: "The longest river in North America, stretching 6,275 kilometers, the most important river system in the United States" },
                yenisei: { name: "å¶å°¼å¡æ²³", englishName: "Yenisei River", length: 5539, coordinates: [92.0, 58.0], description: "è¥¿ä¼¯åˆ©äºšä¸‰å¤§æ²³ä¹‹ä¸€ï¼Œå…¨é•¿5539å…¬é‡Œï¼Œæµå…¥åŒ—å†°æ´‹", englishDescription: "One of the three great rivers of Siberia, stretching 5,539 kilometers, flowing into the Arctic Ocean" },
                yellow: { name: "é»„æ²³", englishName: "Yellow River", length: 5464, coordinates: [110.0, 37.0], description: "ä¸­å›½ç¬¬äºŒé•¿æ²³ï¼Œå…¨é•¿5464å…¬é‡Œï¼Œä¸­åæ–‡æ˜çš„å‘æºåœ°", englishDescription: "The second longest river in China, stretching 5,464 kilometers, the birthplace of Chinese civilization" },
                ob: { name: "é„‚æ¯•æ²³", englishName: "Ob River", length: 5410, coordinates: [75.0, 60.0], description: "è¥¿ä¼¯åˆ©äºšä¸‰å¤§æ²³ä¹‹ä¸€ï¼Œå…¨é•¿5410å…¬é‡Œï¼Œä¿„ç½—æ–¯é‡è¦æ²³æµ", englishDescription: "One of the three great rivers of Siberia, stretching 5,410 kilometers, an important river in Russia" }
            };
            
            Object.keys(majorRivers).forEach(riverKey => {
                const river = majorRivers[riverKey];
                const position = latLonToVector3(river.coordinates[1], river.coordinates[0], 5.08);
                
                // æ²³æµçƒä½“ï¼ˆç»¿è‰²ï¼‰
                const riverGeometry = new THREE.SphereGeometry(0.06, 16, 16);
                const riverMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.9,
                    emissive: 0x003300,
                    shininess: 100,
                    depthTest: true,   // å¯ç”¨æ·±åº¦æµ‹è¯•
                    depthWrite: true   // å¯ç”¨æ·±åº¦å†™å…¥
                });
                
                const riverMesh = new THREE.Mesh(riverGeometry, riverMaterial);
                riverMesh.position.copy(position);
                riverMesh.userData = {
                    riverKey: riverKey,
                    riverData: river,
                    type: 'river'
                };
                riverMesh.renderOrder = 1;
                riversGroup.add(riverMesh);
                
                // ç¢°æ’ä½“
                const hitSphereGeometry = new THREE.SphereGeometry(0.072, 16, 16);
                const hitSphereMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0,
                    depthWrite: false,
                    side: THREE.FrontSide
                });
                const hitSphere = new THREE.Mesh(hitSphereGeometry, hitSphereMaterial);
                hitSphere.position.copy(position);
                hitSphere.userData = {
                    riverKey: riverKey,
                    riverData: river,
                    isHitTest: true
                };
                hitSphere.renderOrder = 1;
                riversGroup.add(hitSphere);
                
                // ç»¿è‰²å…‰ç¯
                const ringGeometry = new THREE.RingGeometry(0.12, 0.18, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(position);
                ring.lookAt(new THREE.Vector3(0, 0, 0));
                riversGroup.add(ring);
                
                // ç»¿è‰²å‘å…‰ç‚¹
                const glowGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.8
                });
                
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(position);
                riversGroup.add(glow);
                
                // æ·»åŠ åç§°æ ‡ç­¾
                const label = createTextSprite(currentLang === 'zh' ? river.name : river.englishName, '#00ff00');
                const labelPosition = position.clone().normalize().multiplyScalar(5.3);
                label.position.copy(labelPosition);
                label.userData = {
                    type: 'river',
                    key: riverKey,
                    data: river
                };
                riversGroup.add(label);
                riverLabels.push(label);
            });
            
            riversGroup.visible = showRivers; // è®¾ç½®åˆå§‹å¯è§çŠ¶æ€
            earthGroup.add(riversGroup); // æ”¹ä¸ºæ·»åŠ åˆ°earthGroupï¼Œè·Ÿéšåœ°çƒæ—‹è½¬
        }
        
        // åˆ›å»ºèµ¤é“å’Œå›å½’çº¿
        function createEquatorAndTropics() {
            equatorGroup = new THREE.Group(); //èµ¤é“ç»„
            tropicGroup = new THREE.Group();  //å›å½’çº¿ç»„
            latLonGroup = new THREE.Group();  //ç»çº¬çº¿ç»„
            arcAntGroup = new THREE.Group();  //æåœˆç»„
            
            // èµ¤é“çº¿
            const equatorPoints = [];
            for (let i = 0; i <= 64; i++) {
                const angle = (i / 64) * Math.PI * 2;
                equatorPoints.push(new THREE.Vector3(
                    Math.cos(angle) * 5.05,
                    0,
                    Math.sin(angle) * 5.05
                ));
            }
            
            const equatorGeometry = new THREE.BufferGeometry().setFromPoints(equatorPoints);
            const equatorMaterial = new THREE.LineBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.6
            });
            
            const equatorLine = new THREE.Line(equatorGeometry, equatorMaterial);
            equatorGroup.add(equatorLine);
            equatorGroup.visible = false;
            earthGroup.add(equatorGroup); // æ”¹ä¸ºæ·»åŠ åˆ°earthGroupï¼Œè·Ÿéšåœ°çƒæ—‹è½¬
            
            // å—åŒ—å›å½’çº¿
            const tropicLatitudes = [23.5, -23.5];
            tropicLatitudes.forEach((lat, index) => {
                const tropicPoints = [];
                const radius = Math.cos(lat * Math.PI / 180) * 5.05;
                const y = Math.sin(lat * Math.PI / 180) * 5.05;
                
                for (let i = 0; i <= 64; i++) {
                    const angle = (i / 64) * Math.PI * 2;
                    tropicPoints.push(new THREE.Vector3(
                        Math.cos(angle) * radius,
                        y,
                        Math.sin(angle) * radius
                    ));
                }
                
                const tropicGeometry = new THREE.BufferGeometry().setFromPoints(tropicPoints);
                const tropicMaterial = new THREE.LineBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.6
                });
                
                const tropicLine = new THREE.Line(tropicGeometry, tropicMaterial);
                tropicGroup.add(tropicLine);
            });
            
            tropicGroup.visible = false;
            earthGroup.add(tropicGroup); // æ”¹ä¸ºæ·»åŠ åˆ°earthGroupï¼Œè·Ÿéšåœ°çƒæ—‹è½¬

            // åŒ—æåœˆ (çº¬åº¦ 66.5Â°N)
            const arcticCirclePoints = [];
            for (let lon = 0; lon <= 360; lon += 5) {
                const point = latLonToVector3(66.5, lon, 5.05);
                arcticCirclePoints.push(point);
            }
            const arcticCircleGeometry = new THREE.BufferGeometry().setFromPoints(arcticCirclePoints);
            const arcticCircleMaterial = new THREE.LineBasicMaterial({
                color: 0x0088ff,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });
            const arcticCircleLine = new THREE.Line(arcticCircleGeometry, arcticCircleMaterial);
            arcAntGroup.add(arcticCircleLine);

            // å—æåœˆ (çº¬åº¦ 66.5Â°S)
            const antarcticCirclePoints = [];
            for (let lon = 0; lon <= 360; lon += 5) {
                const point = latLonToVector3(-66.5, lon, 5.05);
                antarcticCirclePoints.push(point);
            }
            const antarcticCircleGeometry = new THREE.BufferGeometry().setFromPoints(antarcticCirclePoints);
            const antarcticCircleMaterial = new THREE.LineBasicMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });
            const antarcticCircleLine = new THREE.Line(antarcticCircleGeometry, antarcticCircleMaterial);
            arcAntGroup.add(antarcticCircleLine);
            arcAntGroup.visible = false;
            earthGroup.add(arcAntGroup); // æ”¹ä¸ºæ·»åŠ åˆ°earthGroupï¼Œè·Ÿéšåœ°çƒæ—‹è½¬
            // åˆ›å»ºç»çº¬åº¦ç½‘æ ¼
            // ç»åº¦çº¿ï¼ˆæ¯30åº¦ä¸€æ¡ï¼‰
            for (let lon = 0; lon < 360; lon += 30) {
                const lonPoints = [];
                for (let lat = -90; lat <= 90; lat += 5) {
                    const position = latLonToVector3(lat, lon, 5.05);
                    lonPoints.push(position);
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(lonPoints);
                const material = new THREE.LineBasicMaterial({
                    color: 0x888888,
                    transparent: true,
                    opacity: 0.3
                });
                
                const line = new THREE.Line(geometry, material);
                latLonGroup.add(line);
            }
            
            // çº¬åº¦çº¿ï¼ˆæ¯30åº¦ä¸€æ¡ï¼Œä¸åŒ…æ‹¬èµ¤é“å’Œå›å½’çº¿ï¼‰
            for (let lat = -60; lat <= 60; lat += 30) {
                const latPoints = [];
                const radius = Math.cos(lat * Math.PI / 180) * 5.05;
                const y = Math.sin(lat * Math.PI / 180) * 5.05;
                
                for (let lon = 0; lon <= 360; lon += 10) {
                    const angle = lon * Math.PI / 180;
                    latPoints.push(new THREE.Vector3(
                        Math.cos(angle) * radius,
                        y,
                        Math.sin(angle) * radius
                    ));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(latPoints);
                const material = new THREE.LineBasicMaterial({
                    color: 0xaaaaaa,
                    transparent: true,
                    opacity: 0.3
                });
                
                const line = new THREE.Line(geometry, material);
                latLonGroup.add(line);
            }
            latLonGroup.visible = false;
            earthGroup.add(latLonGroup);
        }
        
        // åˆ›å»ºæ ‡è®°
        function createMarker(position, color, name, type) {
            const group = new THREE.Group();
            group.position.copy(position);
            
            // æ ‡è®°çƒä½“
            const geometry = new THREE.SphereGeometry(1, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8
            });
            const sphere = new THREE.Mesh(geometry, material);
            group.add(sphere);
            
            // å‘å…‰ç¯
            const ringGeometry = new THREE.RingGeometry(1.5, 2, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.lookAt(new THREE.Vector3(0, 0, 0));
            group.add(ring);
            
            // æ ‡è®°æ•°æ®
            group.userData = {
                name: name,
                englishName: name,
                type: type,
                isMarker: true
            };
            
            return group;
        }
        
        // ===== è‡ªå®šä¹‰æ ‡è®°åŠŸèƒ½ =====
        function addCustomMarker(lat, lon, name, color = 0xff4444) {
            if (!customMarkersGroup) {
                console.error('è‡ªå®šä¹‰æ ‡è®°ç»„æœªåˆå§‹åŒ–');
                return null;
            }
            
            const position = latLonToVector3(lat, lon, 5.08);
            
            // åˆ›å»ºæ ‡è®°ç»„
            const markerGroup = new THREE.Group();
            markerGroup.position.copy(position);
            markerGroup.renderOrder = 10; // æé«˜æ¸²æŸ“é¡ºåº
            
            // é»„è‰²é”¥å½¢æ ‡è®°ï¼ˆå¢å¤§å°ºå¯¸ï¼‰
            const coneGeometry = new THREE.ConeGeometry(0.03, 0.075, 12);
            const coneMaterial = new THREE.MeshPhongMaterial({
                color: 0xffff00, // å›ºå®šä¸ºé»„è‰²
                transparent: true,
                opacity: 0.95,
                emissive: 0xffff00,
                emissiveIntensity: 0.4,
                depthTest: false, // ç¦ç”¨æ·±åº¦æµ‹è¯•ï¼Œç¡®ä¿æ˜¾ç¤ºåœ¨æœ€å‰é¢
                depthWrite: false
            });
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
            // æ—‹è½¬é”¥å½¢ï¼Œä½¿å…¶å°–ç«¯æœå‘åœ°çƒä¸­å¿ƒ
            const inward = position.clone().negate().normalize();
            cone.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), inward);
            cone.renderOrder = 11; // é”¥å½¢æ¸²æŸ“é¡ºåºæ›´é«˜
            markerGroup.add(cone);
            
            // å…‰ç¯æ•ˆæœï¼ˆä½¿ç”¨RingGeometryï¼Œå¢å¤§å°ºå¯¸ï¼‰
            const ringGeometry = new THREE.RingGeometry(0.05, 0.075, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00, // é»„è‰²
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide,
                depthTest: false,
                depthWrite: false
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            // ä½¿å…‰ç¯æ³•çº¿æŒ‡å‘åœ°çƒä¸­å¿ƒ
            ring.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), inward);
            ring.renderOrder = 10;
            markerGroup.add(ring);
            
            // è„‰å†²å…‰ç¯åŠ¨ç”»ï¼ˆå¢å¤§å°ºå¯¸ï¼‰
            const pulseRingGeometry = new THREE.RingGeometry(0.0625, 0.1, 16);
            const pulseRingMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00, // é»„è‰²
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                depthTest: false,
                depthWrite: false
            });
            const pulseRing = new THREE.Mesh(pulseRingGeometry, pulseRingMaterial);
            // ä½¿è„‰å†²å…‰ç¯æ³•çº¿æŒ‡å‘åœ°çƒä¸­å¿ƒ
            pulseRing.quaternion.copy(ring.quaternion);
            pulseRing.userData.pulse = 0;
            pulseRing.renderOrder = 9;
            markerGroup.add(pulseRing);
            
            // æ–‡å­—æ ‡ç­¾ï¼ˆæé«˜ä½ç½®ï¼‰
            let displayText = name;
            let textColor = '#ffffff';
            // å¦‚æœæ˜¯å½“å‰ä½ç½®æ ‡è®°ï¼Œæ ¹æ®è¯­è¨€é€‰æ‹©æ–‡æœ¬ï¼Œé¢œè‰²ä¸ºé»„è‰²
            if (name === 'here/è¿™é‡Œ') {
                displayText = currentLang === 'zh' ? 'è¿™é‡Œ' : 'here';
                textColor = '#ffff00';
            }
            const textSprite = createTextSprite(displayText, textColor);
            textSprite.position.set(0, 0.4, 0);
            textSprite.scale.set(0.6, 0.6, 1);
            textSprite.renderOrder = 12; // æ–‡å­—æ¸²æŸ“é¡ºåºæœ€é«˜
            markerGroup.add(textSprite);
            
            // æ ‡è®°æ•°æ®
            markerGroup.userData = {
                name: displayText,
                originalName: name,
                type: 'custom',
                lat: lat,
                lon: lon,
                color: 0xffff00, // å­˜å‚¨é»„è‰²
                cone: cone,
                ring: ring,
                pulseRing: pulseRing,
                isCustomMarker: true
            };
            
            customMarkersGroup.add(markerGroup);
            customMarkers.push(markerGroup);
            
            // æ·»åŠ åˆ°åŠ¨ç”»æ›´æ–°
            if (!animationUpdates.some(update => update.id === 'customMarkers')) {
                animationUpdates.push({
                    id: 'customMarkers',
                    update: function(time) {
                        if (customMarkersGroup && customMarkersGroup.visible) {
                            customMarkers.forEach((marker, index) => {
                                // é”¥å½¢æ ‡è®°ä¸Šä¸‹è·³åŠ¨åŠ¨ç”»
                                if (marker.userData.cone) {
                                    const bounce = Math.sin(time * 3 + index * 0.5) * 0.03;
                                    const originalPosition = marker.position.clone().normalize();
                                    marker.userData.cone.position.copy(originalPosition.multiplyScalar(bounce));
                                }
                                
                                // å…‰ç¯ç¼©æ”¾åŠ¨ç”»ï¼ˆä¸åŸå¸‚æ ‡è®°ä¿æŒä¸€è‡´ï¼‰
                                if (marker.userData.ring) {
                                    const scale = 1 + Math.sin(time * 4 + index * 0.3) * 0.3;
                                    marker.userData.ring.scale.setScalar(scale);
                                    marker.userData.ring.material.opacity = 0.5 * (1 + Math.sin(time * 4 + index * 0.3)) * 0.5;
                                }
                                
                                // è„‰å†²å…‰ç¯ç¼©æ”¾åŠ¨ç”»
                                if (marker.userData.pulseRing) {
                                    const pulseScale = 1 + Math.sin(time * 2 + index * 0.2) * 0.4;
                                    marker.userData.pulseRing.scale.setScalar(pulseScale);
                                    marker.userData.pulseRing.material.opacity = 0.3 * (1 + Math.sin(time * 2 + index * 0.2)) * 0.5;
                                }
                            });
                        }
                    }
                });
            }
            
            return markerGroup;
        }
        
        function clearCustomMarkers() {
            if (!customMarkersGroup) return;
            
            while (customMarkersGroup.children.length > 0) {
                customMarkersGroup.remove(customMarkersGroup.children[0]);
            }
            
            customMarkers = [];
            
            // é‡ç½®è§†å›¾å¹¶å¼€å§‹æ—‹è½¬
            controls.reset();
            camera.position.set(0, 0, 10);
            controls.update();
            
            // å¼€å§‹åœ°çƒæ—‹è½¬
            isRotating = true;
            const toggleButton = document.getElementById('toggleRotation');
            if (toggleButton) {
                toggleButton.textContent = texts[currentLang].toggleButtons.rotation[0];
            }
            
            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            const statusEl = document.getElementById('locationStatus');
            statusEl.textContent = 'å·²æ¸…é™¤æ‰€æœ‰è‡ªå®šä¹‰æ ‡è®°';
            statusEl.className = 'success';
            
            setTimeout(() => {
                statusEl.textContent = '';
                statusEl.className = '';
            }, 3000);
        }
        
        // ===== åœ°ç†ç¼–ç å’Œä½ç½®æœåŠ¡ =====

        
        function getCurrentLocation() {
            const statusEl = document.getElementById('locationStatus');
            
            if (!navigator.geolocation) {
                statusEl.textContent = 'æµè§ˆå™¨ä¸æ”¯æŒåœ°ç†ä½ç½®åŠŸèƒ½';
                statusEl.className = 'error';
                setTimeout(() => { statusEl.textContent = ''; statusEl.className = ''; }, 3000);
                return;
            }
            
            statusEl.textContent = 'æ­£åœ¨è·å–æ‚¨çš„ä½ç½®...';
            statusEl.className = 'info';
            
            navigator.geolocation.getCurrentPosition(
                async (position) => {
                    const lat = position.coords.latitude;
                    const lon = position.coords.longitude;
                    
                    statusEl.textContent = `æ‚¨çš„ä½ç½®: (${lat.toFixed(4)}, ${lon.toFixed(4)})`;
                    if (currentLevel !== 'earth') {
                        statusEl.textContent += ' - è¿›å…¥åœ°çƒæŸ¥çœ‹æ ‡è®°';
                    }
                    statusEl.className = 'success';
                    
                    // åå‘åœ°ç†ç¼–ç è·å–ä½ç½®åç§°
                    try {
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 10000);
                        const response = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json`, {
                            headers: {
                                'User-Agent': 'UniverseModel/1.0 (https://example.com)'
                            },
                            signal: controller.signal
                        });
                        clearTimeout(timeoutId);
                        const data = await response.json();
                        
                        // å½“å‰ä½ç½®æ ‡è®°ä½¿ç”¨ "here/è¿™é‡Œ"
                        const locationName = 'here/è¿™é‡Œ';
                        
                        // æ·»åŠ æ ‡è®°åˆ°åœ°çƒ
                        const marker = addCustomMarker(lat, lon, locationName, 0xffff00);
                        
                        if (marker) {
                            // æ˜¾ç¤ºå½“å‰ä½ç½®æ ‡è®°åï¼Œè‡ªåŠ¨æš‚åœåœ°çƒæ—‹è½¬
                            isRotating = false;
                            const toggleButton = document.getElementById('toggleRotation');
                            if (toggleButton) {
                                toggleButton.textContent = texts[currentLang].toggleButtons.rotation[1];
                            }
                            
                            // å¦‚æœä¸åœ¨"earth"å±‚çº§ï¼Œåˆ‡æ¢åˆ°åœ°çƒå±‚çº§
                            if (currentLevel !== 'earth') {
                                // åˆ‡æ¢åˆ°åœ°çƒå±‚çº§ï¼ˆä¸å¸¦åŠ¨ç”»ï¼‰
                                currentLevel = 'earth';
                                solarSystem.visible = false;
                                earthSystem.visible = true;
                                if (customMarkersGroup) customMarkersGroup.visible = true;
                                if (solarStarfield) solarStarfield.visible = false;
                                if (earthStarfield) earthStarfield.visible = true;
                                if (window.earthMoon) window.earthMoon.visible = true;
                                document.getElementById('earth-controls').classList.add('visible');
                                document.getElementById('galaxy-controls').classList.remove('visible');
                                document.getElementById('solar-controls').classList.remove('visible');
                                panelToggleCount = 0;
                                isPanelVisible = true;
                                showingCredits = false;
                                document.getElementById('normalInfo').style.display = 'block';
                                document.getElementById('normalInfo2').style.display = 'block';
                                document.getElementById('creditsInfo').style.display = 'none';
                                setupEarthControls();
                                updateNavButtons();
                                document.getElementById('instructions').innerHTML = texts[currentLang].instructions.earth;
                            }
                            
                            // å°†ç›¸æœºèšç„¦åˆ°è¯¥ä½ç½®
                            const worldPosition = new THREE.Vector3();
                            marker.getWorldPosition(worldPosition);
                            const cameraPosition = worldPosition.clone().multiplyScalar(1.5);
                            
                            camera.position.copy(cameraPosition);
                            // ä¿æŒç›¸æœºçœ‹å‘å½“å‰ç›®æ ‡ï¼ˆåœ°çƒä¸­å¿ƒï¼‰ï¼Œä¸æ”¹å˜OrbitControlsç›®æ ‡
                        }
                        
                    } catch (error) {
                        console.error('åå‘åœ°ç†ç¼–ç é”™è¯¯:', error);
                        // å³ä½¿åå‘åœ°ç†ç¼–ç å¤±è´¥ï¼Œä¹Ÿæ·»åŠ æ ‡è®°
                        const marker = addCustomMarker(lat, lon, 'here/è¿™é‡Œ', 0xffff00);
                        
                        if (marker) {
                            // æ˜¾ç¤ºå½“å‰ä½ç½®æ ‡è®°åï¼Œè‡ªåŠ¨æš‚åœåœ°çƒæ—‹è½¬
                            isRotating = false;
                            const toggleButton = document.getElementById('toggleRotation');
                            if (toggleButton) {
                                toggleButton.textContent = texts[currentLang].toggleButtons.rotation[1];
                            }
                            
                            // å¦‚æœä¸åœ¨"earth"å±‚çº§ï¼Œåˆ‡æ¢åˆ°åœ°çƒå±‚çº§
                            if (currentLevel !== 'earth') {
                                // åˆ‡æ¢åˆ°åœ°çƒå±‚çº§ï¼ˆä¸å¸¦åŠ¨ç”»ï¼‰
                                currentLevel = 'earth';
                                solarSystem.visible = false;
                                earthSystem.visible = true;
                                if (customMarkersGroup) customMarkersGroup.visible = true;
                                if (solarStarfield) solarStarfield.visible = false;
                                if (earthStarfield) earthStarfield.visible = true;
                                if (window.earthMoon) window.earthMoon.visible = true;
                                document.getElementById('earth-controls').classList.add('visible');
                                document.getElementById('galaxy-controls').classList.remove('visible');
                                document.getElementById('solar-controls').classList.remove('visible');
                                panelToggleCount = 0;
                                isPanelVisible = true;
                                showingCredits = false;
                                document.getElementById('normalInfo').style.display = 'block';
                                document.getElementById('normalInfo2').style.display = 'block';
                                document.getElementById('creditsInfo').style.display = 'none';
                                setupEarthControls();
                                updateNavButtons();
                                document.getElementById('instructions').innerHTML = texts[currentLang].instructions.earth;
                            }
                            
                            // å°†ç›¸æœºèšç„¦åˆ°è¯¥ä½ç½®
                            const worldPosition = new THREE.Vector3();
                            marker.getWorldPosition(worldPosition);
                            const cameraPosition = worldPosition.clone().multiplyScalar(1.5);
                            
                            camera.position.copy(cameraPosition);
                            // ä¿æŒç›¸æœºçœ‹å‘å½“å‰ç›®æ ‡ï¼ˆåœ°çƒä¸­å¿ƒï¼‰ï¼Œä¸æ”¹å˜OrbitControlsç›®æ ‡
                        }
                    }
                    
                    setTimeout(() => { 
                        statusEl.textContent = ''; 
                        statusEl.className = ''; 
                    }, 5000);
                },
                (error) => {
                    let errorMessage = 'æ— æ³•è·å–ä½ç½®';
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage = 'ç”¨æˆ·æ‹’ç»äº†ä½ç½®è¯·æ±‚';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage = 'ä½ç½®ä¿¡æ¯ä¸å¯ç”¨';
                            break;
                        case error.TIMEOUT:
                            errorMessage = 'è·å–ä½ç½®è¶…æ—¶';
                            break;
                    }
                    
                    statusEl.textContent = errorMessage;
                    statusEl.className = 'error';
                    setTimeout(() => { statusEl.textContent = ''; statusEl.className = ''; }, 5000);
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        }
        
        // ===== äº‹ä»¶å¤„ç† =====
        function onMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // æ£€æµ‹æ‚¬åœå¹¶é«˜äº®ï¼ˆåŒ…æ‹¬åœ°çƒå±‚çº§ï¼‰
            checkHover();
        }
        
        function onClick(event) {
            raycaster.setFromCamera(mouse, camera);

            // åœ°çƒå±‚çº§çš„ç‚¹å‡»å¤„ç†
            if (currentLevel === 'earth' && earthSystem.visible) {
                const allEarthObjects = [];
                if (citiesGroup) allEarthObjects.push(...citiesGroup.children);
                if (peaksGroup) allEarthObjects.push(...peaksGroup.children);
                if (lakesGroup) allEarthObjects.push(...lakesGroup.children);
                if (riversGroup) allEarthObjects.push(...riversGroup.children);

                const intersects = raycaster.intersectObjects(allEarthObjects, true);

                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    const worldPosition = new THREE.Vector3();
                    object.getWorldPosition(worldPosition);

                    const cameraPosition = camera.position.clone();
                    const objectToCamera = worldPosition.clone().sub(cameraPosition).normalize();
                    const objectToCenter = worldPosition.clone().normalize();
                    const dotProduct = objectToCamera.dot(objectToCenter);

                    if (dotProduct < 0) {
                        let data = null;
                        let key = null;
                        let obj = null;

                        if (object.userData.cityKey) {
                            data = object.userData.cityData;
                            key = object.userData.cityKey;
                            obj = object;
                            showCityTooltip(data, key, obj);
                        } else if (object.userData.peakKey) {
                            data = object.userData.peakData;
                            key = object.userData.peakKey;
                            obj = object;
                            showPeakTooltip(data, key, obj);
                        } else if (object.userData.lakeKey) {
                            data = object.userData.lakeData;
                            key = object.userData.lakeKey;
                            obj = object;
                            showLakeTooltip(data, key, obj);
                        } else if (object.userData.riverKey) {
                            data = object.userData.riverData;
                            key = object.userData.riverKey;
                            obj = object;
                            showRiverTooltip(data, key, obj);
                        }

                        if (data) {
                            isRotating = false;
                            const toggleButton = document.getElementById('toggleRotation');
                            if (toggleButton) {
                                toggleButton.textContent = texts[currentLang].toggleButtons.rotation[2]; // æ¢å¤æ—‹è½¬
                            }
                        }
                    }
                }
                return;
            }

            let intersects;

            if (currentLevel === 'galaxy') {
                intersects = raycaster.intersectObjects(galaxy.children, true);
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    if (object.parent && object.parent.userData.isMarker) {
                        if (object.parent.userData.type === 'solar') {
                            transitionToSolarSystem();
                        }
                    }
                }
            } else if (currentLevel === 'solar') {
                intersects = raycaster.intersectObjects(solarSystem.children, true);
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    if (object.userData.isEarth) {
                        transitionToEarth();
                    }
                }
            }
        }
        
        // æ£€æµ‹é¼ æ ‡æ‚¬åœ
        function checkHover() {
            raycaster.setFromCamera(mouse, camera);

            // åœ°çƒå±‚çº§çš„æ‚¬åœæ£€æµ‹
            if (currentLevel === 'earth' && earthSystem.visible) {
                const allEarthObjects = [];
                if (citiesGroup) allEarthObjects.push(...citiesGroup.children);
                if (peaksGroup) allEarthObjects.push(...peaksGroup.children);
                if (lakesGroup) allEarthObjects.push(...lakesGroup.children);
                if (riversGroup) allEarthObjects.push(...riversGroup.children);

                const intersects = raycaster.intersectObjects(allEarthObjects, true);

                // é‡ç½®æ‰€æœ‰é«˜äº®
                [citiesGroup, peaksGroup, lakesGroup, riversGroup].forEach(group => {
                    if (group) {
                        group.children.forEach(child => {
                            if (child.userData && (child.userData.cityKey || child.userData.peakKey || child.userData.lakeKey || child.userData.riverKey) && !child.userData.isHitTest) {
                                child.scale.setScalar(1);
                            }
                        });
                    }
                });

                // å¤„ç†æ‚¬åœï¼ˆåœ°çƒå±‚çº§ä¹Ÿæ”¯æŒè‡ªåŠ¨å¼¹çª—ï¼‰
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    const worldPosition = new THREE.Vector3();
                    object.getWorldPosition(worldPosition);

                    // æ£€æŸ¥æ˜¯å¦åœ¨åœ°çƒæ­£é¢
                    const cameraPosition = camera.position.clone();
                    const objectToCamera = worldPosition.clone().sub(cameraPosition).normalize();
                    const objectToCenter = worldPosition.clone().normalize();
                    const dotProduct = objectToCamera.dot(objectToCenter);

                    if (dotProduct < 0) { // åœ¨æ­£é¢
                        let data = null;
                        let type = '';
                        let key = null;

                        if (object.userData.cityKey) {
                            data = object.userData.cityData;
                            type = 'city';
                            key = object.userData.cityKey;
                        } else if (object.userData.peakKey) {
                            data = object.userData.peakData;
                            type = 'peak';
                            key = object.userData.peakKey;
                        } else if (object.userData.lakeKey) {
                            data = object.userData.lakeData;
                            type = 'lake';
                            key = object.userData.lakeKey;
                        } else if (object.userData.riverKey) {
                            data = object.userData.riverData;
                            type = 'river';
                            key = object.userData.riverKey;
                        }

                        if (data) {
                            // æ£€æŸ¥æ ‡è®°ç»„æ˜¯å¦å¯è§
                            let isVisible = false;
                            if (type === 'city') isVisible = showCities;
                            else if (type === 'peak') isVisible = showPeaks;
                            else if (type === 'lake') isVisible = showLakes;
                            else if (type === 'river') isVisible = showRivers;

                            if (!isVisible) {
                                // æ ‡è®°ç»„éšè—ï¼Œä¸æ˜¾ç¤ºå¼¹çª—
                                document.body.style.cursor = 'default';
                                document.getElementById('instructions').innerHTML = texts[currentLang].instructions.earth;
                                return;
                            }

                            // é«˜äº®
                            object.scale.setScalar(1.3);
                            document.body.style.cursor = 'pointer';
                            document.getElementById('instructions').innerHTML = texts[currentLang].instructions.hover.replace('%s', currentLang === 'zh' ? data.name : (data.englishName || data.name));

                            // è‡ªåŠ¨æ˜¾ç¤ºå¼¹çª—ï¼ˆæ‚¬åœæ—¶ç«‹å³æ˜¾ç¤ºï¼‰
                            let showFunction = null;
                            if (type === 'city') showFunction = showCityTooltip;
                            else if (type === 'peak') showFunction = showPeakTooltip;
                            else if (type === 'lake') showFunction = showLakeTooltip;
                            else if (type === 'river') showFunction = showRiverTooltip;

                            if (showFunction) {
                                showFunction(data, key, object);

                                // å¼¹çª—æ˜¾ç¤ºæ—¶æš‚åœåœ°çƒæ—‹è½¬
                                isRotating = false;
                                const toggleButton = document.getElementById('toggleRotation');
                                if (toggleButton) {
                                    toggleButton.textContent = texts[currentLang].toggleButtons.rotation[2]; // æ¢å¤æ—‹è½¬
                                }
                            }

                            // é¼ æ ‡ä»åœ¨æ ‡è¯†ä¸Šï¼Œå–æ¶ˆå»¶è¿Ÿå…³é—­
                            cancelTooltipHide();
                        }
                    } else {
                        document.body.style.cursor = 'default';
                        document.getElementById('instructions').innerHTML = texts[currentLang].instructions.earth;
                        // é¼ æ ‡ç§»å¼€åï¼Œå¼€å§‹1ç§’å€’è®¡æ—¶å…³é—­å¼¹çª—
                        if (currentTooltip) {
                            scheduleTooltipHide();
                        }
                    }
                } else {
                    document.body.style.cursor = 'default';
                    document.getElementById('instructions').innerHTML = texts[currentLang].instructions.earth;
                    // é¼ æ ‡ç§»å¼€åï¼Œå¼€å§‹1ç§’å€’è®¡æ—¶å…³é—­å¼¹çª—
                    if (currentTooltip) {
                        scheduleTooltipHide();
                    }
                }

                return;
            }

            if (currentLevel === 'galaxy') {
                const intersects = raycaster.intersectObjects(galaxy.children, true);
                
                // é‡ç½®æ‰€æœ‰é«˜äº®
                [citiesGroup, peaksGroup, lakesGroup, riversGroup].forEach(group => {
                    if (group) {
                        group.children.forEach(child => {
                            if (child.userData && (child.userData.cityKey || child.userData.peakKey || child.userData.lakeKey || child.userData.riverKey) && !child.userData.isHitTest) {
                                child.scale.setScalar(1);
                            }
                        });
                    }
                });
                
                // å¤„ç†æ‚¬åœ
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    const worldPosition = new THREE.Vector3();
                    object.getWorldPosition(worldPosition);
                    
                    // æ£€æŸ¥æ˜¯å¦åœ¨åœ°çƒæ­£é¢
                    const cameraPosition = camera.position.clone();
                    const objectToCamera = worldPosition.clone().sub(cameraPosition).normalize();
                    const objectToCenter = worldPosition.clone().normalize();
                    const dotProduct = objectToCamera.dot(objectToCenter);
                    
                    if (dotProduct < 0) { // åœ¨æ­£é¢
                        let data = null;
                        let type = '';
                        
                        if (object.userData.cityKey) {
                            data = object.userData.cityData;
                            type = 'city';
                        } else if (object.userData.peakKey) {
                            data = object.userData.peakData;
                            type = 'peak';
                        } else if (object.userData.lakeKey) {
                            data = object.userData.lakeData;
                            type = 'lake';
                        } else if (object.userData.riverKey) {
                            data = object.userData.riverData;
                            type = 'river';
                        }
                        
                        if (data) {
                            // é«˜äº®
                            object.scale.setScalar(1.3);
                            document.body.style.cursor = 'pointer';
                            document.getElementById('instructions').innerHTML = texts[currentLang].instructions.hover.replace('%s', currentLang === 'zh' ? data.name : (data.englishName || data.name));
                            
                            // è‡ªåŠ¨æ˜¾ç¤ºå¼¹çª—ï¼ˆæ‚¬åœæ—¶ç«‹å³æ˜¾ç¤ºï¼‰
                            let showFunction = null;
                            if (type === 'city') showFunction = showCityTooltip;
                            else if (type === 'peak') showFunction = showPeakTooltip;
                            else if (type === 'lake') showFunction = showLakeTooltip;
                            else if (type === 'river') showFunction = showRiverTooltip;
                            
                            if (showFunction && (!currentTooltip || currentTooltip !== getActiveTooltip(type, key))) {
                                showFunction(data, key, object);
                            }
                            
                            // è®¾ç½®å»¶è¿Ÿå…³é—­è®¡æ—¶å™¨
                            scheduleTooltipHide();
                        }
                } else {
                    document.body.style.cursor = 'default';
                    document.getElementById('instructions').innerHTML = texts[currentLang].instructions.galaxy;
                    // é¼ æ ‡ç§»å¼€åï¼Œå¼€å§‹1ç§’å€’è®¡æ—¶å…³é—­å¼¹çª—
                    if (currentTooltip) {
                        scheduleTooltipHide();
                    }
                }
            } else {
                document.body.style.cursor = 'default';
                document.getElementById('instructions').innerHTML = texts[currentLang].instructions.galaxy;
                // é¼ æ ‡ç§»å¼€åï¼Œå¼€å§‹1ç§’å€’è®¡æ—¶å…³é—­å¼¹çª—
                if (currentTooltip) {
                    scheduleTooltipHide();
                }
            }
                
                return;
            }
            
            if (currentLevel === 'galaxy') {
                const intersects = raycaster.intersectObjects(galaxy.children, true);
                
                // é‡ç½®æ‰€æœ‰æ ‡è®°
                galaxy.children.forEach(child => {
                    if (child.userData.isMarker) {
                        child.children[0].material.opacity = 0.8;
                        child.children[1].material.opacity = 0.3;
                        child.scale.setScalar(1);
                    }
                });
                
                // é«˜äº®æ‚¬åœçš„æ ‡è®°
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    if (object.parent && object.parent.userData.isMarker) {
                        object.parent.children[0].material.opacity = 1;
                        object.parent.children[1].material.opacity = 0.6;
                        object.parent.scale.setScalar(1.2);
                        document.body.style.cursor = 'pointer';
                        document.getElementById('instructions').innerHTML = texts[currentLang].instructions.click.replace('%s', currentLang === 'zh' ? object.parent.userData.name : (object.parent.userData.englishName || object.parent.userData.name));
                    } else {
                        document.body.style.cursor = 'default';
                        document.getElementById('instructions').innerHTML = texts[currentLang].instructions.galaxy;
                    }
                } else {
                    document.body.style.cursor = 'default';
                    document.getElementById('instructions').innerHTML = texts[currentLang].instructions.galaxy;
                }
                
            } else if (currentLevel === 'solar') {
                const intersects = raycaster.intersectObjects(solarSystem.children, true);
                
                // é‡ç½®è¡Œæ˜Ÿ
                planets.forEach(planet => {
                    planet.material.opacity = 0.9;
                    planet.scale.setScalar(1);
                });
                
                // é«˜äº®æ‚¬åœçš„è¡Œæ˜Ÿ
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    if (object.userData.isEarth) {
                        object.material.opacity = 1;
                        object.scale.setScalar(1.3);
                        document.body.style.cursor = 'pointer';
                        document.getElementById('instructions').innerHTML = texts[currentLang].instructions.click.replace('%s', currentLang === 'zh' ? 'åœ°çƒ' : 'Earth');
                    } else {
                        document.body.style.cursor = 'default';
                        document.getElementById('instructions').innerHTML = texts[currentLang].instructions.solar;
                    }
                } else {
                    document.body.style.cursor = 'default';
                    document.getElementById('instructions').innerHTML = texts[currentLang].instructions.solar;
                }
            }
        }
        
        // è¿‡æ¸¡åˆ°å¤ªé˜³ç³»
        function transitionToSolarSystem() {
            currentLevel = 'solar';
            
            // éšè—é“¶æ²³ç³»ï¼Œæ˜¾ç¤ºå¤ªé˜³ç³»
            galaxy.visible = false;
            solarSystem.visible = true;
            
            // æ˜¾ç¤ºå¤ªé˜³ç³»æ˜Ÿç©ºèƒŒæ™¯
            if (solarStarfield) {
                solarStarfield.visible = true;
            }
            
            // å¹³æ»‘ç§»åŠ¨ç›¸æœº
            animateCamera(
                cameraPositions.solar.position,
                cameraPositions.solar.target,
                2000
            );
            
                // æ˜¾ç¤ºè¿”å›æŒ‰é’®
                document.getElementById('back-button').style.display = 'block';
                
                // æ˜¾ç¤ºå¤ªé˜³ç³»æ§åˆ¶é¢æ¿
                document.getElementById('solar-controls').classList.add('visible');
                document.getElementById('galaxy-controls').classList.remove('visible');
                
                // è®¾ç½®å¤ªé˜³ç³»å±‚çº§æ§åˆ¶
                setupSolarControls();

                document.getElementById('instructions').innerHTML = texts[currentLang].instructions.solar;
                
                // æ›´æ–°å¯¼èˆªæŒ‰é’®
                updateNavButtons();
        }
        
        // è¿‡æ¸¡åˆ°åœ°çƒ
        function transitionToEarth() {
            currentLevel = 'earth';

            // éšè—å¤ªé˜³ç³»ï¼Œæ˜¾ç¤ºåœ°çƒ
            solarSystem.visible = false;
            earthSystem.visible = true;
            
            // æ˜¾ç¤ºè‡ªå®šä¹‰æ ‡è®°ç»„
            if (customMarkersGroup) {
                customMarkersGroup.visible = true;
            }

            // éšè—å¤ªé˜³ç³»æ˜Ÿç©ºèƒŒæ™¯
            if (solarStarfield) {
                solarStarfield.visible = false;
            }

            // æ˜¾ç¤ºåœ°çƒæ˜Ÿç©ºèƒŒæ™¯
            if (earthStarfield) {
                earthStarfield.visible = true;
            }

            // æ˜¾ç¤ºæœˆçƒ
            if (window.earthMoon) {
                window.earthMoon.visible = true;
            }

            // æ˜¾ç¤ºåœ°çƒæ§åˆ¶é¢æ¿
            document.getElementById('earth-controls').classList.add('visible');

                // è®¾ç½®åœ°çƒå±‚çº§æ§åˆ¶
                setupEarthControls();

                // éšè—å…¶ä»–æ§åˆ¶é¢æ¿
                document.getElementById('galaxy-controls').classList.remove('visible');
                document.getElementById('solar-controls').classList.remove('visible');
                
                // é‡ç½®æ§åˆ¶é¢æ¿çŠ¶æ€
                panelToggleCount = 0;
                isPanelVisible = true;
                showingCredits = false;
                document.getElementById('normalInfo').style.display = 'block';
				document.getElementById('normalInfo2').style.display = 'block';
                document.getElementById('creditsInfo').style.display = 'none';

            // å¹³æ»‘ç§»åŠ¨ç›¸æœº
            animateCamera(
                cameraPositions.earth.position,
                cameraPositions.earth.target,
                2000
            );

            document.getElementById('instructions').innerHTML = texts[currentLang].instructions.earth;
            
            // æ›´æ–°å¯¼èˆªæŒ‰é’®
            updateNavButtons();
        }
        
        // è¿”å›ä¸Šä¸€å±‚çº§
        window.goBack = function() {
            if (currentLevel === 'earth') {
                // è¿”å›å¤ªé˜³ç³»
                currentLevel = 'solar';
                earthSystem.visible = false;
                solarSystem.visible = true;
                
                // éšè—è‡ªå®šä¹‰æ ‡è®°ç»„
                if (customMarkersGroup) {
                    customMarkersGroup.visible = false;
                }

                // éšè—æ˜Ÿç©ºèƒŒæ™¯
                if (earthStarfield) {
                    earthStarfield.visible = false;
                }

                // éšè—æœˆçƒ
                if (window.earthMoon) {
                    window.earthMoon.visible = false;
                }

                // éšè—åœ°çƒæ§åˆ¶é¢æ¿
                document.getElementById('earth-controls').classList.remove('visible');
                
                // é‡ç½®æ§åˆ¶é¢æ¿çŠ¶æ€
                panelToggleCount = 0;
                isPanelVisible = true;
                showingCredits = false;
                document.getElementById('normalInfo').style.display = 'block';
				document.getElementById('normalInfo2').style.display = 'block';
                document.getElementById('creditsInfo').style.display = 'none';

                // æ˜¾ç¤ºå¤ªé˜³ç³»æ§åˆ¶é¢æ¿
                document.getElementById('solar-controls').classList.add('visible');
                
                // æ˜¾ç¤ºå¤ªé˜³ç³»æ˜Ÿç©ºèƒŒæ™¯
                if (solarStarfield) {
                    solarStarfield.visible = true;
                }
                
                animateCamera(
                    cameraPositions.solar.position,
                    cameraPositions.solar.target,
                    1500
                );

                document.getElementById('instructions').innerHTML = texts[currentLang].instructions.solar;
                
                // æ›´æ–°å¯¼èˆªæŒ‰é’®
                updateNavButtons();
            } else if (currentLevel === 'solar') {
                // è¿”å›é“¶æ²³ç³»
                currentLevel = 'galaxy';
                solarSystem.visible = false;
                galaxy.visible = true;
                
                // éšè—å¤ªé˜³ç³»æ˜Ÿç©ºèƒŒæ™¯
                if (solarStarfield) {
                    solarStarfield.visible = false;
                }

                // éšè—å¤ªé˜³ç³»æ§åˆ¶é¢æ¿
                document.getElementById('solar-controls').classList.remove('visible');

                // æ˜¾ç¤ºé“¶æ²³ç³»æ§åˆ¶é¢æ¿
                document.getElementById('galaxy-controls').classList.add('visible');
                
                // è®¾ç½®é“¶æ²³ç³»å±‚çº§æ§åˆ¶
                setupGalaxyControls();

                animateCamera(
                    cameraPositions.galaxy.position,
                    cameraPositions.galaxy.target,
                    2000
                );

                document.getElementById('back-button').style.display = 'none';
                document.getElementById('instructions').innerHTML = texts[currentLang].instructions.galaxy;
                
                // æ›´æ–°å¯¼èˆªæŒ‰é’®
                updateNavButtons();
            }
        };
        
        // è¿›å…¥å¤ªé˜³ç³»
        window.enterSolarSystem = function() {
            transitionToSolarSystem();
        };
        
        // è¿›å…¥åœ°çƒ
        window.enterEarth = function() {
            transitionToEarth();
        };
        
        // æ›´æ–°å¯¼èˆªæŒ‰é’®æ˜¾ç¤ºçŠ¶æ€
        function updateNavButtons() {
            const backBtn = document.getElementById('back-button');
            const enterSolarBtn = document.getElementById('enter-solar-button');
            const enterEarthBtn = document.getElementById('enter-earth-button');
            const togglePanelBtn = document.getElementById('toggle-panel-button');
            
            // æ ¹æ®å½“å‰å±‚çº§æ˜¾ç¤º/éšè—æŒ‰é’®
            if (currentLevel === 'galaxy') {
                // é“¶æ²³ç³»å±‚çº§ï¼šæ˜¾ç¤ºè¿›å…¥å¤ªé˜³ç³»æŒ‰é’®
                if (enterSolarBtn) enterSolarBtn.style.display = 'block';
                if (enterEarthBtn) enterEarthBtn.style.display = 'none';
                if (backBtn) backBtn.style.display = 'none';
                if (togglePanelBtn) togglePanelBtn.style.display = 'none';
            } else if (currentLevel === 'solar') {
                // å¤ªé˜³ç³»å±‚çº§ï¼šæ˜¾ç¤ºè¿”å›æŒ‰é’®å’Œè¿›å…¥åœ°çƒæŒ‰é’®
                if (backBtn) backBtn.style.display = 'block';
                if (enterEarthBtn) enterEarthBtn.style.display = 'block';
                if (enterSolarBtn) enterSolarBtn.style.display = 'none';
                if (togglePanelBtn) togglePanelBtn.style.display = 'none';
            } else if (currentLevel === 'earth') {
                // åœ°çƒå±‚çº§ï¼šæ˜¾ç¤ºè¿”å›æŒ‰é’®å’Œæ§åˆ¶é¢æ¿åˆ‡æ¢æŒ‰é’®
                if (backBtn) backBtn.style.display = 'block';
                if (enterSolarBtn) enterSolarBtn.style.display = 'none';
                if (enterEarthBtn) enterEarthBtn.style.display = 'none';
                if (togglePanelBtn) togglePanelBtn.style.display = 'block';
            }

            // æ›´æ–°æŒ‰é’®æ–‡æœ¬
            if (backBtn) backBtn.textContent = texts[currentLang].navButtons.back;
            if (enterSolarBtn) enterSolarBtn.textContent = texts[currentLang].navButtons.enterSolar;
            if (enterEarthBtn) enterEarthBtn.textContent = texts[currentLang].navButtons.enterEarth;
            if (togglePanelBtn) togglePanelBtn.textContent = texts[currentLang].navButtons.togglePanel;
        }
        
        // åˆ‡æ¢æ§åˆ¶é¢æ¿æ˜¾ç¤º/éšè—
        window.toggleControlPanel = function() {
            const panel = document.getElementById('earth-controls');
            const toggleBtn = document.getElementById('toggle-panel-button');
            const normalInfo = document.getElementById('normalInfo');
			const normalInfo2 = document.getElementById('normalInfo2');
            const creditsInfo = document.getElementById('creditsInfo');
            const musicPlayer = document.getElementById('music-player'); // è·å–éŸ³ä¹æ§åˆ¶é¢æ¿

            if (showingCredits) {
                // å¦‚æœæ­£åœ¨æ˜¾ç¤ºåˆ¶ä½œäººå‘˜ä¿¡æ¯ï¼Œç‚¹å‡»åæ¢å¤æ­£å¸¸æ˜¾ç¤º
                showingCredits = false;
                normalInfo.style.display = 'block';
				normalInfo2.style.display = 'block';
                creditsInfo.style.display = 'none';
                panelToggleCount = 0;
				panelToggleFlag = false;
                isPanelVisible = true;
                panel.classList.add('visible');
                // åŒæ—¶æ˜¾ç¤ºéŸ³ä¹æ§åˆ¶é¢æ¿
                if (musicPlayer) musicPlayer.style.display = 'block';
                toggleBtn.textContent = texts[currentLang].navButtons.togglePanel;
            } else {
			if (panelToggleFlag)
			{
                panelToggleCount++;
			}

                if (panelToggleCount === 5) {
                    // ç¬¬5æ¬¡ç‚¹å‡»ï¼šæ˜¾ç¤ºåˆ¶ä½œäººå‘˜ä¿¡æ¯
                    showingCredits = true;
                    normalInfo.style.display = 'none';
					normalInfo2.style.display = 'none';
                    creditsInfo.style.display = 'block';
                    panel.classList.add('visible');
                    isPanelVisible = true;
                    // åŒæ—¶æ˜¾ç¤ºéŸ³ä¹æ§åˆ¶é¢æ¿
                    if (musicPlayer) musicPlayer.style.display = 'block';
                    toggleBtn.textContent = texts[currentLang].navButtons.togglePanel;
                } else {
                    // æ™®é€šåˆ‡æ¢
                    isPanelVisible = !isPanelVisible;
                    if (isPanelVisible) {
                        panel.classList.add('visible');
                        // åŒæ—¶æ˜¾ç¤ºéŸ³ä¹æ§åˆ¶é¢æ¿
                        if (musicPlayer) musicPlayer.style.display = 'block';
                        toggleBtn.textContent = texts[currentLang].navButtons.togglePanel;
                    } else {
                        panel.classList.remove('visible');
                        // åŒæ—¶éšè—éŸ³ä¹æ§åˆ¶é¢æ¿
                        if (musicPlayer) musicPlayer.style.display = 'none';
                        toggleBtn.textContent = currentLang === 'zh' ? (texts[currentLang].navButtons.togglePanel === 'éšè—æ§åˆ¶é¢æ¿' ? 'æ˜¾ç¤ºæ§åˆ¶é¢æ¿' : 'Show Panel') : (texts[currentLang].navButtons.togglePanel === 'æ˜¾ç¤ºæ§åˆ¶é¢æ¿' ? 'Hide Panel' : 'Hide Panel');
                    }
                }
            }
        };
        
        // å¹³æ»‘ç§»åŠ¨ç›¸æœº
        function animateCamera(targetPosition, targetLookAt, duration) {
            const startPosition = camera.position.clone();
            const startLookAt = controls.target.clone();
            const startTime = Date.now();
            
            function updateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                camera.position.lerpVectors(startPosition, targetPosition, easeProgress);
                controls.target.lerpVectors(startLookAt, targetLookAt, easeProgress);
                controls.update();
                
                if (progress < 1) {
                    requestAnimationFrame(updateCamera);
                }
            }
            
            updateCamera();
        }
        
        // è®¾ç½®é“¶æ²³ç³»å±‚çº§æ§åˆ¶
        function setupGalaxyControls() {
            const galaxySpeedSlider = document.getElementById('galaxySpeed');
            
            // æ›´æ–°é“¶æ²³ç³»è½¬é€Ÿ
            galaxySpeedSlider.addEventListener('input', function() {
                galaxyRotationSpeed = parseFloat(this.value);
                document.getElementById('galaxySpeedValue').textContent = galaxyRotationSpeed.toFixed(1);
            });
        }
        
        // è®¾ç½®å¤ªé˜³ç³»å±‚çº§æ§åˆ¶
        function setupSolarControls() {
            const solarSpeedSlider = document.getElementById('solarSpeed');
            
            // æ›´æ–°å¤ªé˜³ç³»è½¬é€Ÿ
            solarSpeedSlider.addEventListener('input', function() {
                solarRotationSpeed = parseFloat(this.value);
                document.getElementById('solarSpeedValue').textContent = solarRotationSpeed.toFixed(1);
            });
        }
        
        // è®¾ç½®åœ°çƒå±‚çº§æ§åˆ¶
        function setupEarthControls() {
            // é˜²æ­¢é‡å¤åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
            if (earthControlsInitialized) {
                return;
            }
            earthControlsInitialized = true;
            
            const rotationSlider = document.getElementById('rotationSpeed');
            const cloudSlider = document.getElementById('cloudOpacity');
            const toggleButton = document.getElementById('toggleRotation');
            const resetButton = document.getElementById('resetView');
            
            // æ›´æ–°æ—‹è½¬é€Ÿåº¦
            rotationSlider.addEventListener('input', function() {
                rotationSpeed = parseFloat(this.value);
                document.getElementById('speedValue').textContent = rotationSpeed.toFixed(1);
            });
            
            // æ›´æ–°äº‘å±‚é€æ˜åº¦
            cloudSlider.addEventListener('input', function() {
                const opacity = parseFloat(this.value);
                document.getElementById('cloudValue').textContent = opacity.toFixed(1);
                if (clouds && clouds.material) {
                    clouds.material.opacity = opacity;
                }
            });
            
            // åˆ‡æ¢æ—‹è½¬
            toggleButton.addEventListener('click', function() {
                isRotating = !isRotating;
                this.textContent = isRotating ? texts[currentLang].toggleButtons.rotation[0] : texts[currentLang].toggleButtons.rotation[1];
            });
            
            // é‡ç½®è§†å›¾
            resetButton.addEventListener('click', function() {
                controls.reset();
                camera.position.set(0, 0, 10);
                controls.update();
            });
            
            // åŸå¸‚æ˜¾ç¤ºåˆ‡æ¢
            const toggleCitiesBtn = document.getElementById('toggleCities');
            toggleCitiesBtn.addEventListener('click', function() {
                showCities = !showCities;
                if (citiesGroup) {
                    citiesGroup.visible = showCities;
                }
                this.textContent = showCities ? texts[currentLang].toggleButtons.cities[0] : texts[currentLang].toggleButtons.cities[1];
                const citiesStatus = document.getElementById('citiesStatus');
                if (citiesStatus) {
                    citiesStatus.textContent = showCities ? texts[currentLang].statusText.cities[0] : texts[currentLang].statusText.cities[1];
                }
            });
            
            // å±±å³°æ˜¾ç¤ºåˆ‡æ¢
            const togglePeaksBtn = document.getElementById('togglePeaks');
            togglePeaksBtn.addEventListener('click', function() {
                showPeaks = !showPeaks;
                if (peaksGroup) {
                    peaksGroup.visible = showPeaks;
                }
                this.textContent = showPeaks ? texts[currentLang].toggleButtons.peaks[0] : texts[currentLang].toggleButtons.peaks[1];
                const peaksStatus = document.getElementById('peaksStatus');
                if (peaksStatus) {
                    peaksStatus.textContent = showPeaks ? texts[currentLang].statusText.peaks[0] : texts[currentLang].statusText.peaks[1];
                }
            });
            
            // æ¹–æ³Šæ˜¾ç¤ºåˆ‡æ¢
            const toggleLakesBtn = document.getElementById('toggleLakes');
            toggleLakesBtn.addEventListener('click', function() {
                showLakes = !showLakes;
                if (lakesGroup) {
                    lakesGroup.visible = showLakes;
                }
                this.textContent = showLakes ? texts[currentLang].toggleButtons.lakes[0] : texts[currentLang].toggleButtons.lakes[1];
                const lakesStatus = document.getElementById('lakesStatus');
                if (lakesStatus) {
                    lakesStatus.textContent = showLakes ? texts[currentLang].statusText.lakes[0] : texts[currentLang].statusText.lakes[1];
                }
            });
            
            // æ²³æµæ˜¾ç¤ºåˆ‡æ¢
            const toggleRiversBtn = document.getElementById('toggleRivers');
            toggleRiversBtn.addEventListener('click', function() {
                showRivers = !showRivers;
                if (riversGroup) {
                    riversGroup.visible = showRivers;
                }
                this.textContent = showRivers ? texts[currentLang].toggleButtons.rivers[0] : texts[currentLang].toggleButtons.rivers[1];
                const riversStatus = document.getElementById('riversStatus');
                if (riversStatus) {
                    riversStatus.textContent = showRivers ? texts[currentLang].statusText.rivers[0] : texts[currentLang].statusText.rivers[1];
                }
            });
            
            // èµ¤é“æ˜¾ç¤ºåˆ‡æ¢
            const toggleEquatorBtn = document.getElementById('toggleEquator');
            toggleEquatorBtn.addEventListener('click', function() {
                showEquator = !showEquator;
                if (equatorGroup) {
                    equatorGroup.visible = showEquator;
                }
                this.textContent = showEquator ? texts[currentLang].toggleButtons.equator[0] : texts[currentLang].toggleButtons.equator[1];
            });
            
            // å›å½’çº¿æ˜¾ç¤ºåˆ‡æ¢
            const toggleCanCapBtn = document.getElementById('toggleCanCap');
            toggleCanCapBtn.addEventListener('click', function() {
                showTropic = !showTropic;
                if (tropicGroup) {
                    tropicGroup.visible = showTropic;
                }
                this.textContent = showTropic ? texts[currentLang].toggleButtons.tropic[0] : texts[currentLang].toggleButtons.tropic[1];
            });

            // ç»çº¬çº¿æ˜¾ç¤ºåˆ‡æ¢
            const toggleLatLonBtn = document.getElementById('toggleLatLon');
            toggleLatLonBtn.addEventListener('click', function() {
                showTonLat = !showTonLat;
                if (latLonGroup) {
                    latLonGroup.visible = showTonLat;
                }
                this.textContent = showTonLat ? texts[currentLang].toggleButtons.latLon[0] : texts[currentLang].toggleButtons.latLon[1];
            });

            // æåœˆæ˜¾ç¤ºåˆ‡æ¢
            const toggleArcAntBtn = document.getElementById('toggleArcAnt');
            toggleArcAntBtn.addEventListener('click', function() {
                showArcAnt = !showArcAnt;
                if (arcAntGroup) {
                    arcAntGroup.visible = showArcAnt;
                }
                this.textContent = showArcAnt ? texts[currentLang].toggleButtons.arcAnt[0] : texts[currentLang].toggleButtons.arcAnt[1];
            });
        }
        
        // çª—å£å¤§å°è°ƒæ•´
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // å…¨å±€å˜é‡ç®¡ç†å¼¹çª—
        let currentTooltip = null;
        let tooltipTimer = null;
        let lastMouseMoveTime = 0;
        let activeCityTooltip = null;
        let activeCityKey = null;
        let activePeakTooltip = null;
        let activePeakKey = null;
        let activeLakeTooltip = null;
        let activeLakeKey = null;
        let activeRiverTooltip = null;
        let activeRiverKey = null;

        // è·å–å½“å‰æ´»åŠ¨çš„å¼¹çª—
        function getActiveTooltip(type, key) {
            if (type === 'city') return activeCityKey === key ? activeCityTooltip : null;
            if (type === 'peak') return activePeakKey === key ? activePeakTooltip : null;
            if (type === 'lake') return activeLakeKey === key ? activeLakeTooltip : null;
            if (type === 'river') return activeRiverKey === key ? activeRiverTooltip : null;
            return null;
        }

        // é‡ç½®å¼¹çª—è®¡æ—¶å™¨
        function resetTooltipTimer() {
            if (tooltipTimer) {
                clearTimeout(tooltipTimer);
                tooltipTimer = null;
            }
            lastMouseMoveTime = Date.now();
        }

        // è®¾ç½®å»¶è¿Ÿå…³é—­å¼¹çª—ï¼ˆé¼ æ ‡ç§»å¼€æ ‡è®°1ç§’åå…³é—­ï¼‰
        function scheduleTooltipHide() {
            if (tooltipTimer) {
                clearTimeout(tooltipTimer);
            }
            tooltipTimer = setTimeout(() => {
                const timeSinceLastMove = Date.now() - lastMouseMoveTime;
                if (timeSinceLastMove >= 1000) { // 1ç§’åå…³é—­
                    hideCurrentTooltip();
                }
            }, 1000);
        }

        // å–æ¶ˆå»¶è¿Ÿå…³é—­ï¼ˆå¦‚æœé¼ æ ‡ä»åœ¨æ ‡è¯†ä¸Šï¼‰
        function cancelTooltipHide() {
            if (tooltipTimer) {
                clearTimeout(tooltipTimer);
                tooltipTimer = null;
            }
        }

        // æ¢å¤æ‰€æœ‰å›¾æ ‡é¢œè‰²
        function restoreAllIconColors() {
            if (citiesGroup) {
                citiesGroup.children.forEach(child => {
                    if (child.userData && child.userData.cityKey && !child.userData.isHitTest) {
                        if (child.geometry && child.geometry.type === 'SphereGeometry') {
                            child.material.color.setHex(0xffffff);
                            child.scale.setScalar(1.0);
                        }
                    }
                });
            }
            if (peaksGroup) {
                peaksGroup.children.forEach(child => {
                    if (child.userData && child.userData.peakKey) {
                        if (child.geometry && child.geometry.type === 'SphereGeometry') {
                            const isPole = child.userData.peakKey === 'northpole' || child.userData.peakKey === 'southpole';
                            const restoreColor = isPole ? 0xff8800 : 0xff0000;
                            child.material.color.setHex(restoreColor);
                            child.scale.setScalar(1.0);
                        }
                    }
                });
            }
            if (lakesGroup) {
                lakesGroup.children.forEach(child => {
                    if (child.userData && child.userData.lakeKey) {
                        if (child.geometry && child.geometry.type === 'SphereGeometry') {
                            child.material.color.setHex(0x0000ff);
                            child.scale.setScalar(1.0);
                        }
                    }
                });
            }
            if (riversGroup) {
                riversGroup.children.forEach(child => {
                    if (child.userData && child.userData.riverKey) {
                        if (child.geometry && child.geometry.type === 'SphereGeometry') {
                            child.material.color.setHex(0x00ff00);
                            child.scale.setScalar(1.0);
                        }
                    }
                });
            }
        }

        // éšè—å½“å‰å¼¹çª—
        function hideCurrentTooltip() {
            restoreAllIconColors();
            if (currentTooltip && currentTooltip.parentNode) {
                document.body.removeChild(currentTooltip);
                currentTooltip = null;
            }
            if (activeCityTooltip) {
                activeCityTooltip = null;
            }
            if (activePeakTooltip) {
                activePeakTooltip = null;
            }
            if (activeLakeTooltip) {
                activeLakeTooltip = null;
            }
            if (activeRiverTooltip) {
                activeRiverTooltip = null;
            }
            if (tooltipTimer) {
                clearTimeout(tooltipTimer);
                tooltipTimer = null;
            }
            // å¼¹çª—å…³é—­åæ¢å¤åœ°çƒæ—‹è½¬
            isRotating = true;
            const toggleButton = document.getElementById('toggleRotation');
            if (toggleButton) {
                toggleButton.textContent = texts[currentLang].toggleButtons.rotation[0]; // æš‚åœæ—‹è½¬
            }
        }

        // åˆ›å»ºç§‘å¹»é£æ ¼ä»‹ç»å¼¹çª—
        function createSciFiTooltip(data, type) {
            const tooltip = document.createElement('div');
            tooltip.className = 'sci-fi-tooltip';
            tooltip.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 30, 60, 0.3);
                border: none;
                border-radius: 15px;
                padding: 25px;
                color: #ffffff;
                font-family: 'Arial', sans-serif;
                max-width: 400px;
                z-index: 1000;
                box-shadow: 0 0 40px rgba(0, 242, 254, 0.6);
                backdrop-filter: blur(15px);
                animation: fadeIn 0.3s ease-in-out;
            `;

            if (!document.getElementById('tooltip-animation-style')) {
                const style = document.createElement('style');
                style.id = 'tooltip-animation-style';
                style.textContent = `
                    @keyframes fadeIn {
                        from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    }
                `;
                document.head.appendChild(style);
            }

            const title = document.createElement('div');
            title.style.cssText = `
                font-size: 24px;
                font-weight: bold;
                color: #00f2fe;
                margin-bottom: 10px;
                text-align: center;
                text-shadow: 0 0 15px rgba(0, 242, 254, 0.9);
            `;
            title.textContent = currentLang === 'zh' ? data.name : (data.englishName || data.name);
            tooltip.appendChild(title);

            if (data.englishName && currentLang === 'zh') {
                const englishTitle = document.createElement('div');
                englishTitle.style.cssText = `
                    font-size: 16px;
                    color: #cccccc;
                    margin-bottom: 15px;
                    text-align: center;
                `;
                englishTitle.textContent = data.englishName;
                tooltip.appendChild(englishTitle);
            }

            const info = document.createElement('div');
            info.style.cssText = 'font-size: 14px; line-height: 1.6;';

            if (type === 'peak') {
                info.innerHTML = `
                    <div style="margin-bottom: 10px;">
                        <span style="color: #ffff00; font-weight: bold; text-shadow: 0 0 5px rgba(255, 255, 0, 0.8);">${currentLang === 'zh' ? "æµ·æ‹”é«˜åº¦ï¼š" : "Elevation:"}</span>
                        <span style="color: #ffffff; font-size: 18px; text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);">${data.elevation.toLocaleString()} ${currentLang === 'zh' ? "ç±³" : "m"}</span>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <span style="color: #ff6600; font-weight: bold; text-shadow: 0 0 5px rgba(255, 102, 0, 0.8);">${currentLang === 'zh' ? "åœ°ç†ä½ç½®ï¼š" : "Location:"}</span>
                        <span style="color: #ffffff;">${currentLang === 'zh' ? "ä¸œç»" : "E"} ${data.coordinates[0].toFixed(4)}Â°, ${currentLang === 'zh' ? "åŒ—çº¬" : "N"} ${data.coordinates[1].toFixed(4)}Â°</span>
                    </div>
                    <div style="color: #cccccc; font-style: italic; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; margin-top: 10px; box-shadow: 0 0 10px rgba(255,255,255,0.2);">
                        ${currentLang === 'zh' ? data.description : (data.englishDescription || data.description)}
                    </div>
                `;
            } else if (type === 'city') {
                info.innerHTML = `
                    <div style="margin-bottom: 10px;">
                        <span style="color: #00f2fe; font-weight: bold; text-shadow: 0 0 5px rgba(0, 242, 254, 0.8);">${currentLang === 'zh' ? "æ‰€å±å›½å®¶ï¼š" : "Country:"}</span>
                        <span style="color: #ffffff; font-size: 16px; text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);">${currentLang === 'zh' ? data.country : data.englishCountry}</span>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <span style="color: #ff00ff; font-weight: bold; text-shadow: 0 0 5px rgba(255, 0, 255, 0.8);">${currentLang === 'zh' ? "æ‰€å±å¤§æ´²ï¼š" : "Continent:"}</span>
                        <span style="color: #ffffff; font-size: 16px; text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);">${currentLang === 'zh' ? data.continent : data.englishContinent}</span>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <span style="color: #ffff00; font-weight: bold; text-shadow: 0 0 5px rgba(255, 255, 0, 0.8);">${currentLang === 'zh' ? "äººå£æ•°é‡ï¼š" : "Population:"}</span>
                        <span style="color: #ffffff; font-size: 18px; text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);">${(data.population / 1000000).toFixed(1)} ${currentLang === 'zh' ? "ç™¾ä¸‡" : "Million"}</span>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <span style="color: #ff6600; font-weight: bold; text-shadow: 0 0 5px rgba(255, 102, 0, 0.8);">${currentLang === 'zh' ? "åœ°ç†ä½ç½®ï¼š" : "Location:"}</span>
                        <span style="color: #ffffff;">${currentLang === 'zh' ? "ä¸œç»" : "E"} ${data.coordinates[0].toFixed(4)}Â°, ${currentLang === 'zh' ? "åŒ—çº¬" : "N"} ${data.coordinates[1].toFixed(4)}Â°</span>
                    </div>
                `;
            } else if (type === 'lake') {
                info.innerHTML = `
                    <div style="margin-bottom: 10px;">
                        <span style="color: #0000ff; font-weight: bold; text-shadow: 0 0 5px rgba(0, 0, 255, 0.8);">${currentLang === 'zh' ? "é¢ç§¯ï¼š" : "Area:"}</span>
                        <span style="color: #ffffff; font-size: 18px; text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);">${data.area.toLocaleString()} ${currentLang === 'zh' ? "å¹³æ–¹å…¬é‡Œ" : "kmÂ²"}</span>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <span style="color: #0088ff; font-weight: bold; text-shadow: 0 0 5px rgba(0, 136, 255, 0.8);">${currentLang === 'zh' ? "æœ€å¤§æ·±åº¦ï¼š" : "Max Depth:"}</span>
                        <span style="color: #ffffff; font-size: 18px; text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);">${data.maxDepth.toLocaleString()} ${currentLang === 'zh' ? "ç±³" : "m"}</span>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <span style="color: #ff6600; font-weight: bold; text-shadow: 0 0 5px rgba(255, 102, 0, 0.8);">${currentLang === 'zh' ? "åœ°ç†ä½ç½®ï¼š" : "Location:"}</span>
                        <span style="color: #ffffff;">${currentLang === 'zh' ? "ä¸œç»" : "E"} ${data.coordinates[0].toFixed(4)}Â°, ${currentLang === 'zh' ? "åŒ—çº¬" : "N"} ${data.coordinates[1].toFixed(4)}Â°</span>
                    </div>
                    <div style="color: #cccccc; font-style: italic; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; margin-top: 10px; box-shadow: 0 0 10px rgba(255,255,255,0.2);">
                        ${currentLang === 'zh' ? data.description : (data.englishDescription || data.description)}
                    </div>
                `;
            } else if (type === 'river') {
                info.innerHTML = `
                    <div style="margin-bottom: 10px;">
                        <span style="color: #00ff00; font-weight: bold; text-shadow: 0 0 5px rgba(0, 255, 0, 0.8);">${currentLang === 'zh' ? "é•¿åº¦ï¼š" : "Length:"}</span>
                        <span style="color: #ffffff; font-size: 18px; text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);">${data.length.toLocaleString()} ${currentLang === 'zh' ? "å…¬é‡Œ" : "km"}</span>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <span style="color: #ff6600; font-weight: bold; text-shadow: 0 0 5px rgba(255, 102, 0, 0.8);">${currentLang === 'zh' ? "åœ°ç†ä½ç½®ï¼š" : "Location:"}</span>
                        <span style="color: #ffffff;">${currentLang === 'zh' ? "ä¸œç»" : "E"} ${data.coordinates[0].toFixed(4)}Â°, ${currentLang === 'zh' ? "åŒ—çº¬" : "N"} ${data.coordinates[1].toFixed(4)}Â°</span>
                    </div>
                    <div style="color: #cccccc; font-style: italic; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; margin-top: 10px; box-shadow: 0 0 10px rgba(255,255,255,0.2);">
                        ${currentLang === 'zh' ? data.description : (data.englishDescription || data.description)}
                    </div>
                `;
            }

            tooltip.appendChild(info);

            const closeBtn = document.createElement('div');
            closeBtn.style.cssText = `
                position: absolute;
                top: 10px;
                right: 15px;
                color: #00f2fe;
                font-size: 20px;
                cursor: pointer;
                font-weight: bold;
                text-shadow: 0 0 5px rgba(0, 242, 254, 0.8);
            `;
            closeBtn.textContent = 'Ã—';
            closeBtn.onclick = () => {
                hideCurrentTooltip();
            };
            tooltip.appendChild(closeBtn);

            document.body.appendChild(tooltip);

            return tooltip;
        }

        // æ˜¾ç¤ºåŸå¸‚å¼¹çª—
        function showCityTooltip(cityData, cityKey, cityObject) {
            // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰åŸå¸‚å¼¹çª—æ˜¾ç¤º
            if (activeCityTooltip) {
                return;
            }
            hideCurrentTooltip();
            activeCityTooltip = createSciFiTooltip(cityData, 'city');
            activeCityKey = cityKey;
            currentTooltip = activeCityTooltip;
            activePeakTooltip = null;
            activeLakeTooltip = null;
            activeRiverTooltip = null;
            resetTooltipTimer();
        }

        // æ˜¾ç¤ºå±±å³°å¼¹çª—
        function showPeakTooltip(peakData, peakKey, peakObject) {
            // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰å±±å³°å¼¹çª—æ˜¾ç¤º
            if (activePeakTooltip) {
                return;
            }
            hideCurrentTooltip();
            activePeakTooltip = createSciFiTooltip(peakData, 'peak');
            activePeakKey = peakKey;
            currentTooltip = activePeakTooltip;
            activeCityTooltip = null;
            activeLakeTooltip = null;
            activeRiverTooltip = null;
            resetTooltipTimer();
        }

        // æ˜¾ç¤ºæ¹–æ³Šå¼¹çª—
        function showLakeTooltip(lakeData, lakeKey, lakeObject) {
            // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰æ¹–æ³Šå¼¹çª—æ˜¾ç¤º
            if (activeLakeTooltip) {
                return;
            }
            hideCurrentTooltip();
            activeLakeTooltip = createSciFiTooltip(lakeData, 'lake');
            activeLakeKey = lakeKey;
            currentTooltip = activeLakeTooltip;
            activeCityTooltip = null;
            activePeakTooltip = null;
            activeRiverTooltip = null;
            resetTooltipTimer();
        }

        // æ˜¾ç¤ºæ²³æµå¼¹çª—
        function showRiverTooltip(riverData, riverKey, riverObject) {
            // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰æ²³æµå¼¹çª—æ˜¾ç¤º
            if (activeRiverTooltip) {
                return;
            }
            hideCurrentTooltip();
            activeRiverTooltip = createSciFiTooltip(riverData, 'river');
            activeRiverKey = riverKey;
            currentTooltip = activeRiverTooltip;
            activeCityTooltip = null;
            activePeakTooltip = null;
            activeLakeTooltip = null;
            resetTooltipTimer();
        }

        // ===== åŠ¨ç”»å¾ªç¯ =====
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // æ—‹è½¬é“¶æ²³ç³»å’Œé»‘æ´ï¼ˆåº”ç”¨è½¬é€Ÿæ§åˆ¶ï¼‰
            if (galaxy && galaxy.visible) {
                // é“¶æ²³ç³»æ•´ä½“é€†æ—¶é’ˆæ—‹è½¬
                galaxy.rotation.y += 0.0005 * galaxyRotationSpeed;

                // é»‘æ´ä¸‰ç»´åŠ¨ç”»ç³»ç»Ÿ
                const blackHoleGroup = galaxy.children.find(child =>
                    child.type === 'Group' &&
                    child.children.length > 0 &&
                    child.children[0].material &&
                    child.children[0].material.color.getHex() === 0x000000
                );
                if (blackHoleGroup) {
                    let childIndex = 0;
                    
                    // 0. äº‹ä»¶è§†ç•Œï¼ˆé™æ­¢ï¼‰
                    childIndex++;
                    
                    // 1. å…‰å­çƒå±‚ - æå¿«æ—‹è½¬ + è„‰åŠ¨
                    if (blackHoleGroup.children[childIndex]) {
                        blackHoleGroup.children[childIndex].rotation.z += 0.04 * galaxyRotationSpeed;
                        const pulse = Math.sin(time * 2) * 0.1 + 1;
                        blackHoleGroup.children[childIndex].scale.set(pulse, pulse, 1);
                    }
                    childIndex++;
                    
                    // 2-4. ä¸‰ç»´æ‰­æ›²å¸ç§¯ç›˜ï¼ˆå†…ã€ä¸»ã€å¤–ï¼‰
                    for (let i = 0; i < 3; i++) {
                        if (blackHoleGroup.children[childIndex]) {
                            const disk = blackHoleGroup.children[childIndex];
                            // å·®å¼‚åŒ–æ—‹è½¬é€Ÿåº¦
                            const rotSpeed = (0.03 - i * 0.008) * galaxyRotationSpeed;
                            disk.rotation.y += rotSpeed;
                            
                            // æ·»åŠ è½»å¾®çš„æ³¢åŠ¨æ•ˆæœ
                            const wobble = Math.sin(time * 1.5 + i) * 0.02;
                            disk.rotation.z = wobble;
                            
                            // åŠ¨æ€æ‰­æ›²æ•ˆæœ
                            if (disk.geometry && disk.geometry.attributes.position) {
                                const positions = disk.geometry.attributes.position.array;
                                for (let j = 0; j < positions.length; j += 3) {
                                    const x = positions[j];
                                    const z = positions[j + 2];
                                    const angle = Math.atan2(z, x);
                                    const radius = Math.sqrt(x * x + z * z);
                                    const heightOffset = Math.sin(angle * 2 + time * 0.5) * radius * 0.08;
                                    positions[j + 1] = heightOffset;
                                }
                                disk.geometry.attributes.position.needsUpdate = true;
                            }
                        }
                        childIndex++;
                    }
                    
                    // 5. å¸ç§¯ç²’å­æµ - èºæ—‹è¿åŠ¨
                    if (blackHoleGroup.children[childIndex] && blackHoleGroup.children[childIndex].type === 'Points') {
                        const particles = blackHoleGroup.children[childIndex];
                        const positions = particles.geometry.attributes.position.array;
                        const angles = particles.geometry.userData.angles;
                        const radii = particles.geometry.userData.radii;
                        const heights = particles.geometry.userData.heights;
                        
                        for (let i = 0; i < positions.length / 3; i++) {
                            // èºæ—‹å‘å†…è¿åŠ¨
                            angles[i] += (0.02 + (1 / radii[i]) * 0.5) * galaxyRotationSpeed;
                            // è§’åº¦å½’ä¸€åŒ–ï¼Œé˜²æ­¢æµ®ç‚¹æ•°ç²¾åº¦è¯¯å·®
                            angles[i] = ((angles[i] % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
                            radii[i] -= 0.015 * galaxyRotationSpeed; // é€æ¸æ¥è¿‘é»‘æ´
                            
                            // é‡ç½®åˆ°å¤–å›´
                            if (radii[i] < 7) {
                                radii[i] = 7 + Math.random() * 25;
                                heights[i] = (Math.random() - 0.5) * radii[i] * 0.3;
                            }
                            
                            positions[i * 3] = Math.cos(angles[i]) * radii[i];
                            positions[i * 3 + 1] = heights[i] * (1 - (32 - radii[i]) / 25);
                            positions[i * 3 + 2] = Math.sin(angles[i]) * radii[i];
                        }
                        particles.geometry.attributes.position.needsUpdate = true;
                    }
                    childIndex++;
                    
                    // 6-15. å¼•åŠ›é€é•œå¤šå±‚å…‰ç¯ (10ä¸ªç¯ï¼Œä¸Šä¸‹å„5ä¸ª)
                    for (let i = 0; i < 10; i++) {
                        if (blackHoleGroup.children[childIndex]) {
                            const ring = blackHoleGroup.children[childIndex];
                            ring.rotation.y += (0.01 + i * 0.002) * galaxyRotationSpeed;
                            // æ³¢æµªå¼ä¸Šä¸‹æ‘†åŠ¨
                            const offset = i < 5 ? i : (i - 5);
                            ring.rotation.z = Math.sin(time * 0.8 + offset * 0.3) * 0.15;
                            // è„‰åŠ¨é€æ˜åº¦
                            if (ring.material) {
                                const baseopacity = 0.4 - offset * 0.06;
                                ring.material.opacity = baseopacity * (0.7 + Math.sin(time * 2 + i) * 0.3);
                            }
                        }
                        childIndex++;
                    }
                    
                    // 16-17. å–·æµç²’å­ç³»ç»Ÿï¼ˆä¸Šä¸‹ä¸¤ä¸ªï¼‰- æ›´æ–°ä¸ºæ›´é•¿çš„å–·æµ
                    for (let j = 0; j < 2; j++) {
                        if (blackHoleGroup.children[childIndex] && blackHoleGroup.children[childIndex].type === 'Points') {
                            const jet = blackHoleGroup.children[childIndex];
                            const positions = jet.geometry.attributes.position.array;
                            const speeds = jet.geometry.userData.speeds;
                            const direction = jet.geometry.userData.direction;
                            
                            for (let i = 0; i < positions.length / 3; i++) {
                                // ç²’å­å‘å¤–å–·å°„
                                positions[i * 3 + 1] += speeds[i] * 0.3 * galaxyRotationSpeed * direction;
                                
                                const currentHeight = Math.abs(positions[i * 3 + 1]);
                                
                                // é‡ç½®ç²’å­ï¼ˆé€‚é…æ–°çš„é•¿åº¦80ï¼‰
                                if (currentHeight > 80) {
                                    positions[i * 3 + 1] = 0;
                                    const angle = Math.random() * Math.PI * 2;
                                    const radius = Math.random() * 0.3;
                                    positions[i * 3] = Math.cos(angle) * radius;
                                    positions[i * 3 + 2] = Math.sin(angle) * radius;
                                }
                                
                                // æ·»åŠ èºæ—‹æ•ˆæœå’Œå¾„å‘æ‰©æ•£
                                const angle = Math.atan2(positions[i * 3 + 2], positions[i * 3]);
                                let radius = Math.sqrt(positions[i * 3] * positions[i * 3] + positions[i * 3 + 2] * positions[i * 3 + 2]);
                                
                                // éšé«˜åº¦å¢åŠ è€Œæ‰©æ•£
                                const expansionRate = 0.015;
                                radius += expansionRate * galaxyRotationSpeed;
                                
                                const newAngle = angle + 0.015 * galaxyRotationSpeed;
                                positions[i * 3] = Math.cos(newAngle) * radius;
                                positions[i * 3 + 2] = Math.sin(newAngle) * radius;
                            }
                            jet.geometry.attributes.position.needsUpdate = true;
                            
                            // å–·æµæ•´ä½“è„‰å†²æ•ˆæœ
                            const jetPulse = Math.sin(time * 3 + j * Math.PI) * 0.3 + 0.7;
                            jet.material.opacity = 0.75 * jetPulse;
                        }
                        childIndex++;
                    }
                    
                    // 17.5-18.5 å–·æµæ ¸å¿ƒå…‰æŸ±ï¼ˆä¸Šä¸‹ä¸¤ä¸ªï¼‰
                    for (let j = 0; j < 2; j++) {
                        if (blackHoleGroup.children[childIndex] && blackHoleGroup.children[childIndex].type === 'Mesh') {
                            const core = blackHoleGroup.children[childIndex];
                            // è½»å¾®æ—‹è½¬
                            core.rotation.y += 0.02 * galaxyRotationSpeed;
                            // è„‰åŠ¨æ•ˆæœ
                            const corePulse = Math.sin(time * 2.5 + j * Math.PI) * 0.2 + 0.8;
                            core.material.opacity = 0.5 * corePulse;
                            core.scale.set(corePulse, 1, corePulse);
                        }
                        childIndex++;
                    }
                    
                    // 19-26. ä½“ç§¯é›¾å±‚ - ç¼“æ…¢æ—‹è½¬å’Œè„‰åŠ¨
                    for (let i = 0; i < 8; i++) {
                        if (blackHoleGroup.children[childIndex]) {
                            const fog = blackHoleGroup.children[childIndex];
                            fog.rotation.y += (0.001 + i * 0.0002) * galaxyRotationSpeed;
                            fog.rotation.z += (0.0008 - i * 0.0001) * galaxyRotationSpeed;
                            // è„‰åŠ¨æ•ˆæœ
                            const pulse = 1 + Math.sin(time * 0.5 + i * 0.5) * 0.1;
                            fog.scale.set(pulse, pulse, pulse);
                        }
                        childIndex++;
                    }
                    
                    // 27. å¤–éƒ¨å…‰æ™• - æ…¢é€Ÿæ—‹è½¬
                    if (blackHoleGroup.children[childIndex]) {
                        blackHoleGroup.children[childIndex].rotation.z += 0.005 * galaxyRotationSpeed;
                        // é€æ˜åº¦è„‰åŠ¨
                        if (blackHoleGroup.children[childIndex].material) {
                            const haloOpacity = 0.15 * (1 + Math.sin(time * 0.8) * 0.3);
                            blackHoleGroup.children[childIndex].material.opacity = haloOpacity;
                        }
                    }
                }

                // å¼€æ™®å‹’æ—‹è½¬ï¼šåŸºäºè·ç¦»çš„æ’æ˜Ÿå·®å¼‚åŒ–è½¬é€Ÿ
                galaxy.children.forEach(child => {
                    if (child.type === 'Points' && child.geometry.userData && child.geometry.userData.distances) {
                        const positions = child.geometry.attributes.position.array;
                        const distances = child.geometry.userData.distances;
                        const angles = child.geometry.userData.angles;
                        const offsets = child.geometry.userData.offsets;

                        for (let i = 0; i < positions.length / 3; i++) {
                            const radius = distances[i];
                            // é“¶æ²³ç³»æ—‹è½¬æ›²çº¿ï¼ˆè¿‘ä¼¼å¹³å¦ï¼‰ï¼šè§’é€Ÿåº¦ Ï‰ âˆ 1/r
                            const angularSpeed = 0.002 / (radius / 10) * galaxyRotationSpeed;

                            // æ›´æ–°è§’åº¦ï¼ˆé€†æ—¶é’ˆæ—‹è½¬ï¼Œä»ä¸Šæ–¹ä¿¯è§†ï¼‰
                            angles[i] += angularSpeed;
                            // è§’åº¦å½’ä¸€åŒ–ï¼Œé˜²æ­¢æµ®ç‚¹æ•°ç²¾åº¦è¯¯å·®å¯¼è‡´æ–¹å‘å¼‚å¸¸
                            // ä¿è¯è§’åº¦åœ¨ [0, 2Ï€) èŒƒå›´å†…ï¼Œæ­£ç¡®å¤„ç†è´Ÿè§’åº¦
                            angles[i] = ((angles[i] % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);

                            // è®¡ç®—æ–°ä½ç½®ï¼ˆä¿æŒèºæ—‹ç»“æ„å’Œç›¸å¯¹åç§»ï¼‰
                            const x = Math.cos(angles[i]) * radius + offsets[i * 2];
                            const z = Math.sin(angles[i]) * radius + offsets[i * 2 + 1];

                            positions[i * 3] = x;
                            positions[i * 3 + 2] = z;
                        }

                        child.geometry.attributes.position.needsUpdate = true;

                        // æ˜Ÿæ˜Ÿé—ªçƒæ•ˆæœ
                        child.material.opacity = 0.6 + Math.sin(time * 2) * 0.2;
                    }
                });
            }
            
            // æ—‹è½¬å¤ªé˜³ç³»ï¼ˆæŒ‰å®é™…æ¯”ä¾‹è®¾ç½®è½¬é€Ÿï¼‰
            if (solarSystem && solarSystem.visible) {
                // ===== å¤ªé˜³åŠ¨ç”»ç³»ç»Ÿ =====
                const sunGroup = solarSystem.children[0]; // å¤ªé˜³ç»„æ˜¯ç¬¬ä¸€ä¸ªå­å¯¹è±¡
                if (sunGroup && sunGroup.type === 'Group') {
                    let sunChildIndex = 0;
                    
                    // 0. å¤ªé˜³æ ¸å¿ƒè‡ªè½¬
                    if (sunGroup.children[sunChildIndex]) {
                        sunGroup.children[sunChildIndex].rotation.y += 0.005 * solarRotationSpeed;
                    }
                    sunChildIndex++;
                    
                    // 1. è¡¨é¢çº¹ç†å±‚è‡ªè½¬ï¼ˆé€Ÿåº¦ç¨æ…¢ï¼‰
                    if (sunGroup.children[sunChildIndex]) {
                        sunGroup.children[sunChildIndex].rotation.y += 0.004 * solarRotationSpeed;
                    }
                    sunChildIndex++;
                    
                    // 2-8. æ—¥å†•å±‚è„‰åŠ¨å’Œæ—‹è½¬
                    for (let i = 0; i < 7; i++) {
                        if (sunGroup.children[sunChildIndex]) {
                            const corona = sunGroup.children[sunChildIndex];
                            // å·®å¼‚åŒ–æ—‹è½¬
                            corona.rotation.y += (0.003 + i * 0.0002) * solarRotationSpeed;
                            corona.rotation.z += (0.001 - i * 0.0001) * solarRotationSpeed;
                            
                            // è„‰åŠ¨æ•ˆæœ
                            const layerIndex = corona.userData.layerIndex || i;
                            const pulse = 1 + Math.sin(time * 1.5 + layerIndex * 0.5) * 0.08;
                            corona.scale.setScalar(pulse);
                            
                            // é€æ˜åº¦é—ªçƒ
                            const baseOpacity = [0.4, 0.35, 0.3, 0.25, 0.18, 0.12, 0.08][layerIndex];
                            corona.material.opacity = baseOpacity * (0.8 + Math.sin(time * 2 + layerIndex) * 0.2);
                        }
                        sunChildIndex++;
                    }
                    
                    // 9. å¤ªé˜³é»‘å­éšè¡¨é¢æ—‹è½¬
                    if (sunGroup.children[sunChildIndex] && sunGroup.children[sunChildIndex].type === 'Points') {
                        sunGroup.children[sunChildIndex].rotation.y += 0.005 * solarRotationSpeed;
                    }
                    sunChildIndex++;
                    
                    // 10. å¤ªé˜³è€€æ–‘åŠ¨ç”»ï¼ˆè·³åŠ¨é—ªçƒï¼‰
                    if (sunGroup.children[sunChildIndex] && sunGroup.children[sunChildIndex].type === 'Points') {
                        const flares = sunGroup.children[sunChildIndex];
                        flares.rotation.y += 0.006 * solarRotationSpeed;
                        
                        // éšæœºé—ªçƒæ•ˆæœ
                        const positions = flares.geometry.attributes.position.array;
                        const colors = flares.geometry.attributes.color.array;
                        const angles = flares.geometry.userData.angles;
                        
                        for (let i = 0; i < positions.length / 3; i++) {
                            // åŠ¨æ€åŠå¾„å˜åŒ–
                            const theta = angles[i * 2];
                            const phi = angles[i * 2 + 1];
                            const radiusVariation = Math.sin(time * 5 + i * 0.1) * 0.15;
                            const radius = 3.08 + 0.3 * Math.random() + radiusVariation;
                            
                            positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                            positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                            positions[i * 3 + 2] = radius * Math.cos(phi);
                            
                            // é¢œè‰²é—ªçƒ
                            const brightness = 0.8 + Math.sin(time * 8 + i * 0.2) * 0.4;
                            const c = new THREE.Color(0xffff88);
                            c.multiplyScalar(brightness);
                            colors[i * 3] = c.r;
                            colors[i * 3 + 1] = c.g;
                            colors[i * 3 + 2] = c.b;
                        }
                        
                        flares.geometry.attributes.position.needsUpdate = true;
                        flares.geometry.attributes.color.needsUpdate = true;
                    }
                    sunChildIndex++;
                    
                    // 11-15. æ—¥ç¥åŠ¨ç”»ï¼ˆ5ä¸ªï¼‰
                    for (let i = 0; i < 5; i++) {
                        if (sunGroup.children[sunChildIndex] && sunGroup.children[sunChildIndex].type === 'Points') {
                            const prominence = sunGroup.children[sunChildIndex];
                            const positions = prominence.geometry.attributes.position.array;
                            const baseAngle = prominence.geometry.userData.angle;
                            const speeds = prominence.geometry.userData.speeds;
                            
                            // æ—¥ç¥ç¼“æ…¢è¿åŠ¨å’Œæ³¢åŠ¨
                            for (let j = 0; j < positions.length / 3; j++) {
                                const t = j / (positions.length / 3);
                                const arcHeight = Math.sin(t * Math.PI) * (1.5 + Math.random() * 1.0);
                                const radius = 3 + arcHeight + Math.sin(time * 2 + j * 0.1) * 0.2;
                                
                                const theta = baseAngle + (Math.random() - 0.5) * 0.3 + speeds[j] * time;
                                const phi = Math.PI / 2 + (t - 0.5) * 0.8;
                                
                                positions[j * 3] = radius * Math.sin(phi) * Math.cos(theta);
                                positions[j * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                                positions[j * 3 + 2] = radius * Math.cos(phi);
                            }
                            
                            prominence.geometry.attributes.position.needsUpdate = true;
                            
                            // é€æ˜åº¦è„‰åŠ¨
                            prominence.material.opacity = 0.8 * (0.7 + Math.sin(time * 1.5 + i) * 0.3);
                        }
                        sunChildIndex++;
                    }
                    
                    // 16. å¤ªé˜³é£ç²’å­æµï¼ˆå‘å¤–è¾å°„ï¼‰
                    if (sunGroup.children[sunChildIndex] && sunGroup.children[sunChildIndex].type === 'Points') {
                        const solarWind = sunGroup.children[sunChildIndex];
                        const positions = solarWind.geometry.attributes.position.array;
                        const speeds = solarWind.geometry.userData.speeds;
                        
                        for (let i = 0; i < positions.length / 3; i++) {
                            const x = positions[i * 3];
                            const y = positions[i * 3 + 1];
                            const z = positions[i * 3 + 2];
                            
                            let radius = Math.sqrt(x * x + y * y + z * z);
                            const theta = Math.atan2(y, x);
                            const phi = Math.acos(z / radius);
                            
                            // å‘å¤–æ‰©æ•£
                            radius += speeds[i] * solarRotationSpeed;
                            
                            // é‡ç½®ç²’å­
                            if (radius > 11.5) {
                                radius = 3.5 + Math.random() * 0.5;
                            }
                            
                            positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                            positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                            positions[i * 3 + 2] = radius * Math.cos(phi);
                        }
                        
                        solarWind.geometry.attributes.position.needsUpdate = true;
                    }
                }
                
                // è¡Œæ˜Ÿå…¬è½¬ï¼ˆæŒ‰å¼€æ™®å‹’ç¬¬ä¸‰å®šå¾‹ï¼Œå‘¨æœŸ^2 âˆ è·ç¦»^3ï¼‰
                // åŸºå‡†ï¼šåœ°çƒå…¬è½¬å‘¨æœŸ = 1å¹´ = 0.02å¼§åº¦/å¸§
                planets.forEach(planet => {
                    const distance = planet.userData.distance;
                    // å…¬è½¬é€Ÿåº¦ = åŸºå‡†é€Ÿåº¦ / è·ç¦»^(3/2)ï¼ˆå¼€æ™®å‹’å®šå¾‹ï¼‰
                    const orbitalSpeed = 0.02 / Math.pow(distance / 16, 1.5);
                    planet.userData.angle += orbitalSpeed * solarRotationSpeed;
                    // è§’åº¦å½’ä¸€åŒ–ï¼Œé˜²æ­¢æµ®ç‚¹æ•°ç²¾åº¦è¯¯å·®
                    planet.userData.angle = ((planet.userData.angle % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
                    planet.position.x = Math.cos(planet.userData.angle) * distance;
                    planet.position.z = Math.sin(planet.userData.angle) * distance;
                    
                    // è¡Œæ˜Ÿè‡ªè½¬ï¼ˆè®¾ä¸ºä¸åŒé€Ÿåº¦ï¼‰
                    const rotationSpeeds = {
                        'æ°´æ˜Ÿ': 0.02,  // æ°´æ˜Ÿè‡ªè½¬å¾ˆæ…¢
                        'é‡‘æ˜Ÿ': 0.005, // é‡‘æ˜Ÿè‡ªè½¬ææ…¢ä¸”åå‘
                        'åœ°çƒ': 0.05,  // åœ°çƒ24å°æ—¶
                        'ç«æ˜Ÿ': 0.048, // ç«æ˜Ÿ24.6å°æ—¶
                        'æœ¨æ˜Ÿ': 0.12,  // æœ¨æ˜Ÿè‡ªè½¬æœ€å¿«
                        'åœŸæ˜Ÿ': 0.11,  // åœŸæ˜Ÿæ¬¡ä¹‹
                        'å¤©ç‹æ˜Ÿ': 0.08, // å¤©ç‹æ˜Ÿ
                        'æµ·ç‹æ˜Ÿ': 0.08  // æµ·ç‹æ˜Ÿ
                    };
                    const rotationSpeed = rotationSpeeds[planet.userData.name] || 0.05;
                    planet.rotation.y += rotationSpeed * solarRotationSpeed;
                    
                    // åœŸæ˜Ÿå…‰ç¯æ—‹è½¬
                    if (planet.userData.name === 'åœŸæ˜Ÿ' || planet.userData.englishName === 'Saturn') {
                        if (planet.children.length > 0) {
                            planet.children[0].rotation.z += 0.005 * solarRotationSpeed;
                        }
                    }
                    
                    // æ°”æ€å·¨è¡Œæ˜Ÿå¤§æ°”å±‚æ•ˆæœï¼ˆè½»å¾®è„‰åŠ¨ï¼‰
                    if (planet.userData.name === 'æœ¨æ˜Ÿ' || planet.userData.name === 'åœŸæ˜Ÿ' || 
                        planet.userData.name === 'å¤©ç‹æ˜Ÿ' || planet.userData.name === 'æµ·ç‹æ˜Ÿ' ||
                        planet.userData.englishName === 'Jupiter' || planet.userData.englishName === 'Saturn' || 
                        planet.userData.englishName === 'Uranus' || planet.userData.englishName === 'Neptune') {
                        const pulse = 1 + Math.sin(time * 0.5 + planet.userData.angle) * 0.02;
                        planet.scale.setScalar(pulse);
                    }
                });
                
                // æœˆçƒå›´ç»•åœ°çƒï¼ˆçº¦27.3å¤©ä¸€åœˆï¼Œç›¸å¯¹åœ°çƒè®¾ä¸º0.4ï¼‰
                if (moon && planets[2]) { // åœ°çƒæ˜¯ç¬¬3ä¸ªè¡Œæ˜Ÿ
                    moon.userData.angle += 0.04 * solarRotationSpeed; // æœˆçƒå…¬è½¬
                    // è§’åº¦å½’ä¸€åŒ–ï¼Œé˜²æ­¢æµ®ç‚¹æ•°ç²¾åº¦è¯¯å·®
                    moon.userData.angle = ((moon.userData.angle % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
                    const earthX = planets[2].position.x;
                    const earthZ = planets[2].position.z;
                    moon.position.x = earthX + Math.cos(moon.userData.angle) * moon.userData.distance;
                    moon.position.z = earthZ + Math.sin(moon.userData.angle) * moon.userData.distance;
                    
                    // æœˆçƒè‡ªè½¬ï¼ˆæ½®æ±é”å®šï¼Œä¸å…¬è½¬åŒæ­¥ï¼‰
                    moon.rotation.y += 0.04 * solarRotationSpeed;
                }
                
                // å°è¡Œæ˜Ÿå¸¦åŠ¨ç”»ç³»ç»Ÿ
                asteroidBelt.forEach(asteroid => {
                    if (asteroid.type === 'Points') {
                        // ç²’å­ç³»ç»Ÿï¼ˆå°˜åŸƒäº‘å’Œç¢ç‰‡ï¼‰
                        const positions = asteroid.geometry.attributes.position.array;
                        const angles = asteroid.geometry.userData.angles;
                        const radii = asteroid.geometry.userData.radii;
                        
                        if (angles && radii) {
                            for (let i = 0; i < positions.length / 3; i++) {
                                // å…¬è½¬
                                const speed = asteroid.userData.type === 'asteroidDust' ? 0.003 : 0.005;
                                angles[i] += speed * solarRotationSpeed;
                                // è§’åº¦å½’ä¸€åŒ–ï¼Œé˜²æ­¢æµ®ç‚¹æ•°ç²¾åº¦è¯¯å·®
                                angles[i] = ((angles[i] % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
                                
                                positions[i * 3] = Math.cos(angles[i]) * radii[i];
                                positions[i * 3 + 2] = Math.sin(angles[i]) * radii[i];
                            }
                            asteroid.geometry.attributes.position.needsUpdate = true;
                        }
                        
                        // å°˜åŸƒäº‘æ•´ä½“ç¼“æ…¢æ—‹è½¬
                        if (asteroid.userData.type === 'asteroidDust') {
                            asteroid.rotation.y += 0.0001 * solarRotationSpeed;
                        }
                    } else if (asteroid.userData && asteroid.userData.type === 'asteroid') {
                        // å¤§å‹å’Œä¸­å‹å°è¡Œæ˜Ÿ
                        asteroid.userData.angle += asteroid.userData.speed * solarRotationSpeed;
                        // è§’åº¦å½’ä¸€åŒ–ï¼Œé˜²æ­¢æµ®ç‚¹æ•°ç²¾åº¦è¯¯å·®
                        asteroid.userData.angle = ((asteroid.userData.angle % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
                        asteroid.position.x = Math.cos(asteroid.userData.angle) * asteroid.userData.distance;
                        asteroid.position.z = Math.sin(asteroid.userData.angle) * asteroid.userData.distance;
                        
                        // ä¸è§„åˆ™è‡ªè½¬
                        if (asteroid.userData.rotationSpeedX) {
                            asteroid.rotation.x += asteroid.userData.rotationSpeedX * solarRotationSpeed;
                            asteroid.rotation.y += asteroid.userData.rotationSpeedY * solarRotationSpeed;
                            if (asteroid.userData.rotationSpeedZ) {
                                asteroid.rotation.z += asteroid.userData.rotationSpeedZ * solarRotationSpeed;
                            }
                        } else {
                            // ç®€å•æ—‹è½¬ï¼ˆä¸­å‹å°è¡Œæ˜Ÿï¼‰
                            asteroid.rotation.x += 0.01 * solarRotationSpeed;
                            asteroid.rotation.y += 0.015 * solarRotationSpeed;
                        }
                    }
                });
                
                // æŸ¯ä¼Šä¼¯å¸¦åŠ¨ç”»ç³»ç»Ÿ
                kuiperBelt.forEach(kbo => {
                    if (kbo.type === 'Points') {
                        // å†°ç²’ç²’å­ç³»ç»Ÿ
                        const positions = kbo.geometry.attributes.position.array;
                        const angles = kbo.geometry.userData.angles;
                        const radii = kbo.geometry.userData.radii;
                        
                        if (angles && radii) {
                            for (let i = 0; i < positions.length / 3; i++) {
                                // å…¬è½¬ï¼ˆéå¸¸ç¼“æ…¢ï¼‰
                                const speed = 0.001 + Math.random() * 0.001;
                                angles[i] += speed * solarRotationSpeed;
                                // è§’åº¦å½’ä¸€åŒ–ï¼Œé˜²æ­¢æµ®ç‚¹æ•°ç²¾åº¦è¯¯å·®
                                angles[i] = ((angles[i] % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
                                
                                positions[i * 3] = Math.cos(angles[i]) * radii[i];
                                positions[i * 3 + 2] = Math.sin(angles[i]) * radii[i];
                            }
                            kbo.geometry.attributes.position.needsUpdate = true;
                        }
                    } else if (kbo.userData && kbo.userData.type === 'kuiperBeltObject') {
                        // å¤§å‹æŸ¯ä¼Šä¼¯å¸¦å¤©ä½“
                        kbo.userData.angle += kbo.userData.speed * solarRotationSpeed;
                        // è§’åº¦å½’ä¸€åŒ–ï¼Œé˜²æ­¢æµ®ç‚¹æ•°ç²¾åº¦è¯¯å·®
                        kbo.userData.angle = ((kbo.userData.angle % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
                        kbo.position.x = Math.cos(kbo.userData.angle) * kbo.userData.distance;
                        kbo.position.z = Math.sin(kbo.userData.angle) * kbo.userData.distance;
                        
                        // è‡ªè½¬
                        if (kbo.userData.rotationSpeedX) {
                            kbo.rotation.x += kbo.userData.rotationSpeedX * solarRotationSpeed;
                            kbo.rotation.y += kbo.userData.rotationSpeedY * solarRotationSpeed;
                        }
                    }
                });
                
                // å¥¥å°”ç‰¹äº‘åŠ¨ç”»å’Œå¯è§æ€§æ§åˆ¶
                oortCloud.forEach(oortObj => {
                    if (oortObj.userData && oortObj.userData.type === 'oortCloud') {
                        // æ ¹æ®ç›¸æœºç¼©æ”¾è°ƒæ•´å¯è§æ€§å’Œé€æ˜åº¦
                        // camera.position.length() è¡¨ç¤ºç›¸æœºè·ç¦»åŸç‚¹çš„è·ç¦»
                        const cameraDistance = camera.position.length();
                        const baseDistance = oortObj.userData.baseDistance;
                        
                        // å½“ç›¸æœºè·ç¦»è¶…è¿‡åŸºç¡€è·ç¦»çš„ visibleThreshold å€æ—¶æ˜¾ç¤º
                        const shouldBeVisible = cameraDistance > baseDistance * oortObj.userData.visibleThreshold;
                        
                        if (shouldBeVisible) {
                            // è®¡ç®—é€æ˜åº¦ï¼šç›¸æœºè¶Šè¿œï¼Œå¥¥å°”ç‰¹äº‘è¶Šæ˜æ˜¾
                            const opacityFactor = Math.min(1, (cameraDistance - baseDistance * oortObj.userData.visibleThreshold) / (baseDistance * 0.5));
                            oortObj.material.opacity = oortObj.userData.baseOpacity * opacityFactor;
                            oortObj.material.size = oortObj.userData.baseSize * opacityFactor;
                            
                            if (!oortObj.visible) {
                                oortObj.visible = true;
                            }
                            
                            // å¥¥å°”ç‰¹äº‘ç¼“æ…¢æ—‹è½¬ï¼ˆçƒå½¢ï¼‰
                            oortObj.rotation.y += 0.00005 * solarRotationSpeed;
                            oortObj.rotation.x += 0.00003 * solarRotationSpeed;
                        } else {
                            oortObj.visible = false;
                        }
                    }
                });
            }

            // å½—æ˜ŸåŠ¨ç”»ç³»ç»Ÿï¼ˆæ²¿æ¤­åœ†è½¨é“è¿è¡Œï¼‰
            if (solarSystem && solarSystem.visible) {
                comets.forEach((comet, cometIndex) => {
                    if (comet.userData && comet.userData.type === 'comet') {
                        // æ›´æ–°å½—æ˜Ÿè½¨é“è§’åº¦ï¼ˆæ¤­åœ†è½¨é“ï¼‰
                        comet.userData.angle += comet.userData.speed * solarRotationSpeed;
                        // è§’åº¦å½’ä¸€åŒ–ï¼Œé˜²æ­¢æµ®ç‚¹æ•°ç²¾åº¦è¯¯å·®
                        comet.userData.angle = ((comet.userData.angle % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);

                        // è®¡ç®—æ¤­åœ†è½¨é“ä½ç½®
                        // æ¤­åœ†è½¨é“å‚æ•°
                        const a = comet.userData.semiMajorAxis; // åŠé•¿è½´
                        const e = comet.userData.eccentricity; // ç¦»å¿ƒç‡
                        const i = comet.userData.inclination; // è½¨é“å€¾è§’

                        // è½¨é“å‘¨æœŸé€Ÿåº¦å˜åŒ–ï¼ˆåœ¨è¿‘æ—¥ç‚¹å¿«ï¼Œè¿œæ—¥ç‚¹æ…¢ï¼‰
                        // ä½¿ç”¨ç®€åŒ–æ¨¡å‹ï¼šé€Ÿåº¦ä¸è·ç¦»æˆåæ¯”
                        const currentAngle = comet.userData.angle;

                        // è®¡ç®—å½“å‰è·ç¦» r = a(1-eÂ²) / (1 + e cos(Î¸))
                        const r = a * (1 - e * e) / (1 + e * Math.cos(currentAngle));

                        // è½¨é“å¹³é¢æ—‹è½¬ï¼ˆè€ƒè™‘å€¾è§’ï¼‰
                        const orbitX = Math.cos(currentAngle) * r;
                        const orbitZ = Math.sin(currentAngle) * r;
                        const orbitY = Math.sin(i) * orbitZ; // å€¾è§’å½±å“Yè½´

                        // è®¾ç½®å½—æ˜Ÿç»„ä½ç½®
                        comet.position.set(orbitX, orbitY, orbitZ);

                        // å½—æ ¸è‡ªè½¬
                        if (comet.children[0]) {
                            comet.children[0].rotation.y += comet.userData.rotationSpeed * solarRotationSpeed;
                        }

                        // ç¦»å­å°¾åŠ¨ç”»ï¼ˆè“è‰²ï¼Œç¬”ç›´æŒ‡å‘è¿œç¦»å¤ªé˜³çš„æ–¹å‘ï¼‰
                        if (comet.userData.ionTail) {
                            const ionTail = comet.userData.ionTail;
                            const positions = ionTail.geometry.attributes.position.array;

                            // è®¡ç®—æŒ‡å‘è¿œç¦»å¤ªé˜³çš„æ–¹å‘ï¼ˆå½—å°¾æ–¹å‘ï¼‰
                            const cometPos = new THREE.Vector3(orbitX, orbitY, orbitZ);
                            const tailDirection = cometPos.clone().normalize().multiplyScalar(1); // æŒ‡å‘è¿œç¦»å¤ªé˜³çš„æ–¹å‘ï¼ˆä»å½—æ ¸å‘å¤–ï¼‰
                            
                            // å½—å°¾é•¿åº¦æ ¹æ®è·ç¦»è°ƒæ•´ï¼ˆè·ç¦»è¶Šè¿‘å½—å°¾è¶Šé•¿ï¼‰
                            const tailLength = 3.0 * (30.0 / Math.max(cometPos.length(), 10.0)); // æœ€å¤§3å•ä½é•¿åº¦

                            for (let j = 0; j < positions.length / 3; j++) {
                                // æ²¿ç€å½—å°¾æ–¹å‘å¸ƒç½®ç²’å­
                                const distanceAlongTail = (j / (positions.length / 3)) * tailLength;
                                const spread = Math.random() * 0.1 * distanceAlongTail;
                                
                                // è®¡ç®—ç²’å­ä½ç½®ï¼ˆæ²¿ç€å½—å°¾æ–¹å‘ï¼ŒåŠ ä¸Šä¸€äº›éšæœºæ‰©æ•£ï¼‰
                                const tailPos = tailDirection.clone().multiplyScalar(distanceAlongTail);
                                
                                // æ·»åŠ å‚ç›´æ–¹å‘çš„éšæœºæ‰©æ•£
                                const perpendicular = new THREE.Vector3(
                                    Math.random() - 0.5,
                                    Math.random() - 0.5,
                                    Math.random() - 0.5
                                ).cross(tailDirection).normalize().multiplyScalar(spread);
                                
                                positions[j * 3] = tailPos.x + perpendicular.x;
                                positions[j * 3 + 1] = tailPos.y + perpendicular.y;
                                positions[j * 3 + 2] = tailPos.z + perpendicular.z;

                                // ç²’å­é—ªçƒæ•ˆæœï¼Œè·ç¦»å½—æ ¸è¶Šè¿œè¶Šæš—
                                const distanceFactor = distanceAlongTail / tailLength;
                                const brightness = 0.7 * (1 - distanceFactor * 0.5) + Math.sin(time * 5 + j * 0.1) * 0.2;
                                ionTail.geometry.attributes.opacity.array[j] = brightness;
                            }

                            ionTail.geometry.attributes.position.needsUpdate = true;
                            ionTail.geometry.attributes.opacity.needsUpdate = true;
                        }

                        // å°˜åŸƒå°¾åŠ¨ç”»ï¼ˆé»„ç™½è‰²ï¼Œå¼¯æ›²æ‰©æ•£ï¼‰
                        if (comet.userData.dustTail) {
                            const dustTail = comet.userData.dustTail;
                            const positions = dustTail.geometry.attributes.position.array;
                            const curves = dustTail.geometry.userData.curves;

                            // è®¡ç®—æŒ‡å‘è¿œç¦»å¤ªé˜³çš„æ–¹å‘ï¼ˆå½—å°¾æ–¹å‘ï¼‰
                            const cometPos = new THREE.Vector3(orbitX, orbitY, orbitZ);
                            const tailDirection = cometPos.clone().normalize().multiplyScalar(1); // æŒ‡å‘è¿œç¦»å¤ªé˜³çš„æ–¹å‘ï¼ˆä»å½—æ ¸å‘å¤–ï¼‰
                            
                            // å½—å°¾é•¿åº¦æ ¹æ®è·ç¦»è°ƒæ•´ï¼ˆè·ç¦»è¶Šè¿‘å½—å°¾è¶Šé•¿ï¼‰
                            const tailLength = 4.0 * (30.0 / Math.max(cometPos.length(), 10.0)); // æœ€å¤§4å•ä½é•¿åº¦

                            for (let j = 0; j < positions.length / 3; j++) {
                                const distanceAlongTail = (j / (positions.length / 3)) * tailLength;
                                const curve = curves[j] || 0.3;
                                
                                // è®¡ç®—åŸºæœ¬å½—å°¾ä½ç½®
                                const tailPos = tailDirection.clone().multiplyScalar(distanceAlongTail);
                                
                                // æ·»åŠ å¼¯æ›²æ•ˆæœï¼ˆå‚ç›´äºå½—å°¾æ–¹å‘å’Œå½—æ˜Ÿé€Ÿåº¦æ–¹å‘ï¼‰
                                const bendAmount = distanceAlongTail * 0.1 * curve;
                                const bendDirection = new THREE.Vector3(0, 1, 0).cross(tailDirection).normalize();
                                
                                // æ·»åŠ åŠ¨æ€å¼¯æ›²ï¼ˆéšæ—¶é—´å˜åŒ–ï¼‰
                                const dynamicBend = Math.sin(time * 2 + j * 0.05) * bendAmount * 0.3;
                                
                                positions[j * 3] = tailPos.x + bendDirection.x * bendAmount + Math.random() * 0.05 * distanceAlongTail;
                                positions[j * 3 + 1] = tailPos.y + bendDirection.y * bendAmount + Math.random() * 0.05 * distanceAlongTail + dynamicBend;
                                positions[j * 3 + 2] = tailPos.z + bendDirection.z * bendAmount + Math.random() * 0.05 * distanceAlongTail;

                                // å°˜åŸƒé—ªçƒå’Œé¢œè‰²å˜åŒ–
                                const distanceFactor = distanceAlongTail / tailLength;
                                const hue = 0.1 + Math.random() * 0.03 - distanceFactor * 0.02;
                                const lightness = 0.6 + Math.sin(time * 4 + j * 0.08) * 0.2 - distanceFactor * 0.3;
                                const c = new THREE.Color().setHSL(hue, 0.5, lightness);
                                dustTail.geometry.attributes.color.array[j * 3] = c.r;
                                dustTail.geometry.attributes.color.array[j * 3 + 1] = c.g;
                                dustTail.geometry.attributes.color.array[j * 3 + 2] = c.b;
                            }

                            dustTail.geometry.attributes.position.needsUpdate = true;
                            dustTail.geometry.attributes.color.needsUpdate = true;
                        }
                    }
                });
            }

            // æ—‹è½¬æ˜Ÿç©ºèƒŒæ™¯ï¼ˆåœ°çƒå±‚çº§ï¼‰
            if (earthStarfield && earthStarfield.visible) {
                earthStarfield.rotation.y += 0.0002;
            }

            // åœ°çƒå±‚çº§æœˆçƒè½¨é“è¿åŠ¨
            if (window.earthMoon && currentLevel === 'earth') {
                window.earthMoon.userData.angle += window.earthMoon.userData.orbitSpeed * rotationSpeed;
                // è§’åº¦å½’ä¸€åŒ–ï¼Œé˜²æ­¢æµ®ç‚¹æ•°ç²¾åº¦è¯¯å·®
                window.earthMoon.userData.angle = ((window.earthMoon.userData.angle % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
                const moonRadius = window.earthMoon.userData.orbitRadius;
                const moonAngle = window.earthMoon.userData.angle;
                window.earthMoon.position.x = Math.cos(moonAngle) * moonRadius;
                window.earthMoon.position.z = Math.sin(moonAngle) * moonRadius;

                // æœˆçƒè‡ªè½¬ï¼ˆæ½®æ±é”å®šï¼Œä¸å…¬è½¬åŒæ­¥ï¼‰
                window.earthMoon.rotation.y += window.earthMoon.userData.orbitSpeed * rotationSpeed;
            }

            // æ—‹è½¬åœ°çƒå’Œäº‘å±‚
            if (earthSystem && earthSystem.visible) {
                if (isRotating) {
                    earthGroup.rotation.y += 0.005 * rotationSpeed;
                    if (clouds) {
                        clouds.rotation.y += 0.007 * rotationSpeed;
                    }
                }
                
                // åŸå¸‚å…‰ç¯è„‰å†²
                if (citiesGroup && showCities) {
                    const time = Date.now() * 0.002;
                    citiesGroup.children.forEach((child, index) => {
                        if (child.geometry && child.geometry.type === 'RingGeometry') {
                            const scale = 1 + Math.sin(time * 4 + index * 0.3) * 0.3;
                            child.scale.setScalar(scale);
                            child.material.opacity = 0.4 * (1 + Math.sin(time * 4 + index * 0.3)) * 0.5;
                        }
                    });
                }
                
                // å±±å³°å…‰ç¯è„‰å†²
                if (peaksGroup && showPeaks) {
                    const time = Date.now() * 0.001;
                    peaksGroup.children.forEach((child, index) => {
                        if (child.geometry && child.geometry.type === 'RingGeometry') {
                            const scale = 1 + Math.sin(time * 3 + index * 0.5) * 0.4;
                            child.scale.setScalar(scale);
                            child.material.opacity = 0.4 * (1 + Math.sin(time * 3 + index * 0.5)) * 0.5;
                        }
                    });
                }
                
                // æ¹–æ³Šå…‰ç¯è„‰å†²
                if (lakesGroup && showLakes) {
                    const time = Date.now() * 0.0015;
                    lakesGroup.children.forEach((child, index) => {
                        if (child.geometry && child.geometry.type === 'RingGeometry') {
                            const scale = 1 + Math.sin(time * 3.5 + index * 0.4) * 0.35;
                            child.scale.setScalar(scale);
                            child.material.opacity = 0.4 * (1 + Math.sin(time * 3.5 + index * 0.4)) * 0.5;
                        }
                    });
                }
                
                // æ²³æµå…‰ç¯è„‰å†²
                if (riversGroup && showRivers) {
                    const time = Date.now() * 0.0012;
                    riversGroup.children.forEach((child, index) => {
                        if (child.geometry && child.geometry.type === 'RingGeometry') {
                            const scale = 1 + Math.sin(time * 3.2 + index * 0.45) * 0.38;
                            child.scale.setScalar(scale);
                            child.material.opacity = 0.4 * (1 + Math.sin(time * 3.2 + index * 0.45)) * 0.5;
                        }
                    });
                }
            }
            
            // æ‰§è¡Œè‡ªå®šä¹‰åŠ¨ç”»æ›´æ–°
            animationUpdates.forEach(update => {
                if (update.update) {
                    update.update(time);
                }
            });
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // å¯åŠ¨åº”ç”¨
        window.addEventListener('DOMContentLoaded', function() {
            console.log('DOMåŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–');
            init(); // åˆå§‹åŒ–3Dåœºæ™¯

            // åˆå§‹åŒ–éŸ³ä¹åŠŸèƒ½
            initMusicPlayer();
            console.log('éŸ³ä¹æ’­æ”¾å™¨åˆå§‹åŒ–å®Œæˆ');
            
            // åˆå§‹åŒ–ä½ç½®æ ‡è®°åŠŸèƒ½
            setTimeout(() => {
                const locationButton = document.getElementById('getCurrentLocation');
                const clearButton = document.getElementById('clearCustomMarkers');
                
                if (locationButton) {
                    locationButton.addEventListener('click', getCurrentLocation);
                }
                
                if (clearButton) {
                    clearButton.addEventListener('click', clearCustomMarkers);
                }
                
                console.log('ä½ç½®æ ‡è®°åŠŸèƒ½åˆå§‹åŒ–å®Œæˆ');
            }, 500); // ç¨ç­‰ä¸€æ®µæ—¶é—´ç¡®ä¿DOMå®Œå…¨åŠ è½½
        });
        
        // éŸ³ä¹æ’­æ”¾åŠŸèƒ½
        let musicEnabled = false;
        let currentMusic = null;
        // currentLevel å·²åœ¨ä¸Šé¢å£°æ˜ï¼ˆç¬¬752è¡Œï¼‰ï¼Œæ­¤å¤„ä¸å†é‡å¤å£°æ˜

        // Web Audio API ç¨‹åºåŒ–éŸ³ä¹ç”Ÿæˆå™¨ - ä¼˜ç¾æ—‹å¾‹ç‰ˆ
        class SpaceMusicGenerator {
            constructor() {
                this.audioContext = null;
                this.isInitialized = false;
                this.masterGain = null;
                this.oscillators = [];
                this.gainNodes = [];
                this.envelopes = [];
                this.isPlaying = false;
                this.noteQueue = [];
                this.currentNoteIndex = 0;
                this.intervalId = null;
            }

            async init() {
                if (this.isInitialized) {
                    // å¦‚æœå·²ç»åˆå§‹åŒ–ï¼Œç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡æ˜¯è¿è¡ŒçŠ¶æ€
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                        console.log('éŸ³é¢‘ä¸Šä¸‹æ–‡å·²æ¢å¤');
                    }
                    return;
                }

                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.connect(this.audioContext.destination);
                    this.masterGain.gain.value = 0.8; // æé«˜åˆå§‹éŸ³é‡åˆ°0.8
                    this.isInitialized = true;
                    console.log('Web Audio API åˆå§‹åŒ–æˆåŠŸï¼Œé‡‡æ ·ç‡:', this.audioContext.sampleRate);

                    // å°è¯•æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                        console.log('éŸ³é¢‘ä¸Šä¸‹æ–‡å·²å¯åŠ¨');
                    }
                } catch (error) {
                    console.error('Web Audio API åˆå§‹åŒ–å¤±è´¥:', error);
                }
            }

            // åœæ­¢æ‰€æœ‰æŒ¯è¡å™¨å’Œè®¡æ—¶å™¨
            stopAll() {
                if (this.intervalId) {
                    clearInterval(this.intervalId);
                    this.intervalId = null;
                }

                this.oscillators.forEach(osc => {
                    try {
                        osc.stop();
                        osc.disconnect();
                    } catch (e) {}
                });
                this.oscillators = [];

                this.gainNodes.forEach(gain => {
                    try {
                        gain.disconnect();
                    } catch (e) {}
                });
                this.gainNodes = [];

                this.envelopes.forEach(env => {
                    try {
                        env.disconnect();
                    } catch (e) {}
                });
                this.envelopes = [];

                this.isPlaying = false;
            }

            // åˆ›å»ºå•ä¸ªéŸ³ç¬¦
            playNote(frequency, duration, startTime, type = 'sine', volume = 0.5) {
                if (!this.audioContext) return;

                const osc = this.audioContext.createOscillator();
                const gain = this.audioContext.createGain();
                const filter = this.audioContext.createBiquadFilter();

                osc.type = type;
                osc.frequency.setValueAtTime(frequency, startTime);

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(5000, startTime); // è¿›ä¸€æ­¥æé«˜æ»¤æ³¢å™¨é¢‘ç‡
                filter.Q.value = 2; // æé«˜Qå€¼å¢å¼ºéŸ³è‰²

                // ADSR åŒ…ç»œ
                const attack = 0.15;
                const decay = 0.25;
                const sustain = 0.6;
                const release = 0.5;

                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(volume, startTime + attack);
                gain.gain.linearRampToValueAtTime(volume * sustain, startTime + attack + decay);
                gain.gain.setValueAtTime(volume * sustain, startTime + duration - release);
                gain.gain.linearRampToValueAtTime(0, startTime + duration);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);

                osc.start(startTime);
                osc.stop(startTime + duration + 0.1);

                this.oscillators.push(osc);
                this.gainNodes.push(gain);
            }

            // åˆ›å»ºå’Œå¼¦
            playChord(frequencies, duration, startTime, type = 'sine', volume = 0.35) {
                frequencies.forEach(freq => {
                    this.playNote(freq, duration, startTime, type, volume);
                });
            }

            // ç”Ÿæˆé“¶æ²³ç³»éŸ³ä¹ - ä¼˜ç¾æ—‹å¾‹
            playGalaxyMusic() {
                console.log('å¼€å§‹æ’­æ”¾é“¶æ²³ç³»éŸ³ä¹ï¼Œå½“å‰æ—¶é—´:', this.audioContext ? this.audioContext.currentTime : 'æœªåˆå§‹åŒ–');
                this.stopAll();
                if (!this.audioContext) {
                    console.error('éŸ³é¢‘ä¸Šä¸‹æ–‡æœªåˆå§‹åŒ–ï¼Œæ— æ³•æ’­æ”¾éŸ³ä¹');
                    return;
                }

                const C4 = 261.63;
                const E4 = 329.63;
                const G4 = 392.00;
                const A4 = 440.00;
                const C5 = 523.25;
                const F4 = 349.23;
                const G3 = 196.00;
                const B3 = 246.94;
                const D4 = 293.66;
                const A3 = 220.00;
                const F3 = 174.61;
                const B4 = 493.88;
                const D5 = 587.33;

                // ä¼˜ç¾çš„å¤§è°ƒå’Œå¼¦è¿›è¡Œ
                const melody = [
                    // å°èŠ‚ 1-2
                    { notes: [C4, E4, G4], duration: 2, time: 0 },
                    { notes: [C4, F4, A4], duration: 2, time: 2 },
                    { notes: [G3, B3, D4], duration: 2, time: 4 },
                    { notes: [G3, C4, E4], duration: 2, time: 6 },

                    // å°èŠ‚ 3-4
                    { notes: [A3, C4, E4], duration: 2, time: 8 },
                    { notes: [F3, A3, C4], duration: 2, time: 10 },
                    { notes: [G3, B3, D4], duration: 2, time: 12 },
                    { notes: [C4, E4, G4], duration: 4, time: 14 },

                    // å°èŠ‚ 5-6
                    { notes: [C4, E4, A4], duration: 2, time: 18 },
                    { notes: [G4, B4, D5], duration: 2, time: 20 },
                    { notes: [E4, G4, C5], duration: 2, time: 22 },
                    { notes: [C4, E4, G4], duration: 2, time: 24 },

                    // å°èŠ‚ 7-8
                    { notes: [A3, D4, F4], duration: 2, time: 26 },
                    { notes: [G3, B3, D4], duration: 2, time: 28 },
                    { notes: [C4, E4, G4], duration: 4, time: 30 },
                ];

                // æ·»åŠ èƒŒæ™¯ä½éŸ³
                const bass = [
                    { freq: C4 * 0.5, time: 0, duration: 34 }
                ];

                const now = this.audioContext.currentTime;
                console.log('å½“å‰éŸ³é¢‘ä¸Šä¸‹æ–‡æ—¶é—´:', now);
                console.log('å¼€å§‹æ’­æ”¾æ—‹å¾‹ï¼Œå…±', melody.length, 'ä¸ªå’Œå¼¦');
                melody.forEach(chord => {
                    this.playChord(chord.notes, chord.duration, now + chord.time, 'sine', 0.4);
                });

                console.log('å¼€å§‹æ’­æ”¾ä½éŸ³ï¼Œå…±', bass.length, 'ä¸ªéŸ³ç¬¦');
                bass.forEach(note => {
                    this.playNote(note.freq, note.duration, now + note.time, 'triangle', 0.5);
                });

                // å¾ªç¯æ’­æ”¾
                this.intervalId = setInterval(() => {
                    if (this.isPlaying && musicEnabled) {
                        const loopTime = this.audioContext.currentTime;
                        melody.forEach(chord => {
                            this.playChord(chord.notes, chord.duration, loopTime + chord.time, 'sine', 0.4);
                        });
                        bass.forEach(note => {
                            this.playNote(note.freq, note.duration, loopTime + note.time, 'triangle', 0.5);
                        });
                    }
                }, 34000);

                this.isPlaying = true;
                console.log('é“¶æ²³ç³»æ—‹å¾‹éŸ³ä¹å¼€å§‹æ’­æ”¾ï¼Œä¸»éŸ³é‡:', this.masterGain.gain.value);
            }

            // ç”Ÿæˆå¤ªé˜³ç³»éŸ³ä¹ - æ´»æ³¼æ—‹å¾‹
            playSolarMusic() {
                this.stopAll();
                if (!this.audioContext) return;

                const G4 = 392.00;
                const B4 = 493.88;
                const D5 = 587.33;
                const E5 = 659.25;
                const E4 = 329.63;
                const D4 = 293.66;
                const F4 = 349.23;
                const A4 = 440.00;
                const C4 = 261.63;
                const B3 = 246.94;
                const C5 = 523.25;

                // æ´»æ³¼çš„å°è°ƒå’Œå¼¦è¿›è¡Œ
                const melody = [
                    // å°èŠ‚ 1-2
                    { notes: [E4, G4, B4], duration: 1.5, time: 0 },
                    { notes: [D4, F4, A4], duration: 1.5, time: 1.5 },
                    { notes: [C4, E4, G4], duration: 1.5, time: 3 },
                    { notes: [B3, D4, G4], duration: 1.5, time: 4.5 },

                    // å°èŠ‚ 3-4
                    { notes: [E4, G4, C5], duration: 1.5, time: 6 },
                    { notes: [D4, F4, B4], duration: 1.5, time: 7.5 },
                    { notes: [C4, E4, A4], duration: 1.5, time: 9 },
                    { notes: [B3, E4, G4], duration: 3, time: 10.5 },

                    // å°èŠ‚ 5-6
                    { notes: [G4, B4, D5], duration: 1.5, time: 13.5 },
                    { notes: [F4, A4, C5], duration: 1.5, time: 15 },
                    { notes: [E4, G4, B4], duration: 1.5, time: 16.5 },
                    { notes: [D4, G4, B4], duration: 1.5, time: 18 },

                    // å°èŠ‚ 7-8
                    { notes: [C4, E4, A4], duration: 1.5, time: 19.5 },
                    { notes: [B3, D4, G4], duration: 1.5, time: 21 },
                    { notes: [C4, E4, G4], duration: 3, time: 22.5 },
                ];

                const bass = [
                    { freq: 196.00, time: 0, duration: 25.5 }
                ];

                const now = this.audioContext.currentTime;
                melody.forEach(chord => {
                    this.playChord(chord.notes, chord.duration, now + chord.time, 'triangle', 0.35);
                });

                bass.forEach(note => {
                    this.playNote(note.freq, note.duration, now + note.time, 'sine', 0.5);
                });

                // å¾ªç¯æ’­æ”¾
                this.intervalId = setInterval(() => {
                    if (this.isPlaying && musicEnabled) {
                        const loopTime = this.audioContext.currentTime;
                        melody.forEach(chord => {
                            this.playChord(chord.notes, chord.duration, loopTime + chord.time, 'triangle', 0.35);
                        });
                        bass.forEach(note => {
                            this.playNote(note.freq, note.duration, loopTime + note.time, 'sine', 0.5);
                        });
                    }
                }, 25500);

                this.isPlaying = true;
                console.log('å¤ªé˜³ç³»æ—‹å¾‹éŸ³ä¹å¼€å§‹æ’­æ”¾');
            }

            // ç”Ÿæˆåœ°çƒéŸ³ä¹ - æ¸©æŸ”æ—‹å¾‹
            playEarthMusic() {
                this.stopAll();
                if (!this.audioContext) return;

                const D4 = 293.66;
                const F4 = 349.23;
                const A4 = 440.00;
                const C4 = 261.63;
                const E4 = 329.63;
                const G4 = 392.00;
                const B3 = 246.94;
                const A3 = 220.00;
                const G3 = 196.00;
                const B4 = 493.88;
                const C5 = 523.25;

                // æ¸©æŸ”çš„æ—‹å¾‹
                const melody = [
                    // å°èŠ‚ 1-2
                    { notes: [D4, F4, A4], duration: 2, time: 0 },
                    { notes: [C4, E4, G4], duration: 2, time: 2 },
                    { notes: [B3, D4, G4], duration: 2, time: 4 },
                    { notes: [A3, C4, E4], duration: 2, time: 6 },

                    // å°èŠ‚ 3-4
                    { notes: [G3, B3, D4], duration: 2, time: 8 },
                    { notes: [A3, C4, E4], duration: 2, time: 10 },
                    { notes: [B3, D4, F4], duration: 2, time: 12 },
                    { notes: [C4, E4, G4], duration: 4, time: 14 },

                    // å°èŠ‚ 5-6
                    { notes: [D4, F4, A4], duration: 2, time: 18 },
                    { notes: [E4, G4, B4], duration: 2, time: 20 },
                    { notes: [F4, A4, C5], duration: 2, time: 22 },
                    { notes: [E4, G4, B4], duration: 2, time: 24 },

                    // å°èŠ‚ 7-8
                    { notes: [D4, F4, A4], duration: 2, time: 26 },
                    { notes: [C4, E4, G4], duration: 2, time: 28 },
                    { notes: [D4, F4, A4], duration: 4, time: 30 },
                ];

                const bass = [
                    { freq: D4 * 0.5, time: 0, duration: 34 }
                ];

                const now = this.audioContext.currentTime;
                melody.forEach(chord => {
                    this.playChord(chord.notes, chord.duration, now + chord.time, 'sine', 0.4);
                });

                bass.forEach(note => {
                    this.playNote(note.freq, note.duration, now + note.time, 'triangle', 0.5);
                });

                // å¾ªç¯æ’­æ”¾
                this.intervalId = setInterval(() => {
                    if (this.isPlaying && musicEnabled) {
                        const loopTime = this.audioContext.currentTime;
                        melody.forEach(chord => {
                            this.playChord(chord.notes, chord.duration, loopTime + chord.time, 'sine', 0.4);
                        });
                        bass.forEach(note => {
                            this.playNote(note.freq, note.duration, loopTime + note.time, 'triangle', 0.5);
                        });
                    }
                }, 34000);

                this.isPlaying = true;
                console.log('åœ°çƒæ—‹å¾‹éŸ³ä¹å¼€å§‹æ’­æ”¾');
            }

            async resume() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                    console.log('éŸ³é¢‘ä¸Šä¸‹æ–‡å·²æ¢å¤');
                }
            }

            setVolume(value) {
                if (this.masterGain) {
                    // éŸ³é‡èŒƒå›´ 0-1ï¼Œç›´æ¥ä½¿ç”¨æ»‘å—å€¼ï¼Œä¸é™ä½éŸ³é‡
                    this.masterGain.gain.setValueAtTime(value, this.audioContext.currentTime);
                    console.log(`ä¸»éŸ³é‡è®¾ç½®ä¸º: ${value}`);
                }
            }
        }

        // åˆ›å»ºéŸ³ä¹ç”Ÿæˆå™¨å®ä¾‹
        const musicGenerator = new SpaceMusicGenerator();
        
        // æ–‡æœ¬å›½é™…åŒ–
        const musicTexts = {
            zh: {
                musicOn: 'ğŸµ éŸ³ä¹: å¼€',
                musicOff: 'ğŸ”‡ éŸ³ä¹: å…³',
                volume: 'éŸ³é‡'
            },
            en: {
                musicOn: 'ğŸµ Music: On',
                musicOff: 'ğŸ”‡ Music: Off',
                volume: 'Volume'
            }
        };
        
        // æ›´æ–°éŸ³ä¹ç•Œé¢æ–‡æœ¬
        function updateMusicInterfaceText() {
            const musicToggleBtn = document.getElementById('music-toggle');
            const volumeLabel = document.getElementById('volume-label');

            if (musicToggleBtn) {
                musicToggleBtn.textContent = musicEnabled ?
                    musicTexts[currentLang].musicOn :
                    musicTexts[currentLang].musicOff;
            }

            if (volumeLabel) {
                volumeLabel.textContent = musicTexts[currentLang].volume;
            }
        }

        // åˆå§‹åŒ–éŸ³ä¹æ’­æ”¾å™¨
        function initMusicPlayer() {
            // éŸ³ä¹å¼€å…³
            const musicToggleBtn = document.getElementById('music-toggle');
            if (musicToggleBtn) {
                musicToggleBtn.addEventListener('click', function() {
                    musicEnabled = !musicEnabled;
                    updateMusicInterfaceText();

                    if (musicEnabled) {
                        console.log(`å¼€å¯éŸ³ä¹ï¼Œæ’­æ”¾ ${currentLevel} éŸ³ä¹`);
                        playLevelMusic(currentLevel).then(() => {
                            console.log("éŸ³ä¹æ’­æ”¾æˆåŠŸ");
                        }).catch(e => {
                            console.error("éŸ³ä¹æ’­æ”¾å¤±è´¥:", e);
                        });
                    } else {
                        musicGenerator.stopAll();
                        console.log("éŸ³ä¹å·²å…³é—­");
                    }
                });
            }

            // éŸ³é‡æ§åˆ¶
            const musicVolumeSlider = document.getElementById('music-volume');
            if (musicVolumeSlider) {
                musicVolumeSlider.addEventListener('input', function(e) {
                    const volume = parseFloat(e.target.value);
                    musicGenerator.setVolume(volume);
                    console.log(`éŸ³é‡è®¾ç½®ä¸º: ${volume}`);
                });

                // åˆå§‹åŒ–éŸ³é‡è®¾ç½® - åœ¨éŸ³ä¹åˆå§‹åŒ–åè®¾ç½®
                const initialVolume = parseFloat(musicVolumeSlider.value);
                // å»¶è¿Ÿè®¾ç½®éŸ³é‡ï¼Œç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å·²åˆå§‹åŒ–
                setTimeout(() => {
                    if (musicGenerator.masterGain) {
                        musicGenerator.setVolume(initialVolume);
                        console.log(`åˆå§‹éŸ³é‡è®¾ç½®ä¸º: ${initialVolume}`);
                    }
                }, 100);
            }

            // åœ¨å±‚çº§åˆ‡æ¢å‡½æ•°ä¸­é›†æˆéŸ³ä¹
            // ä¿®æ”¹enterSolarSystemå‡½æ•°
            if (window.enterSolarSystem) {
                const originalEnterSolarSystem = window.enterSolarSystem;
                window.enterSolarSystem = function() {
                    originalEnterSolarSystem();
                    setTimeout(() => updateMusicForLevel('solar'), 100);
                };
            }

            // ä¿®æ”¹enterEarthå‡½æ•°
            if (window.enterEarth) {
                const originalEnterEarth = window.enterEarth;
                window.enterEarth = function() {
                    originalEnterEarth();
                    setTimeout(() => updateMusicForLevel('earth'), 100);
                };
            }

            // ä¿®æ”¹goBackå‡½æ•°
            if (window.goBack) {
                const originalGoBack = window.goBack;
                window.goBack = function() {
                    const previousLevel = currentLevel;
                    originalGoBack();
                    // æ ¹æ®è¿”å›åçš„å±‚çº§è®¾ç½®éŸ³ä¹
                    setTimeout(() => {
                        if (musicEnabled && musicGenerator.isPlaying) {
                            // å¦‚æœä»åœ°çƒè¿”å›åˆ°å¤ªé˜³ç³»ï¼Œæ’­æ”¾å¤ªé˜³ç³»éŸ³ä¹
                            if (previousLevel === 'earth' && currentLevel === 'solar') {
                                updateMusicForLevel('solar');
                            }
                            // å¦‚æœä»å¤ªé˜³ç³»è¿”å›åˆ°é“¶æ²³ç³»ï¼Œæ’­æ”¾é“¶æ²³ç³»éŸ³ä¹
                            else if (previousLevel === 'solar' && currentLevel === 'galaxy') {
                                updateMusicForLevel('galaxy');
                            }
                        }
                    }, 200);
                };
            }

            // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–éŸ³ä¹ç•Œé¢æ–‡æœ¬
            updateMusicInterfaceText();

            // ç›‘å¬ç”¨æˆ·ç¬¬ä¸€æ¬¡äº¤äº’åå†æ’­æ”¾éŸ³ä¹ï¼ˆè§£å†³è‡ªåŠ¨æ’­æ”¾é™åˆ¶ï¼‰
            const playAfterInteraction = () => {
                if (musicEnabled && !musicGenerator.isPlaying) {
                    console.log("æ£€æµ‹åˆ°ç”¨æˆ·äº¤äº’ï¼Œå¼€å§‹æ’­æ”¾éŸ³ä¹");
                    playLevelMusic('galaxy');
                }
                // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
                document.removeEventListener('click', playAfterInteraction);
                document.removeEventListener('keydown', playAfterInteraction);
                document.removeEventListener('touchstart', playAfterInteraction);
            };

            // ç›‘å¬å¤šç§ç”¨æˆ·äº¤äº’äº‹ä»¶
            document.addEventListener('click', playAfterInteraction, { once: true });
            document.addEventListener('keydown', playAfterInteraction, { once: true });
            document.addEventListener('touchstart', playAfterInteraction, { once: true });

            console.log("éŸ³ä¹æ’­æ”¾å™¨å·²åˆå§‹åŒ–ï¼Œç­‰å¾…ç”¨æˆ·äº¤äº’åæ’­æ”¾");
        }

        // æ’­æ”¾æŒ‡å®šå±‚çº§çš„éŸ³ä¹ï¼ˆä½¿ç”¨ç¨‹åºåŒ–ç”Ÿæˆï¼‰
        async function playLevelMusic(level) {
            if (!musicEnabled) return;

            try {
                // åˆå§‹åŒ–éŸ³ä¹ç”Ÿæˆå™¨
                await musicGenerator.init();

                // æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆå·²åœ¨initä¸­å¤„ç†ï¼‰

                // æ ¹æ®å±‚çº§æ’­æ”¾ä¸åŒçš„éŸ³ä¹
                switch (level) {
                    case 'galaxy':
                        musicGenerator.playGalaxyMusic();
                        break;
                    case 'solar':
                        musicGenerator.playSolarMusic();
                        break;
                    case 'earth':
                        musicGenerator.playEarthMusic();
                        break;
                    default:
                        musicGenerator.playGalaxyMusic();
                }

                console.log(`æ­£åœ¨æ’­æ”¾ ${level} ç¨‹åºåŒ–éŸ³ä¹`);
                return Promise.resolve();
            } catch (e) {
                console.error("æ’­æ”¾éŸ³ä¹æ—¶å‡ºé”™:", e);
                return Promise.reject(e);
            }
        }
        
        // æ›´æ–°éŸ³ä¹çŠ¶æ€
        function updateMusicForLevel(newLevel) {
            currentLevel = newLevel;
            if (musicEnabled) {
                playLevelMusic(newLevel);
            }
        }
    </script>
    
    <!-- éŸ³ä¹æ’­æ”¾å™¨ -->
    <div id="music-player" style="
        position: absolute;
        bottom: 20px;
        left: 20px;
        z-index: 300;
        background: rgba(0, 30, 60, 0.8);
        border: 1px solid #00f2fe;
        border-radius: 5px;
        padding: 10px;
        backdrop-filter: blur(10px);
    ">
        <div style="display: flex; align-items: center; gap: 10px;">
            <button id="music-toggle" style="
                background: rgba(0, 242, 254, 0.2);
                color: #00f2fe;
                border: 1px solid #00f2fe;
                border-radius: 3px;
                padding: 5px 10px;
                cursor: pointer;
                font-size: 14px;
            ">ğŸµ Music: On</button>
            <input type="range" id="music-volume" min="0" max="1" step="0.1" value="0.8" style="
                width: 80px;
            ">
            <span id="volume-label" style="color: #00f2fe; font-size: 12px;">Volume</span>
        </div>
    </div>

</body>
</html>