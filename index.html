<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="pageTitle">宇宙迷航</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: radial-gradient(ellipse at center, #0a0e2a 0%, #000000 70%);
            color: #ffffff;
            overflow: hidden;
        }
        
        #universe-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            text-align: center;
            background: linear-gradient(180deg, rgba(0,0,0,0.8), transparent);
            z-index: 100;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(0, 242, 254, 0.8);
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #00f2fe;
            opacity: 0.8;
        }
        
        /* 语言切换按钮 */
        #lang-toggle {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 8px 15px;
            background: rgba(0, 30, 60, 0.8);
            border: 1px solid #00f2fe;
            color: #00f2fe;
            cursor: pointer;
            border-radius: 5px;
            font-size: 14px;
            z-index: 200;
            backdrop-filter: blur(10px);
        }
        
        #lang-toggle:hover {
            background: rgba(0, 242, 254, 0.2);
            box-shadow: 0 0 10px rgba(0, 242, 254, 0.5);
        }
        
        /* 导航按钮通用样式 */
        .nav-button {
            position: absolute;
            left: 20px;
            padding: 10px 20px;
            background: rgba(0, 30, 60, 0.8);
            border: 1px solid #00f2fe;
            color: #00f2fe;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
            display: none;
            z-index: 100;
        }
        
        .nav-button:hover {
            background: rgba(0, 242, 254, 0.2);
            box-shadow: 0 0 10px rgba(0, 242, 254, 0.5);
        }
        
        #back-button {
            top: 20px;
        }
        
        #enter-solar-button {
            top: 70px;
        }
        
        #enter-earth-button {
            top: 120px;
        }
        
        #toggle-panel-button {
            bottom: 20px;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 242, 254, 0.3);
            border-top: 3px solid #00f2fe;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 10px;
            border: 1px solid #00f2fe;
            z-index: 100;
        }
        
        /* 控制面板样式 - 从原始地球模型整合 */
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 30, 60, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #00f2fe;
            z-index: 100;
            max-width: 250px;
            backdrop-filter: blur(10px);
        }
        
        #controls h3 {
            color: #00f2fe;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 5px rgba(0, 242, 254, 0.5);
        }
        
        #controls label {
            color: #ffffff;
            font-size: 12px;
            display: block;
            margin-bottom: 5px;
        }
        
        #controls input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
            -webkit-appearance: none;
            height: 5px;
            border-radius: 5px;
            background: rgba(0, 242, 254, 0.3);
            outline: none;
        }
        
        #controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background: #00f2fe;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 242, 254, 0.8);
        }
        
        #controls button {
            background: rgba(0, 242, 254, 0.2);
            color: #00f2fe;
            border: 1px solid #00f2fe;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            display: inline-block;
        }
        
        #controls button:hover {
            background: rgba(0, 242, 254, 0.4);
            box-shadow: 0 0 10px rgba(0, 242, 254, 0.5);
        }
        
        #controls div:last-child {
            text-align: center;
        }
        
        .texture-info {
            font-size: 11px;
            color: #00f2fe;
            margin-top: 10px;
            text-align: center;
            opacity: 0.8;
        }
        
        .credits-info {
            font-size: 12px;
            color: #00f2fe;
            margin-top: 10px;
            text-align: center;
            line-height: 1.8;
        }
        
        .credits-info div {
            padding: 3px 0;
        }
        
        /* 介绍弹窗样式 */
        .sci-fi-tooltip {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 30, 60, 0.3);
            border: none;
            border-radius: 15px;
            padding: 25px;
            color: #ffffff;
            font-family: 'Arial', sans-serif;
            max-width: 400px;
            z-index: 1000;
            box-shadow: 0 0 40px rgba(0, 242, 254, 0.6);
            backdrop-filter: blur(15px);
            animation: fadeIn 0.3s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        
        /* 隐藏地球层级的控制面板 */
        .earth-controls {
            display: none;
        }
        
        .earth-controls.visible {
            display: block;
        }
    </style>
</head>
<body>
    <div id="universe-container">
        <div id="header">
            <h1 id="mainTitle">宇宙迷航</h1>
            <div class="subtitle" id="mainSubtitle">飞向无边的星际</div>
        </div>
        
        <button id="lang-toggle" onclick="toggleLanguage()">English/中文</button>
        
        <button id="back-button" class="nav-button" onclick="goBack()">返回</button>
        <button id="enter-solar-button" class="nav-button" onclick="enterSolarSystem()">进入太阳系</button>
        <button id="enter-earth-button" class="nav-button" onclick="enterEarth()">进入地球</button>
        <button id="toggle-panel-button" class="nav-button" onclick="toggleControlPanel()">隐藏控制面板</button>
        
        <div id="loading" class="loading">
            <div class="loading-spinner"></div>
            <div id="loadingText">正在加载宇宙...</div>
        </div>
        
        <div class="instructions" id="instructions">
            移动鼠标到太阳系标记处点击
        </div>
        
        <!-- 银河系控制面板 -->
        <div id="galaxy-controls" class="earth-controls">
            <div id="controls">
                <h3 id="galaxyControlTitle">银河系控制</h3>
                <label><span id="galaxySpeedLabel">银河系转速</span>: <span id="galaxySpeedValue">1.0</span></label>
                <input type="range" id="galaxySpeed" min="0" max="3" step="0.1" value="1">
            </div>
        </div>
        
        <!-- 太阳系控制面板 -->
        <div id="solar-controls" class="earth-controls">
            <div id="controls">
                <h3 id="solarControlTitle">太阳系控制</h3>
                <label><span id="solarSpeedLabel">系统转速</span>: <span id="solarSpeedValue">0.25</span></label>
                <input type="range" id="solarSpeed" min="0" max="3" step="0.1" value="0.25">
            </div>
        </div>
        
        <!-- 地球层级控制面板 -->
        <div id="earth-controls" class="earth-controls">
            <div id="controls">
                <h3 id="earthControlTitle">地球控制面板</h3>
                <label><span id="rotationSpeedLabel">旋转速度</span>: <span id="speedValue">0.25</span></label>
                <input type="range" id="rotationSpeed" min="0" max="3" step="0.1" value="0.25">
                
                <label><span id="cloudOpacityLabel">云层透明度</span>: <span id="cloudValue">0.4</span></label>
                <input type="range" id="cloudOpacity" min="0" max="1" step="0.1" value="0.4">
                
                <div>
                    <button id="toggleRotation">暂停旋转</button>
                    <button id="resetView">重置视图</button>
                </div>

                <div>
					<button id="toggleEquator">显示赤道</button>
                    <button id="toggleLatLon">显示经纬线</button>
                    <button id="toggleArcAnt">显示极圈</button>
                    <button id="toggleCanCap">显示回归线</button>
                </div>

                <div>
                    <button id="toggleCities">隐藏城市</button>
                    <button id="togglePeaks">隐藏山峰</button>
                    <button id="toggleLakes">隐藏湖泊</button>
                    <button id="toggleRivers">隐藏河流</button>
                </div>

                <div class="texture-info" id="normalInfo">
                    <span id="peaksStatus">山峰: 已显示</span> | 
                    <span id="citiesStatus">城市: 已显示</span>
                </div>
				
                <div class="texture-info" id="normalInfo2">
                    <span id="lakesStatus">湖泊: 已显示</span> | 
                    <span id="riversStatus">河流: 已显示</span>
                </div>
                
                <div class="credits-info" id="creditsInfo" style="display: none;">
                    <div id="supervisorText">监制　白爱娃</div>
                    <div id="developerText">开发　李　博</div>
                    <div id="testerText">测试　李一昕</div>
                    <div id="softwareText">AI: CodeBuddy</div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
        // 语言状态
        let currentLang = 'zh'; // 默认中文
        
        // 文本映射
        const texts = {
            zh: {
                pageTitle: '宇宙迷航',
                mainTitle: '宇宙迷航',
                mainSubtitle: '飞向无边的星际',
                loadingText: '正在加载宇宙...',
                instructions: {
                    galaxy: '移动鼠标到太阳系标记处点击',
                    solar: '移动鼠标到地球标记处点击',
                    earth: '使用鼠标拖拽旋转，滚轮缩放',
                    hover: '悬停: %s | 点击查看详情',
                    click: '点击探索: %s'
                },
                navButtons: {
                    back: '返回',
                    enterSolar: '进入太阳系',
                    enterEarth: '进入地球',
                    togglePanel: '隐藏控制面板'
                },
                controlPanels: {
                    galaxy: {
                        title: '银河系控制',
                        speedLabel: '银河系转速'
                    },
                    solar: {
                        title: '太阳系控制',
                        speedLabel: '系统转速'
                    },
                    earth: {
                        title: '地球控制面板',
                        rotationSpeed: '旋转速度',
                        cloudOpacity: '云层透明度'
                    }
                },
                toggleButtons: {
                    rotation: ['暂停旋转', '继续旋转', '恢复旋转'],
                    reset: '重置视图',
                    latLon: ['显示经纬线', '隐藏经纬线'],
                    equator: ['显示赤道', '隐藏赤道'],
                    tropic: ['显示回归线', '隐藏回归线'],
                    arcAnt: ['显示极圈', '隐藏极圈'],
                    cities: ['隐藏城市', '显示城市'],
                    peaks: ['隐藏山峰', '显示山峰'],
                    lakes: ['隐藏湖泊', '隐藏湖泊'],
                    rivers: ['隐藏河流', '显示河流']
                },
                statusText: {
                    peaks: ['山峰: 已显示', '山峰: 未显示'],
                    cities: ['城市: 已显示', '城市: 未显示'],
                    lakes: ['湖泊: 已显示', '湖泊: 未显示'],
                    rivers: ['河流: 已显示', '河流: 未显示']
                },
                credits: {
                    supervisor: '监制    白爱娃',
                    developer: '开发    李博',
                    tester: '测试    李一昕'
                }
            },
            en: {
                pageTitle: 'Journey to the Universe',
                mainTitle: 'Journey to the Universe',
                mainSubtitle: 'Soaring into the distant stars',
                loadingText: 'Loading universe...',
                instructions: {
                    galaxy: 'Move mouse to Solar System marker and click',
                    solar: 'Move mouse to Earth marker and click',
                    earth: 'Drag mouse to rotate, scroll to zoom',
                    hover: 'Hover: %s | Click for details',
                    click: 'Click to explore: %s'
                },
                navButtons: {
                    back: 'Back',
                    enterSolar: 'Enter Solar System',
                    enterEarth: 'Enter Earth',
                    togglePanel: 'Hide Panel'
                },
                controlPanels: {
                    galaxy: {
                        title: 'Galaxy Controls',
                        speedLabel: 'Galaxy Rotation Speed'
                    },
                    solar: {
                        title: 'Solar System Controls',
                        speedLabel: 'System Rotation Speed'
                    },
                    earth: {
                        title: 'Earth Control Panel',
                        rotationSpeed: 'Rotation Speed',
                        cloudOpacity: 'Cloud Opacity'
                    }
                },
                toggleButtons: {
                    rotation: ['Pause Rotation', 'Resume Rotation', 'Resume Rotation'],
                    reset: 'Reset View',
                    latLon: ['Show Lat/Lon Lines', 'Hide Lat/Lon Lines'],
                    equator: ['Show Equator', 'Hide Equator'],
                    tropic: ['Show Tropics', 'Hide Tropics'],
                    arcAnt: ['Show Polar Circles', 'Hide Polar Circles'],
                    cities: ['Hide Cities', 'Show Cities'],
                    peaks: ['Hide Peaks', 'Show Peaks'],
                    lakes: ['Hide Lakes', 'Show Lakes'],
                    rivers: ['Hide Rivers', 'Show Rivers']
                },
                statusText: {
                    peaks: ['Peaks: Shown', 'Peaks: Hidden'],
                    cities: ['Cities: Shown', 'Cities: Hidden'],
                    lakes: ['Lakes: Shown', 'Lakes: Hidden'],
                    rivers: ['Rivers: Shown', 'Rivers: Hidden']
                },
                credits: {
                    supervisor: 'Supervisor Bai Aiewa',
                    developer: 'Developer Li Bo',
                    tester: 'Tester Li Yixin'
                }
            }
        };
        
        // 切换语言函数
        function toggleLanguage() {
            currentLang = currentLang === 'zh' ? 'en' : 'zh';
            panelToggleFlag = true;
            // 更新页面标题
            document.title = texts[currentLang].pageTitle;
            document.getElementById('pageTitle').textContent = texts[currentLang].pageTitle;
            
            // 更新主标题
            document.getElementById('mainTitle').textContent = texts[currentLang].mainTitle;
            document.getElementById('mainSubtitle').textContent = texts[currentLang].mainSubtitle;
            
            // 更新加载文本
            document.getElementById('loadingText').textContent = texts[currentLang].loadingText;
            
            // 更新导航按钮文本
            document.getElementById('back-button').textContent = texts[currentLang].navButtons.back;
            document.getElementById('enter-solar-button').textContent = texts[currentLang].navButtons.enterSolar;
            document.getElementById('enter-earth-button').textContent = texts[currentLang].navButtons.enterEarth;
            document.getElementById('toggle-panel-button').textContent = texts[currentLang].navButtons.togglePanel;
            
            // 更新控制面板标题
            document.getElementById('galaxyControlTitle').textContent = texts[currentLang].controlPanels.galaxy.title;
            document.getElementById('galaxySpeedLabel').textContent = texts[currentLang].controlPanels.galaxy.speedLabel;
            document.getElementById('solarControlTitle').textContent = texts[currentLang].controlPanels.solar.title;
            document.getElementById('solarSpeedLabel').textContent = texts[currentLang].controlPanels.solar.speedLabel;
            document.getElementById('earthControlTitle').textContent = texts[currentLang].controlPanels.earth.title;
            document.getElementById('rotationSpeedLabel').textContent = texts[currentLang].controlPanels.earth.rotationSpeed;
            document.getElementById('cloudOpacityLabel').textContent = texts[currentLang].controlPanels.earth.cloudOpacity;
            
            // 更新控制按钮文本
            updateControlButtonText();
            
            // 更新制作人员信息
            if (document.getElementById('supervisorText')) {
                document.getElementById('supervisorText').textContent = texts[currentLang].credits.supervisor;
            }
            if (document.getElementById('developerText')) {
                document.getElementById('developerText').textContent = texts[currentLang].credits.developer;
            }
            if (document.getElementById('testerText')) {
                document.getElementById('testerText').textContent = texts[currentLang].credits.tester;
            }

            // 更新状态文本
            updateStatusText();

            // 更新说明文字
            updateInstructionsText();

            // 更新所有标签文本
            updateAllLabels();
        }

        // 更新所有标签文本
        function updateAllLabels() {
            // 更新城市标签
            cityLabels.forEach(label => {
                const data = label.userData.data;
                const text = currentLang === 'zh' ? data.name : data.englishName;
                updateLabelText(label, text);
            });

            // 更新山峰标签
            peakLabels.forEach(label => {
                const data = label.userData.data;
                const text = currentLang === 'zh' ? data.name : data.englishName;
                const isPole = label.userData.key === 'northpole' || label.userData.key === 'southpole';
                const color = isPole ? '#ff8800' : '#ff0000';
                updateLabelText(label, text, color);
            });

            // 更新湖泊标签
            lakeLabels.forEach(label => {
                const data = label.userData.data;
                const text = currentLang === 'zh' ? data.name : data.englishName;
                updateLabelText(label, text, '#0099ff');
            });

            // 更新河流标签
            riverLabels.forEach(label => {
                const data = label.userData.data;
                const text = currentLang === 'zh' ? data.name : data.englishName;
                updateLabelText(label, text, '#00ff00');
            });
        }

        // 更新标签文本
        function updateLabelText(label, text, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;

            // 清除画布，保持透明背景
            context.clearRect(0, 0, canvas.width, canvas.height);

            // 添加文字阴影效果，提高可读性
            context.shadowColor = 'rgba(0, 0, 0, 0.8)';
            context.shadowBlur = 4;
            context.shadowOffsetX = 2;
            context.shadowOffsetY = 2;

            context.font = 'Bold 24px Arial';
            context.fillStyle = color || '#ffffff';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;

            if (label.material && label.material.map) {
                label.material.map.dispose();
                label.material.map = texture;
                label.material.needsUpdate = true;
            }
        }

        // 更新控制按钮文本
        function updateControlButtonText() {
            const langTexts = texts[currentLang];
            
            // 旋转按钮
            const toggleRotationBtn = document.getElementById('toggleRotation');
            if (toggleRotationBtn) {
                // 根据当前状态决定显示哪个文本
                if (toggleRotationBtn.textContent.includes(texts['zh'].toggleButtons.rotation[0]) || 
                    toggleRotationBtn.textContent.includes(texts['en'].toggleButtons.rotation[0])) {
                    toggleRotationBtn.textContent = langTexts.toggleButtons.rotation[0]; // 暂停/暂停旋转
                } else if (toggleRotationBtn.textContent.includes(texts['zh'].toggleButtons.rotation[1]) || 
                          toggleRotationBtn.textContent.includes(texts['en'].toggleButtons.rotation[1])) {
                    toggleRotationBtn.textContent = langTexts.toggleButtons.rotation[1]; // 继续/继续旋转
                } else if (toggleRotationBtn.textContent.includes(texts['zh'].toggleButtons.rotation[2]) || 
                          toggleRotationBtn.textContent.includes(texts['en'].toggleButtons.rotation[2])) {
                    toggleRotationBtn.textContent = langTexts.toggleButtons.rotation[2]; // 恢复/恢复旋转
                }
            }
            
            // 重置按钮
            const resetViewBtn = document.getElementById('resetView');
            if (resetViewBtn) {
                resetViewBtn.textContent = langTexts.toggleButtons.reset;
            }
            
            // 显示/隐藏按钮 - 直接根据显示状态更新
            const toggleLatLonBtn = document.getElementById('toggleLatLon');
            if (toggleLatLonBtn) {
                const isVisible = !toggleLatLonBtn.textContent.includes(texts['zh'].toggleButtons.latLon[1]) &&
                                    !toggleLatLonBtn.textContent.includes(texts['en'].toggleButtons.latLon[1]);
                toggleLatLonBtn.textContent = isVisible ? langTexts.toggleButtons.latLon[1] : langTexts.toggleButtons.latLon[0];
            }

            const toggleEquatorBtn = document.getElementById('toggleEquator');
            if (toggleEquatorBtn) {
                const isVisible = !toggleEquatorBtn.textContent.includes(texts['zh'].toggleButtons.equator[1]) &&
                                    !toggleEquatorBtn.textContent.includes(texts['en'].toggleButtons.equator[1]);
                toggleEquatorBtn.textContent = isVisible ? langTexts.toggleButtons.equator[1] : langTexts.toggleButtons.equator[0];
            }

            const toggleCanCapBtn = document.getElementById('toggleCanCap');
            if (toggleCanCapBtn) {
                const isVisible = !toggleCanCapBtn.textContent.includes(texts['zh'].toggleButtons.tropic[1]) &&
                                    !toggleCanCapBtn.textContent.includes(texts['en'].toggleButtons.tropic[1]);
                toggleCanCapBtn.textContent = isVisible ? langTexts.toggleButtons.tropic[1] : langTexts.toggleButtons.tropic[0];
            }

            const toggleArcAntBtn = document.getElementById('toggleArcAnt');
            if (toggleArcAntBtn) {
                const isVisible = !toggleArcAntBtn.textContent.includes(texts['zh'].toggleButtons.arcAnt[1]) &&
                                    !toggleArcAntBtn.textContent.includes(texts['en'].toggleButtons.arcAnt[1]);
                toggleArcAntBtn.textContent = isVisible ? langTexts.toggleButtons.arcAnt[1] : langTexts.toggleButtons.arcAnt[0];
            }
            
            // 城市、山峰、湖泊、河流按钮
            updateVisibilityButton('toggleCities', langTexts.toggleButtons.cities);
            updateVisibilityButton('togglePeaks', langTexts.toggleButtons.peaks);
            updateVisibilityButton('toggleLakes', langTexts.toggleButtons.lakes);
            updateVisibilityButton('toggleRivers', langTexts.toggleButtons.rivers);
        }
        
        // 辅助函数：更新显示/隐藏按钮文本
        function updateVisibilityButton(buttonId, textsArray) {
            const btn = document.getElementById(buttonId);
            if (btn) {
                // 检查当前按钮文本是否包含显示或隐藏的文本
                const hasValidText = btn.textContent.includes(texts['zh'].toggleButtons.cities[0]) ||
                    btn.textContent.includes(texts['en'].toggleButtons.cities[0]) ||
                    btn.textContent.includes(texts['zh'].toggleButtons.cities[1]) ||
                    btn.textContent.includes(texts['en'].toggleButtons.cities[1]) ||
                    btn.textContent.includes(texts['zh'].toggleButtons.peaks[0]) ||
                    btn.textContent.includes(texts['en'].toggleButtons.peaks[0]) ||
                    btn.textContent.includes(texts['zh'].toggleButtons.peaks[1]) ||
                    btn.textContent.includes(texts['en'].toggleButtons.peaks[1]) ||
                    btn.textContent.includes(texts['zh'].toggleButtons.lakes[0]) ||
                    btn.textContent.includes(texts['en'].toggleButtons.lakes[0]) ||
                    btn.textContent.includes(texts['zh'].toggleButtons.lakes[1]) ||
                    btn.textContent.includes(texts['en'].toggleButtons.lakes[1]) ||
                    btn.textContent.includes(texts['zh'].toggleButtons.rivers[0]) ||
                    btn.textContent.includes(texts['en'].toggleButtons.rivers[0]) ||
                    btn.textContent.includes(texts['zh'].toggleButtons.rivers[1]) ||
                    btn.textContent.includes(texts['en'].toggleButtons.rivers[1]);

                if (hasValidText) {
                    // 判断当前是否为隐藏状态(包含"隐藏"或"Hide"文本)
                    const isHidden = btn.textContent.includes(texts['zh'].toggleButtons.cities[0]) ||
                                    btn.textContent.includes(texts['en'].toggleButtons.cities[0]) ||
                                    btn.textContent.includes(texts['zh'].toggleButtons.peaks[0]) ||
                                    btn.textContent.includes(texts['en'].toggleButtons.peaks[0]) ||
                                    btn.textContent.includes(texts['zh'].toggleButtons.lakes[0]) ||
                                    btn.textContent.includes(texts['en'].toggleButtons.lakes[0]) ||
                                    btn.textContent.includes(texts['zh'].toggleButtons.rivers[0]) ||
                                    btn.textContent.includes(texts['en'].toggleButtons.rivers[0]);

                    // 直接根据显示状态更新为对应的语言文本
                    btn.textContent = isHidden ? textsArray[0] : textsArray[1];
                }
            }
        }
        
        // 更新说明文字
        function updateInstructionsText() {
            const instructionsEl = document.getElementById('instructions');
            if (instructionsEl) {
                // 根据当前层级更新说明文字
                if (currentLevel === 'galaxy') {
                    instructionsEl.innerHTML = texts[currentLang].instructions.galaxy;
                } else if (currentLevel === 'solar') {
                    instructionsEl.innerHTML = texts[currentLang].instructions.solar;
                } else if (currentLevel === 'earth') {
                    instructionsEl.innerHTML = texts[currentLang].instructions.earth;
                }
            }
        }

        // 更新状态文本
        function updateStatusText() {
            const peaksStatus = document.getElementById('peaksStatus');
            const citiesStatus = document.getElementById('citiesStatus');
            const lakesStatus = document.getElementById('lakesStatus');
            const riversStatus = document.getElementById('riversStatus');

            if (peaksStatus) {
                const isShown = showPeaks;
                peaksStatus.textContent = texts[currentLang].statusText.peaks[isShown ? 0 : 1];
            }

            if (citiesStatus) {
                const isShown = showCities;
                citiesStatus.textContent = texts[currentLang].statusText.cities[isShown ? 0 : 1];
            }

            if (lakesStatus) {
                const isShown = showLakes;
                lakesStatus.textContent = texts[currentLang].statusText.lakes[isShown ? 0 : 1];
            }

            if (riversStatus) {
                const isShown = showRivers;
                riversStatus.textContent = texts[currentLang].statusText.rivers[isShown ? 0 : 1];
            }
        }
        
        // ===== 全局变量 =====
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let currentLevel = 'galaxy'; // galaxy, solar, earth
        let animationId;
        
        // 控制面板状态变量
        let panelToggleCount = 0;
		let panelToggleFlag = true;
        let isPanelVisible = true;
        let showingCredits = false;
        
        // 层级对象
        let galaxy, solarSystem, earthSystem;
        let galaxyStars = [];
        let planets = [];
        let moon = null;
        let asteroidBelt = [];
        let comets = []; // 彗星数组
        let kuiperBelt = []; // 柯伊伯带数组
        let oortCloud = []; // 奥尔特云数组
        let earthStarfield = null;
        let solarStarfield = null;
        
        // 创建球型粒子纹理
        function createSphereTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            
            // 创建径向渐变，模拟球体效果
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // 创建行星纹理
        function createPlanetTexture(planetName) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // 根据行星类型生成不同纹理
            switch(planetName) {
                case '水星':
                case 'Mercury':
                    // 水星：灰色、布满陨石坑
                    createMercuryTexture(ctx);
                    break;
                case '金星':
                case 'Venus':
                    // 金星：黄白色、云层覆盖
                    createVenusTexture(ctx);
                    break;
                case '火星':
                case 'Mars':
                    // 火星：红色、有极冠和暗色区域
                    createMarsTexture(ctx);
                    break;
                case '木星':
                case 'Jupiter':
                    // 木星：条纹状、大红斑
                    createJupiterTexture(ctx);
                    break;
                case '土星':
                case 'Saturn':
                    // 土星：淡黄色条纹
                    createSaturnTexture(ctx);
                    break;
                case '天王星':
                case 'Uranus':
                    // 天王星：青色
                    createUranusTexture(ctx);
                    break;
                case '海王星':
                case 'Neptune':
                    // 海王星：深蓝色
                    createNeptuneTexture(ctx);
                    break;
                default:
                    ctx.fillStyle = '#888888';
                    ctx.fillRect(0, 0, 512, 512);
            }
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        // 水星纹理：灰色、陨石坑
        function createMercuryTexture(ctx) {
            // 基础灰色
            const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            gradient.addColorStop(0, '#a0a0a0');
            gradient.addColorStop(1, '#606060');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // 陨石坑
            for (let i = 0; i < 150; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const radius = Math.random() * 20 + 5;
                
                const craterGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                craterGradient.addColorStop(0, '#505050');
                craterGradient.addColorStop(0.7, '#707070');
                craterGradient.addColorStop(1, '#808080');
                ctx.fillStyle = craterGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // 金星纹理：黄白色云层
        function createVenusTexture(ctx) {
            // 基础黄白色
            ctx.fillStyle = '#f5e6d3';
            ctx.fillRect(0, 0, 512, 512);
            
            // 云层纹理
            for (let i = 0; i < 300; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const width = Math.random() * 100 + 50;
                const height = Math.random() * 30 + 10;
                
                ctx.fillStyle = `rgba(${200 + Math.random() * 50}, ${180 + Math.random() * 50}, ${140 + Math.random() * 40}, 0.3)`;
                ctx.beginPath();
                ctx.ellipse(x, y, width, height, Math.random() * Math.PI, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // 火星纹理：红色、极冠、暗区
        function createMarsTexture(ctx) {
            // 基础红色
            const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            gradient.addColorStop(0, '#cd5c5c');
            gradient.addColorStop(1, '#8b3a3a');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // 暗色区域（古代海洋）
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const radius = Math.random() * 80 + 40;
                
                ctx.fillStyle = `rgba(100, 50, 40, ${0.3 + Math.random() * 0.3})`;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // 极冠（白色）
            const polarGradient1 = ctx.createRadialGradient(256, 50, 0, 256, 50, 60);
            polarGradient1.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            polarGradient1.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = polarGradient1;
            ctx.beginPath();
            ctx.arc(256, 50, 60, 0, Math.PI * 2);
            ctx.fill();
            
            const polarGradient2 = ctx.createRadialGradient(256, 462, 0, 256, 462, 60);
            polarGradient2.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            polarGradient2.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = polarGradient2;
            ctx.beginPath();
            ctx.arc(256, 462, 60, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // 木星纹理：条纹、大红斑
        function createJupiterTexture(ctx) {
            // 绘制条纹
            const stripes = 20;
            for (let i = 0; i < stripes; i++) {
                const y = (i / stripes) * 512;
                const height = 512 / stripes;
                
                // 交替颜色
                const colors = ['#c9b791', '#b8926a', '#dcc8a0', '#a67c52'];
                ctx.fillStyle = colors[i % colors.length];
                ctx.fillRect(0, y, 512, height);
                
                // 添加噪点
                for (let j = 0; j < 100; j++) {
                    const x = Math.random() * 512;
                    const py = y + Math.random() * height;
                    ctx.fillStyle = `rgba(${180 + Math.random() * 50}, ${140 + Math.random() * 50}, ${100 + Math.random() * 40}, 0.3)`;
                    ctx.fillRect(x, py, 3, 3);
                }
            }
            
            // 大红斑
            const spotX = 380;
            const spotY = 300;
            const spotGradient = ctx.createRadialGradient(spotX, spotY, 0, spotX, spotY, 50);
            spotGradient.addColorStop(0, '#d4645c');
            spotGradient.addColorStop(0.5, '#b85450');
            spotGradient.addColorStop(1, 'rgba(184, 84, 80, 0)');
            ctx.fillStyle = spotGradient;
            ctx.beginPath();
            ctx.ellipse(spotX, spotY, 60, 40, 0.3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // 土星纹理：淡黄色条纹
        function createSaturnTexture(ctx) {
            // 绘制条纹
            const stripes = 25;
            for (let i = 0; i < stripes; i++) {
                const y = (i / stripes) * 512;
                const height = 512 / stripes;
                
                // 淡黄色调
                const brightness = 220 + Math.random() * 35;
                ctx.fillStyle = `rgb(${brightness}, ${brightness - 20}, ${brightness - 40})`;
                ctx.fillRect(0, y, 512, height);
            }
        }
        
        // 天王星纹理：青色
        function createUranusTexture(ctx) {
            const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            gradient.addColorStop(0, '#b0e0e6');
            gradient.addColorStop(1, '#5f9ea0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // 淡淡的云层
            for (let i = 0; i < 50; i++) {
                const y = Math.random() * 512;
                ctx.fillStyle = `rgba(160, 200, 210, ${0.1 + Math.random() * 0.2})`;
                ctx.fillRect(0, y, 512, Math.random() * 20 + 5);
            }
        }
        
        // 海王星纹理：深蓝色
        function createNeptuneTexture(ctx) {
            const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            gradient.addColorStop(0, '#4169e1');
            gradient.addColorStop(1, '#191970');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // 深色风暴
            for (let i = 0; i < 10; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const radius = Math.random() * 40 + 20;
                
                const stormGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                stormGradient.addColorStop(0, 'rgba(25, 25, 112, 0.6)');
                stormGradient.addColorStop(1, 'rgba(25, 25, 112, 0)');
                ctx.fillStyle = stormGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // 创建月球纹理
        function createMoonTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // 基础灰色
            const gradient = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            gradient.addColorStop(0, '#c0c0c0');
            gradient.addColorStop(1, '#808080');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // 环形山（陨石坑）
            for (let i = 0; i < 200; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const radius = Math.random() * 30 + 5;
                
                // 外环
                const craterGradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                craterGradient.addColorStop(0, '#606060');
                craterGradient.addColorStop(0.6, '#909090');
                craterGradient.addColorStop(0.8, '#b0b0b0');
                craterGradient.addColorStop(1, '#808080');
                ctx.fillStyle = craterGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // 中心凹陷
                ctx.fillStyle = '#505050';
                ctx.beginPath();
                ctx.arc(x, y, radius * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // 月海（暗色区域）
            for (let i = 0; i < 15; i++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                const radius = Math.random() * 100 + 50;
                
                ctx.fillStyle = `rgba(70, 70, 70, ${0.3 + Math.random() * 0.3})`;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        const sphereParticleTexture = createSphereTexture();
        
        // 相机参数
        const cameraPositions = {
            galaxy: { position: new THREE.Vector3(0, 50, 100), target: new THREE.Vector3(0, 0, 0) },
            solar: { position: new THREE.Vector3(0, 20, 40), target: new THREE.Vector3(0, 0, 0) },
            earth: { position: new THREE.Vector3(0, 0, 10), target: new THREE.Vector3(0, 0, 0) }
        };
        
        // 转速控制变量
        let galaxyRotationSpeed = 1.0;
        let solarRotationSpeed = 0.25;
        
        // 地球相关变量（从原始地球模型整合）
        let earth, clouds, earthGroup;
        let isRotating = true;
        let rotationSpeed = 0.25; // 初始转速设置为25%
        let showCities = true, showPeaks = true, showLakes = true, showRivers = true;
        let showEquator = false, showTropic = false, showTonLat = false, showArcAnt = false, showNames = false;
        let citiesGroup, peaksGroup, lakesGroup, riversGroup, equatorGroup, tropicGroup, arcAntGroup, latLonGroup, timezoneLabelsGroup, bordersGroup;
        let namesGroup;
        // 存储所有标签引用,用于语言切换时更新
        let cityLabels = [], peakLabels = [], lakeLabels = [], riverLabels = [];
        // ===== 初始化 =====
        function init() {
            const container = document.getElementById('universe-container');
            
            // 场景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            
            // 相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.copy(cameraPositions.galaxy.position);
            
            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            
            // 控制器
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 500;
            
            // 光源
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 3, 5);
            scene.add(directionalLight);
            
            // 射线检测
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // 添加事件监听
            container.addEventListener('mousemove', onMouseMove);
            container.addEventListener('click', onClick);
            window.addEventListener('resize', onWindowResize);
            
            // 创建宇宙层级
            createGalaxy();
            createSolarSystem();
            createEarthSystem(); // 这将包含完整的地球模型
            
            // 隐藏加载界面
            document.getElementById('loading').style.display = 'none';
            
            // 设置银河系层级控制（初始化时调用）
            setupGalaxyControls();
            
            // 开始动画
            animate();
            
            // 更新导航按钮显示
            updateNavButtons();
        }
        
        // ===== 银河系创建 =====
        function createGalaxy() {
            galaxy = new THREE.Group();

            // 创建《星际穿越》风格的黑洞模型 - 三维立体版
            const blackHoleGroup = new THREE.Group();

            // 1. 事件视界（Event Horizon）- 纯黑色球体，绝对黑暗
            const eventHorizonGeometry = new THREE.SphereGeometry(5, 128, 128);
            const eventHorizonMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: false,
                opacity: 1.0
            });
            const eventHorizon = new THREE.Mesh(eventHorizonGeometry, eventHorizonMaterial);
            blackHoleGroup.add(eventHorizon);

            // 2. 光子球层（Photon Sphere）- 最靠近事件视界的极亮光环
            const photonSphereGeometry = new THREE.RingGeometry(5.5, 6.5, 128);
            const photonSphereMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const photonSphere = new THREE.Mesh(photonSphereGeometry, photonSphereMaterial);
            photonSphere.rotation.x = Math.PI / 2;
            blackHoleGroup.add(photonSphere);

            // 3. 三维扭曲吸积盘 - 内盘（最热区域）
            function createTwistedDisk(innerRadius, outerRadius, color, opacity, tiltAngle) {
                const segments = 256;
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];
                
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    for (let j = 0; j <= 32; j++) {
                        const radius = innerRadius + (outerRadius - innerRadius) * (j / 32);
                        // 根据角度添加高度变化，创建扭曲效果
                        const heightOffset = Math.sin(angle * 2) * radius * 0.08;
                        const x = Math.cos(angle) * radius;
                        const y = heightOffset;
                        const z = Math.sin(angle) * radius;
                        
                        positions.push(x, y, z);
                        
                        // 根据半径调整颜色亮度
                        const brightness = 1 - (j / 32) * 0.3;
                        const c = new THREE.Color(color);
                        c.multiplyScalar(brightness);
                        colors.push(c.r, c.g, c.b);
                    }
                }
                
                const indices = [];
                for (let i = 0; i < segments; i++) {
                    for (let j = 0; j < 32; j++) {
                        const a = i * 33 + j;
                        const b = i * 33 + j + 1;
                        const c = (i + 1) * 33 + j + 1;
                        const d = (i + 1) * 33 + j;
                        
                        indices.push(a, b, d);
                        indices.push(b, c, d);
                    }
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();
                
                const material = new THREE.MeshBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: opacity,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = tiltAngle;
                return mesh;
            }
            
            const innerDisk = createTwistedDisk(6.8, 11, 0xffddaa, 1.0, Math.PI / 2.2);
            blackHoleGroup.add(innerDisk);

            const mainDisk = createTwistedDisk(11, 17, 0xffaa44, 0.95, Math.PI / 2.1);
            blackHoleGroup.add(mainDisk);

            const outerDisk = createTwistedDisk(17, 26, 0xff9933, 0.75, Math.PI / 2);
            blackHoleGroup.add(outerDisk);

            // 4. 三维吸积粒子流 - 模拟物质螺旋落入黑洞（增强版）
            const accretionParticleCount = 8000; // 从3000增加到8000
            const accretionGeometry = new THREE.BufferGeometry();
            const accretionPositions = new Float32Array(accretionParticleCount * 3);
            const accretionColors = new Float32Array(accretionParticleCount * 3);
            const accretionAngles = new Float32Array(accretionParticleCount);
            const accretionRadii = new Float32Array(accretionParticleCount);
            const accretionHeights = new Float32Array(accretionParticleCount);
            
            for (let i = 0; i < accretionParticleCount; i++) {
                const radius = 7 + Math.random() * 25;
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * radius * 0.3;
                
                accretionAngles[i] = angle;
                accretionRadii[i] = radius;
                accretionHeights[i] = height;
                
                accretionPositions[i * 3] = Math.cos(angle) * radius;
                accretionPositions[i * 3 + 1] = height;
                accretionPositions[i * 3 + 2] = Math.sin(angle) * radius;
                
                // 内部更亮
                const brightness = 1 - (radius / 32);
                const c = new THREE.Color(0xffaa44);
                c.multiplyScalar(brightness * 1.5);
                accretionColors[i * 3] = c.r;
                accretionColors[i * 3 + 1] = c.g;
                accretionColors[i * 3 + 2] = c.b;
            }
            
            accretionGeometry.setAttribute('position', new THREE.Float32BufferAttribute(accretionPositions, 3));
            accretionGeometry.setAttribute('color', new THREE.Float32BufferAttribute(accretionColors, 3));
            accretionGeometry.userData = {
                angles: accretionAngles,
                radii: accretionRadii,
                heights: accretionHeights
            };
            
            const accretionMaterial = new THREE.PointsMaterial({
                size: 1.0, // 稍微增大以配合球型纹理
                vertexColors: true,
                transparent: true,
                opacity: 0.85,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                map: sphereParticleTexture, // 使用球型纹理
                alphaTest: 0.01
            });
            
            const accretionParticles = new THREE.Points(accretionGeometry, accretionMaterial);
            blackHoleGroup.add(accretionParticles);

            // 5. 引力透镜三维光环 - 更多层次的环形结构
            for (let i = 0; i < 5; i++) {
                const radius = 8 + i * 1.5;
                const yPos = 3 + i * 0.8;
                const lensingGeometry = new THREE.TorusGeometry(radius, 0.8 - i * 0.1, 16, 100);
                const lensingMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffcc66,
                    transparent: true,
                    opacity: 0.4 - i * 0.06,
                    blending: THREE.AdditiveBlending
                });
                const lensingRing = new THREE.Mesh(lensingGeometry, lensingMaterial);
                lensingRing.position.y = yPos;
                lensingRing.rotation.x = Math.PI * 0.1 * i;
                blackHoleGroup.add(lensingRing);
                
                // 添加下方对称环
                const lensingRingBottom = lensingRing.clone();
                lensingRingBottom.position.y = -yPos;
                lensingRingBottom.rotation.x = -Math.PI * 0.1 * i;
                blackHoleGroup.add(lensingRingBottom);
            }

            // 6. 三维喷流粒子系统（增强版 - 更长更壮观）
            function createJetParticles(direction) {
                const jetParticleCount = 6000; // 从4000增加到6000
                const jetGeometry = new THREE.BufferGeometry();
                const jetPositions = new Float32Array(jetParticleCount * 3);
                const jetColors = new Float32Array(jetParticleCount * 3);
                const jetSpeeds = new Float32Array(jetParticleCount);
                const jetSizes = new Float32Array(jetParticleCount); // 新增：存储粒子大小
                
                for (let i = 0; i < jetParticleCount; i++) {
                    const height = Math.random() * 80; // 从35增加到80，增加长度
                    // 锥形喷流：底部细，顶部逐渐扩散
                    const baseRadius = 0.3;
                    const topRadius = 5;
                    const radius = baseRadius + (height / 80) * topRadius;
                    const angle = Math.random() * Math.PI * 2;
                    
                    // 添加径向偏移，使喷流更自然
                    const radialVariation = (Math.random() - 0.5) * radius * 0.3;
                    const finalRadius = radius + radialVariation;
                    
                    jetPositions[i * 3] = Math.cos(angle) * finalRadius;
                    jetPositions[i * 3 + 1] = height * direction;
                    jetPositions[i * 3 + 2] = Math.sin(angle) * finalRadius;
                    
                    jetSpeeds[i] = 0.3 + Math.random() * 1.2;
                    
                    // 粒子大小随高度变化
                    jetSizes[i] = 1.2 + (height / 80) * 0.8;
                    
                    // 颜色渐变：底部亮蓝白色，顶部暗蓝色
                    const brightness = 1.2 - (height / 80) * 0.8;
                    const hue = 0.55 + (height / 80) * 0.05; // 从青蓝到深蓝
                    const c = new THREE.Color();
                    c.setHSL(hue, 0.8, brightness * 0.6);
                    jetColors[i * 3] = c.r;
                    jetColors[i * 3 + 1] = c.g;
                    jetColors[i * 3 + 2] = c.b;
                }
                
                jetGeometry.setAttribute('position', new THREE.Float32BufferAttribute(jetPositions, 3));
                jetGeometry.setAttribute('color', new THREE.Float32BufferAttribute(jetColors, 3));
                jetGeometry.userData = { 
                    speeds: jetSpeeds, 
                    direction: direction,
                    sizes: jetSizes
                };
                
                const jetMaterial = new THREE.PointsMaterial({
                    size: 1.8, // 增大基础粒子大小
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.75,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false,
                    map: sphereParticleTexture,
                    alphaTest: 0.01
                });
                
                return new THREE.Points(jetGeometry, jetMaterial);
            }
            
            const jetTop = createJetParticles(1);
            blackHoleGroup.add(jetTop);
            
            const jetBottom = createJetParticles(-1);
            blackHoleGroup.add(jetBottom);
            
            // 6.5 喷流核心光柱 - 增强喷流中心
            function createJetCore(direction) {
                const coreGeometry = new THREE.CylinderGeometry(0.2, 1.5, 70, 16, 1, true);
                const coreMaterial = new THREE.MeshBasicMaterial({
                    color: 0xaaddff,
                    transparent: true,
                    opacity: 0.5,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });
                const core = new THREE.Mesh(coreGeometry, coreMaterial);
                core.position.y = 35 * direction;
                return core;
            }
            
            const jetCoreTop = createJetCore(1);
            blackHoleGroup.add(jetCoreTop);
            
            const jetCoreBottom = createJetCore(-1);
            blackHoleGroup.add(jetCoreBottom);

            // 7. 体积雾效果 - 增强深度感
            const fogSphereCount = 8;
            for (let i = 0; i < fogSphereCount; i++) {
                const radius = 8 + i * 4;
                const fogGeometry = new THREE.SphereGeometry(radius, 32, 32);
                const fogMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff8844,
                    transparent: true,
                    opacity: 0.03 - i * 0.003,
                    side: THREE.BackSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const fogSphere = new THREE.Mesh(fogGeometry, fogMaterial);
                blackHoleGroup.add(fogSphere);
            }

            // 8. 外部光晕（弱引力场效应）
            const outerHaloGeometry = new THREE.RingGeometry(28, 45, 128);
            const outerHaloMaterial = new THREE.MeshBasicMaterial({
                color: 0xffaa66,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            const outerHalo = new THREE.Mesh(outerHaloGeometry, outerHaloMaterial);
            outerHalo.rotation.x = Math.PI / 2;
            blackHoleGroup.add(outerHalo);

            galaxy.add(blackHoleGroup);
            
            // 创建银河盘面的星星（大幅增加数量以模拟真实银河系）
            const starCount = 25000; // 从15000增加到25000
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = new Float32Array(starCount * 3);
            const starColors = new Float32Array(starCount * 3);
            const starDistances = new Float32Array(starCount); // 存储每颗恒星的距离
            const starAngles = new Float32Array(starCount); // 存储每颗恒星的当前角度
            const starOffsets = new Float32Array(starCount * 2); // 存储每颗恒星的随机偏移（保持相对位置）

            for (let i = 0; i < starCount; i++) {
                const armIndex = Math.floor(Math.random() * 4);
                const armAngle = (armIndex * Math.PI * 2) / 4;
                const radius = Math.random() * 80 + 10;
                const spiralAngle = armAngle + radius * 0.1;

                const offsetX = (Math.random() - 0.5) * 10;
                const offsetZ = (Math.random() - 0.5) * 10;

                const x = Math.cos(spiralAngle) * radius + offsetX;
                const z = Math.sin(spiralAngle) * radius + offsetZ;
                const y = (Math.random() - 0.5) * 5;

                starPositions[i * 3] = x;
                starPositions[i * 3 + 1] = y;
                starPositions[i * 3 + 2] = z;

                // 存储距离（用于开普勒旋转）
                starDistances[i] = radius;
                // 存储初始角度
                starAngles[i] = spiralAngle;
                // 存储偏移量，保持相对位置
                starOffsets[i * 2] = offsetX;
                starOffsets[i * 2 + 1] = offsetZ;

                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.2 + 0.5, 0.5, Math.random() * 0.5 + 0.5);
                starColors[i * 3] = color.r;
                starColors[i * 3 + 1] = color.g;
                starColors[i * 3 + 2] = color.b;
            }

            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
            starGeometry.userData = {
                distances: starDistances,
                angles: starAngles,
                offsets: starOffsets
            };
            
            const starMaterial = new THREE.PointsMaterial({
                size: 0.6, // 稍微增大一点
                vertexColors: true,
                transparent: true,
                opacity: 0.85,
                map: sphereParticleTexture, // 使用统一的球型纹理
                blending: THREE.AdditiveBlending,
                alphaTest: 0.01
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            galaxy.add(stars);

            // 添加太阳系标记（黄色）
            const solarSystemMarker = createMarker(
                new THREE.Vector3(60, 0, 20),
                0xffff00,  // 黄色
                '太阳系',
                'solar'
            );
            galaxy.add(solarSystemMarker);

            scene.add(galaxy);
        }
        
        // ===== 太阳系创建 =====
        function createSolarSystem() {
            solarSystem = new THREE.Group();
            solarSystem.visible = false;
            
            // 创建太阳系层级星空背景
            createSolarStarfieldBackground();
            
            // ===== 创建真实太阳系统 =====
            const sunGroup = new THREE.Group();
            
            // 1. 太阳核心（光球层）
            const sunGeometry = new THREE.SphereGeometry(3, 64, 64);
            const sunMaterial = new THREE.MeshBasicMaterial({
                color: 0xfff5e6,
                transparent: true,
                opacity: 1.0
            });
            const sun = new THREE.Mesh(sunGeometry, sunMaterial);
            sunGroup.add(sun);
            
            // 2. 太阳表面纹理层（模拟对流层和颗粒结构）
            const surfaceGeometry = new THREE.SphereGeometry(3.05, 64, 64);
            const surfaceMaterial = new THREE.MeshBasicMaterial({
                color: 0xffdd66,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            const surface = new THREE.Mesh(surfaceGeometry, surfaceMaterial);
            sunGroup.add(surface);
            
            // 3. 多层日冕（Corona）- 7层渐变光晕
            const coronaLayers = [
                { radius: 3.3, color: 0xffcc44, opacity: 0.4 },
                { radius: 3.6, color: 0xffaa33, opacity: 0.35 },
                { radius: 4.0, color: 0xff9922, opacity: 0.3 },
                { radius: 4.5, color: 0xff8811, opacity: 0.25 },
                { radius: 5.2, color: 0xff7700, opacity: 0.18 },
                { radius: 6.0, color: 0xff6600, opacity: 0.12 },
                { radius: 7.0, color: 0xff5500, opacity: 0.08 }
            ];
            
            coronaLayers.forEach((layer, index) => {
                const coronaGeometry = new THREE.SphereGeometry(layer.radius, 32, 32);
                const coronaMaterial = new THREE.MeshBasicMaterial({
                    color: layer.color,
                    transparent: true,
                    opacity: layer.opacity,
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide,
                    depthWrite: false
                });
                const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
                corona.userData.layerIndex = index;
                sunGroup.add(corona);
            });
            
            // 4. 太阳黑子粒子系统（表面暗斑）
            const sunspotCount = 200;
            const sunspotGeometry = new THREE.BufferGeometry();
            const sunspotPositions = new Float32Array(sunspotCount * 3);
            const sunspotColors = new Float32Array(sunspotCount * 3);
            
            for (let i = 0; i < sunspotCount; i++) {
                // 在球面上均匀分布
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 3.02;
                
                sunspotPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                sunspotPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                sunspotPositions[i * 3 + 2] = radius * Math.cos(phi);
                
                const c = new THREE.Color(0x442200);
                sunspotColors[i * 3] = c.r;
                sunspotColors[i * 3 + 1] = c.g;
                sunspotColors[i * 3 + 2] = c.b;
            }
            
            sunspotGeometry.setAttribute('position', new THREE.BufferAttribute(sunspotPositions, 3));
            sunspotGeometry.setAttribute('color', new THREE.BufferAttribute(sunspotColors, 3));
            
            const sunspotMaterial = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                map: sphereParticleTexture,
                blending: THREE.NormalBlending
            });
            
            const sunspots = new THREE.Points(sunspotGeometry, sunspotMaterial);
            sunGroup.add(sunspots);
            
            // 5. 太阳耀斑粒子系统（表面活动区）
            const flareCount = 800;
            const flareGeometry = new THREE.BufferGeometry();
            const flarePositions = new Float32Array(flareCount * 3);
            const flareColors = new Float32Array(flareCount * 3);
            const flareAngles = new Float32Array(flareCount * 2); // theta, phi
            
            for (let i = 0; i < flareCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 3.08 + Math.random() * 0.3;
                
                flareAngles[i * 2] = theta;
                flareAngles[i * 2 + 1] = phi;
                
                flarePositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                flarePositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                flarePositions[i * 3 + 2] = radius * Math.cos(phi);
                
                const brightness = 0.8 + Math.random() * 0.4;
                const c = new THREE.Color(0xffff88);
                c.multiplyScalar(brightness);
                flareColors[i * 3] = c.r;
                flareColors[i * 3 + 1] = c.g;
                flareColors[i * 3 + 2] = c.b;
            }
            
            flareGeometry.setAttribute('position', new THREE.BufferAttribute(flarePositions, 3));
            flareGeometry.setAttribute('color', new THREE.BufferAttribute(flareColors, 3));
            flareGeometry.userData = { angles: flareAngles };
            
            const flareMaterial = new THREE.PointsMaterial({
                size: 0.4,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                map: sphereParticleTexture,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const flares = new THREE.Points(flareGeometry, flareMaterial);
            sunGroup.add(flares);
            
            // 6. 日珥（Prominences）- 从太阳表面喷发的火焰弧
            function createProminence(angle, height) {
                const prominenceParticles = 150;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(prominenceParticles * 3);
                const colors = new Float32Array(prominenceParticles * 3);
                const speeds = new Float32Array(prominenceParticles);
                
                for (let i = 0; i < prominenceParticles; i++) {
                    const t = i / prominenceParticles;
                    const arcHeight = Math.sin(t * Math.PI) * height;
                    const radius = 3 + arcHeight;
                    
                    const theta = angle + (Math.random() - 0.5) * 0.3;
                    const phi = Math.PI / 2 + (t - 0.5) * 0.8;
                    
                    positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                    positions[i * 3 + 2] = radius * Math.cos(phi);
                    
                    speeds[i] = Math.random() * 0.02;
                    
                    const brightness = 1.2 - t * 0.5;
                    const c = new THREE.Color(0xff6633);
                    c.multiplyScalar(brightness);
                    colors[i * 3] = c.r;
                    colors[i * 3 + 1] = c.g;
                    colors[i * 3 + 2] = c.b;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.userData = { angle: angle, speeds: speeds };
                
                const material = new THREE.PointsMaterial({
                    size: 0.5,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    map: sphereParticleTexture,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                return new THREE.Points(geometry, material);
            }
            
            // 创建4-6个日珥
            const prominenceCount = 5;
            for (let i = 0; i < prominenceCount; i++) {
                const angle = (i / prominenceCount) * Math.PI * 2 + Math.random() * 0.5;
                const height = 1.5 + Math.random() * 1.0;
                const prominence = createProminence(angle, height);
                sunGroup.add(prominence);
            }
            
            // 7. 太阳风粒子流（向外辐射）
            const solarWindCount = 2000;
            const solarWindGeometry = new THREE.BufferGeometry();
            const solarWindPositions = new Float32Array(solarWindCount * 3);
            const solarWindColors = new Float32Array(solarWindCount * 3);
            const solarWindSpeeds = new Float32Array(solarWindCount);
            
            for (let i = 0; i < solarWindCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 3.5 + Math.random() * 8;
                
                solarWindPositions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                solarWindPositions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                solarWindPositions[i * 3 + 2] = radius * Math.cos(phi);
                
                solarWindSpeeds[i] = 0.02 + Math.random() * 0.03;
                
                const brightness = 1 - (radius / 11.5) * 0.7;
                const c = new THREE.Color(0xffcc88);
                c.multiplyScalar(brightness);
                solarWindColors[i * 3] = c.r;
                solarWindColors[i * 3 + 1] = c.g;
                solarWindColors[i * 3 + 2] = c.b;
            }
            
            solarWindGeometry.setAttribute('position', new THREE.BufferAttribute(solarWindPositions, 3));
            solarWindGeometry.setAttribute('color', new THREE.BufferAttribute(solarWindColors, 3));
            solarWindGeometry.userData = { speeds: solarWindSpeeds };
            
            const solarWindMaterial = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                map: sphereParticleTexture,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const solarWind = new THREE.Points(solarWindGeometry, solarWindMaterial);
            sunGroup.add(solarWind);
            
            // 将太阳组添加到太阳系
            solarSystem.add(sunGroup);
            
            // 创建行星
            const planetData = [
                { name: '水星', englishName: 'Mercury', distance: 8, size: 0.3, color: 0x888888 },
                { name: '金星', englishName: 'Venus', distance: 12, size: 0.5, color: 0xffff88 },
                { name: '地球', englishName: 'Earth', distance: 16, size: 0.6, color: 0x4488ff },
                { name: '火星', englishName: 'Mars', distance: 20, size: 0.4, color: 0xff4444 },
                { name: '木星', englishName: 'Jupiter', distance: 28, size: 1.5, color: 0xffaa44 },
                { name: '土星', englishName: 'Saturn', distance: 36, size: 1.2, color: 0xffdd88 },
                { name: '天王星', englishName: 'Uranus', distance: 44, size: 0.8, color: 0x44ffff },
                { name: '海王星', englishName: 'Neptune', distance: 52, size: 0.8, color: 0x4444ff }
            ];
            
            planetData.forEach((data, index) => {
                // 行星轨道
                const orbitGeometry = new THREE.RingGeometry(data.distance - 0.05, data.distance + 0.05, 64);
                const orbitMaterial = new THREE.MeshBasicMaterial({
                    color: 0x444444,
                    transparent: true,
                    opacity: 0.3,
                    side: THREE.DoubleSide
                });
                const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
                orbit.rotation.x = Math.PI / 2;
                solarSystem.add(orbit);
                
                // 行星 - 使用更高分辨率
                const planetGeometry = new THREE.SphereGeometry(data.size, 64, 64);

                let planetMaterial;
                if (data.name === '地球' || data.englishName === 'Earth') {
                    // 地球使用NASA高质量纹理
                    const textureLoader = new THREE.TextureLoader();
                    const earthTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_atmos_2048.jpg');
                    const specularTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg');
                    const normalTexture = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg');

                    planetMaterial = new THREE.MeshPhongMaterial({
                        map: earthTexture,
                        specularMap: specularTexture,
                        specular: new THREE.Color(0x666666),
                        shininess: 10,
                        normalMap: normalTexture,
                        normalScale: new THREE.Vector2(0.85, 0.85)
                    });
                } else {
                    // 其他行星使用程序化纹理
                    const planetTexture = createPlanetTexture(data.name);
                    planetMaterial = new THREE.MeshPhongMaterial({
                        map: planetTexture,
                        shininess: 5,
                        specular: new THREE.Color(0x333333)
                    });
                    
                    // 为气态巨行星添加轻微透明度
                    if (data.name === '木星' || data.name === '土星' || 
                        data.name === '天王星' || data.name === '海王星' ||
                        data.englishName === 'Jupiter' || data.englishName === 'Saturn' || 
                        data.englishName === 'Uranus' || data.englishName === 'Neptune') {
                        planetMaterial.transparent = true;
                        planetMaterial.opacity = 0.95;
                    }
                }

                const planet = new THREE.Mesh(planetGeometry, planetMaterial);
                planet.position.x = data.distance;
                planet.userData = {
                    name: data.name,
                    englishName: data.englishName,
                    type: 'planet',
                    distance: data.distance,
                    angle: Math.random() * Math.PI * 2,
                    rotationSpeed: 0.05 // 默认自转速度
                };

                if (data.name === '地球' || data.englishName === 'Earth') {
                    planet.userData.isEarth = true;
                }

                planets.push(planet);
                solarSystem.add(planet);
                
                // 为土星添加光环
                if (data.name === '土星' || data.englishName === 'Saturn') {
                    createSaturnRings(planet, data.size);
                }
            });
            
            // 创建土星光环
            function createSaturnRings(planet, planetSize) {
                const ringGeometry = new THREE.RingGeometry(planetSize * 1.3, planetSize * 2.0, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xc9b587,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                const rings = new THREE.Mesh(ringGeometry, ringMaterial);
                rings.rotation.x = Math.PI / 2.2; // 稍微倾斜
                planet.add(rings);
            }
            
            // 添加月球（围绕地球）- 使用纹理
            const moonGeometry = new THREE.SphereGeometry(0.15, 32, 32);
            const moonTexture = createMoonTexture();
            const moonMaterial = new THREE.MeshPhongMaterial({
                map: moonTexture,
                shininess: 5
            });
            moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.userData = {
                name: '月球',
                englishName: 'Moon',
                type: 'moon',
                distance: 1.5,
                angle: 0
            };
            solarSystem.add(moon);
            
            // 添加小行星带（在火星和木星之间）
            createAsteroidBelt();

            // 添加彗星系统（在太阳系外围运行）
            createComets();

            // 添加柯伊伯带（海王星轨道之外）
            createKuiperBelt();

            // 添加奥尔特云（太阳系最外围）
            createOortCloud();

            scene.add(solarSystem);
        }
        
        // 创建小行星带（增强版）
        function createAsteroidBelt() {
            const innerRadius = 22;
            const outerRadius = 26;
            
            // 1. 创建大型小行星（使用不规则网格）
            const largeAsteroidCount = 50;
            for (let i = 0; i < largeAsteroidCount; i++) {
                const asteroid = createIrregularAsteroid();
                
                // 随机位置在小行星带区域
                const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 2;
                
                asteroid.position.x = Math.cos(angle) * radius;
                asteroid.position.z = Math.sin(angle) * radius;
                asteroid.position.y = height;
                
                // 随机旋转
                asteroid.rotation.x = Math.random() * Math.PI * 2;
                asteroid.rotation.y = Math.random() * Math.PI * 2;
                asteroid.rotation.z = Math.random() * Math.PI * 2;
                
                asteroid.userData = {
                    type: 'asteroid',
                    size: 'large',
                    distance: radius,
                    angle: angle,
                    speed: Math.random() * 0.008 + 0.004,
                    rotationSpeedX: (Math.random() - 0.5) * 0.02,
                    rotationSpeedY: (Math.random() - 0.5) * 0.02,
                    rotationSpeedZ: (Math.random() - 0.5) * 0.02
                };
                
                asteroidBelt.push(asteroid);
                solarSystem.add(asteroid);
            }
            
            // 2. 创建中型小行星群（简单球体）
            const mediumAsteroidCount = 150;
            for (let i = 0; i < mediumAsteroidCount; i++) {
                const size = Math.random() * 0.08 + 0.04;
                const asteroidGeometry = new THREE.SphereGeometry(size, 8, 8);
                
                // 随机变形
                const positions = asteroidGeometry.attributes.position.array;
                for (let j = 0; j < positions.length; j += 3) {
                    const scale = 0.7 + Math.random() * 0.6;
                    positions[j] *= scale;
                    positions[j + 1] *= scale;
                    positions[j + 2] *= scale;
                }
                asteroidGeometry.computeVertexNormals();
                
                const asteroidMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(0.08 + Math.random() * 0.05, 0.3, 0.3 + Math.random() * 0.2),
                    shininess: 5,
                    flatShading: true
                });
                const asteroid = new THREE.Mesh(asteroidGeometry, asteroidMaterial);
                
                const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 2.5;
                
                asteroid.position.x = Math.cos(angle) * radius;
                asteroid.position.z = Math.sin(angle) * radius;
                asteroid.position.y = height;
                
                asteroid.rotation.x = Math.random() * Math.PI * 2;
                asteroid.rotation.y = Math.random() * Math.PI * 2;
                
                asteroid.userData = {
                    type: 'asteroid',
                    size: 'medium',
                    distance: radius,
                    angle: angle,
                    speed: Math.random() * 0.01 + 0.005,
                    rotationSpeedX: (Math.random() - 0.5) * 0.03,
                    rotationSpeedY: (Math.random() - 0.5) * 0.03
                };
                
                asteroidBelt.push(asteroid);
                solarSystem.add(asteroid);
            }
            
            // 3. 创建小行星尘埃云（粒子系统）
            const dustParticleCount = 3000;
            const dustGeometry = new THREE.BufferGeometry();
            const dustPositions = new Float32Array(dustParticleCount * 3);
            const dustColors = new Float32Array(dustParticleCount * 3);
            const dustAngles = new Float32Array(dustParticleCount);
            const dustRadii = new Float32Array(dustParticleCount);
            
            for (let i = 0; i < dustParticleCount; i++) {
                const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 3;
                
                dustAngles[i] = angle;
                dustRadii[i] = radius;
                
                dustPositions[i * 3] = Math.cos(angle) * radius;
                dustPositions[i * 3 + 1] = height;
                dustPositions[i * 3 + 2] = Math.sin(angle) * radius;
                
                // 褐色尘埃
                const brightness = 0.3 + Math.random() * 0.3;
                const c = new THREE.Color().setHSL(0.08, 0.4, brightness);
                dustColors[i * 3] = c.r;
                dustColors[i * 3 + 1] = c.g;
                dustColors[i * 3 + 2] = c.b;
            }
            
            dustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
            dustGeometry.setAttribute('color', new THREE.BufferAttribute(dustColors, 3));
            dustGeometry.userData = {
                angles: dustAngles,
                radii: dustRadii
            };
            
            const dustMaterial = new THREE.PointsMaterial({
                size: 0.15,
                vertexColors: true,
                transparent: true,
                opacity: 0.4,
                map: sphereParticleTexture,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const dustCloud = new THREE.Points(dustGeometry, dustMaterial);
            dustCloud.userData = { type: 'asteroidDust' };
            solarSystem.add(dustCloud);
            asteroidBelt.push(dustCloud); // 添加到数组以便动画
            
            // 4. 创建微小碎片粒子（更密集）
            const debrisParticleCount = 1500;
            const debrisGeometry = new THREE.BufferGeometry();
            const debrisPositions = new Float32Array(debrisParticleCount * 3);
            const debrisColors = new Float32Array(debrisParticleCount * 3);
            const debrisAngles = new Float32Array(debrisParticleCount);
            const debrisRadii = new Float32Array(debrisParticleCount);
            
            for (let i = 0; i < debrisParticleCount; i++) {
                const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 2;
                
                debrisAngles[i] = angle;
                debrisRadii[i] = radius;
                
                debrisPositions[i * 3] = Math.cos(angle) * radius;
                debrisPositions[i * 3 + 1] = height;
                debrisPositions[i * 3 + 2] = Math.sin(angle) * radius;
                
                // 灰褐色
                const brightness = 0.4 + Math.random() * 0.2;
                const c = new THREE.Color().setHSL(0.1, 0.2, brightness);
                debrisColors[i * 3] = c.r;
                debrisColors[i * 3 + 1] = c.g;
                debrisColors[i * 3 + 2] = c.b;
            }
            
            debrisGeometry.setAttribute('position', new THREE.BufferAttribute(debrisPositions, 3));
            debrisGeometry.setAttribute('color', new THREE.BufferAttribute(debrisColors, 3));
            debrisGeometry.userData = {
                angles: debrisAngles,
                radii: debrisRadii
            };
            
            const debrisMaterial = new THREE.PointsMaterial({
                size: 0.08,
                vertexColors: true,
                transparent: true,
                opacity: 0.6,
                map: sphereParticleTexture,
                depthWrite: false
            });
            
            const debrisField = new THREE.Points(debrisGeometry, debrisMaterial);
            debrisField.userData = { type: 'asteroidDebris' };
            solarSystem.add(debrisField);
            asteroidBelt.push(debrisField);
        }
        
        // 创建彗星系统
        function createComets() {
            const cometCount = 1; // 创建1颗彗星

            for (let i = 0; i < cometCount; i++) {
                const cometGroup = new THREE.Group();

                // 1. 彗核（亮白色核心）- 缩小到10%
                const nucleusGeometry = new THREE.SphereGeometry(0.015, 16, 16);
                const nucleusMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    emissive: 0xaaccff,
                    emissiveIntensity: 0.6,
                    shininess: 100
                });
                const nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
                cometGroup.add(nucleus);
                
                // 2. 彗发（气体云，围绕彗核的发光云团）- 缩小到10%
                const comaGeometry = new THREE.SphereGeometry(0.08, 32, 32);
                const comaMaterial = new THREE.MeshBasicMaterial({
                    color: 0x88ccff,
                    transparent: true,
                    opacity: 0.25,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const coma = new THREE.Mesh(comaGeometry, comaMaterial);
                cometGroup.add(coma);
                
                // 3. 内层彗发（更亮）- 缩小到10%
                const innerComaGeometry = new THREE.SphereGeometry(0.04, 32, 32);
                const innerComaMaterial = new THREE.MeshBasicMaterial({
                    color: 0xccddff,
                    transparent: true,
                    opacity: 0.4,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const innerComa = new THREE.Mesh(innerComaGeometry, innerComaMaterial);
                cometGroup.add(innerComa);
                
                // 4. 离子尾（蓝色，笔直指向太阳相反方向）
                // 首先计算彗星轨道参数和初始位置，以便确定彗尾方向
                const semiMajorAxis = 70 + Math.random() * 20; // 半长轴 70-90
                const eccentricity = 0.6 + Math.random() * 0.3; // 离心率 0.6-0.9（高离心率）
                const inclination = (Math.random() - 0.5) * Math.PI * 0.3; // 倾角 ±27度
                const initialAngle = Math.random() * Math.PI * 2; // 初始角度
                
                // 计算初始轨道位置（用于确定彗尾方向）
                const r = semiMajorAxis * (1 - eccentricity * eccentricity) / (1 + eccentricity * Math.cos(initialAngle));
                const orbitX = Math.cos(initialAngle) * r;
                const orbitZ = Math.sin(initialAngle) * r;
                const orbitY = Math.sin(inclination) * orbitZ;
                
                // 彗尾方向：指向远离太阳的方向（太阳在原点）
                const tailDirection = new THREE.Vector3(orbitX, orbitY, orbitZ).normalize().multiplyScalar(-1); // 指向远离太阳的方向（从彗核向外）
                
                const ionTailParticleCount = 500;
                const ionTailGeometry = new THREE.BufferGeometry();
                const ionTailPositions = new Float32Array(ionTailParticleCount * 3);
                const ionTailColors = new Float32Array(ionTailParticleCount * 3);
                const ionTailOpacities = new Float32Array(ionTailParticleCount);
                
                for (let j = 0; j < ionTailParticleCount; j++) {
                    // 尾巴从彗核向后延伸（沿彗尾方向）- 缩小到10%
                    const distance = Math.pow(Math.random(), 0.5) * 2.5; // 2.5单位长度
                    const spread = Math.random() * 0.3 * distance; // 扩散度
                    
                    // 计算沿彗尾方向的基本位置
                    const tailPos = tailDirection.clone().multiplyScalar(distance);
                    
                    // 添加垂直方向的随机扩散
                    const perpendicular = new THREE.Vector3(
                        Math.random() - 0.5,
                        Math.random() - 0.5,
                        Math.random() - 0.5
                    ).cross(tailDirection).normalize().multiplyScalar(spread);
                    
                    ionTailPositions[j * 3] = tailPos.x + perpendicular.x;
                    ionTailPositions[j * 3 + 1] = tailPos.y + perpendicular.y;
                    ionTailPositions[j * 3 + 2] = tailPos.z + perpendicular.z;
                    
                    // 蓝白色离子尾
                    const c = new THREE.Color().setHSL(0.55 + Math.random() * 0.1, 0.8, 0.6 + Math.random() * 0.2);
                    ionTailColors[j * 3] = c.r;
                    ionTailColors[j * 3 + 1] = c.g;
                    ionTailColors[j * 3 + 2] = c.b;
                    
                    // 距离越远越透明
                    ionTailOpacities[j] = 1 - (distance / 2.5) * 0.8;
                }
                
                ionTailGeometry.setAttribute('position', new THREE.BufferAttribute(ionTailPositions, 3));
                ionTailGeometry.setAttribute('color', new THREE.BufferAttribute(ionTailColors, 3));
                ionTailGeometry.setAttribute('opacity', new THREE.BufferAttribute(ionTailOpacities, 1));
                
                const ionTailMaterial = new THREE.PointsMaterial({
                    size: 0.04, // 缩小到10%
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.7,
                    map: sphereParticleTexture,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const ionTail = new THREE.Points(ionTailGeometry, ionTailMaterial);
                ionTail.userData.type = 'ionTail';
                cometGroup.add(ionTail);
                
                // 5. 尘埃尾（黄白色，弯曲扩散）
                const dustTailParticleCount = 600;
                const dustTailGeometry = new THREE.BufferGeometry();
                const dustTailPositions = new Float32Array(dustTailParticleCount * 3);
                const dustTailColors = new Float32Array(dustTailParticleCount * 3);
                const dustTailCurves = new Float32Array(dustTailParticleCount); // 记录弯曲参数
                
                for (let j = 0; j < dustTailParticleCount; j++) {
                    const distance = Math.pow(Math.random(), 0.4) * 3; // 3单位长度（缩小到10%）
                    const spread = Math.random() * 0.5 * distance; // 更大的扩散
                    const curve = Math.random() * 0.3; // 弯曲度
                    
                    dustTailCurves[j] = curve;
                    
                    // 计算沿彗尾方向的基本位置
                    const tailPos = tailDirection.clone().multiplyScalar(distance);
                    
                    // 添加垂直方向的随机扩散和弯曲效果
                    const perpendicular = new THREE.Vector3(
                        Math.random() - 0.5,
                        Math.random() - 0.5,
                        Math.random() - 0.5
                    ).cross(tailDirection).normalize().multiplyScalar(spread);
                    
                    // 弯曲效果：垂直于彗尾方向和垂直方向
                    const bendDirection = new THREE.Vector3(0, 1, 0).cross(tailDirection).normalize();
                    const bendAmount = distance * 0.1 * curve;
                    
                    dustTailPositions[j * 3] = tailPos.x + perpendicular.x + bendDirection.x * bendAmount;
                    dustTailPositions[j * 3 + 1] = tailPos.y + perpendicular.y + bendDirection.y * bendAmount;
                    dustTailPositions[j * 3 + 2] = tailPos.z + perpendicular.z + bendDirection.z * bendAmount;
                    
                    // 黄白色尘埃尾
                    const c = new THREE.Color().setHSL(0.1 + Math.random() * 0.05, 0.5, 0.7 + Math.random() * 0.2);
                    dustTailColors[j * 3] = c.r;
                    dustTailColors[j * 3 + 1] = c.g;
                    dustTailColors[j * 3 + 2] = c.b;
                }
                
                dustTailGeometry.setAttribute('position', new THREE.BufferAttribute(dustTailPositions, 3));
                dustTailGeometry.setAttribute('color', new THREE.BufferAttribute(dustTailColors, 3));
                dustTailGeometry.userData.curves = dustTailCurves;
                
                const dustTailMaterial = new THREE.PointsMaterial({
                    size: 0.05, // 缩小到10%
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.6,
                    map: sphereParticleTexture,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const dustTail = new THREE.Points(dustTailGeometry, dustTailMaterial);
                dustTail.userData.type = 'dustTail';
                cometGroup.add(dustTail);
                
                // 存储轨道参数到彗星组
                cometGroup.userData = {
                    type: 'comet',
                    semiMajorAxis: semiMajorAxis,
                    eccentricity: eccentricity,
                    inclination: inclination,
                    angle: initialAngle,
                    speed: 0.001 + Math.random() * 0.002, // 公转速度
                    rotationSpeed: 0.02 + Math.random() * 0.03, // 彗核自转速度
                    ionTail: ionTail,
                    dustTail: dustTail
                };
                
                comets.push(cometGroup);
                solarSystem.add(cometGroup);

                // 创建彗星的青色轨迹线
                createCometTrajectory(cometGroup, semiMajorAxis, eccentricity, inclination);
            }
        }

        // 创建彗星轨迹线
        function createCometTrajectory(cometGroup, semiMajorAxis, eccentricity, inclination) {
            const segments = 128; // 轨迹线分段数
            const points = [];

            // 计算椭圆轨道上的点
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2; // 0到2π
                const r = semiMajorAxis * (1 - eccentricity * eccentricity) / (1 + eccentricity * Math.cos(angle));
                
                // 计算轨道平面上的点
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                const y = Math.sin(inclination) * z; // 考虑轨道倾角
                
                points.push(new THREE.Vector3(x, y, z));
            }

            // 创建轨迹线几何体
            const trajectoryGeometry = new THREE.BufferGeometry().setFromPoints(points);
            
            // 青色轨迹线材质
            const trajectoryMaterial = new THREE.LineBasicMaterial({
                color: 0x004444, // 青色
                transparent: true,
                opacity: 0.6,
                linewidth: 1
            });

            // 创建轨迹线
            const trajectoryLine = new THREE.Line(trajectoryGeometry, trajectoryMaterial);
            trajectoryLine.userData = { type: 'cometTrajectory' };
            
            // 添加到太阳系
            solarSystem.add(trajectoryLine);
        }
        
        // 创建柯伊伯带（海王星轨道之外的冰体带）
        function createKuiperBelt() {
            const innerRadius = 60; // 约60天文单位（缩放后）
            const outerRadius = 100; // 约100天文单位
            
            // 1. 创建大型柯伊伯带天体（冰质矮行星）
            const largeKBOCount = 20;
            for (let i = 0; i < largeKBOCount; i++) {
                // 使用彗核类似的外观，但更大
                const kboGeometry = new THREE.SphereGeometry(0.04 + Math.random() * 0.03, 16, 16);
                const kboMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(0.6 + Math.random() * 0.1, 0.5, 0.4 + Math.random() * 0.2), // 蓝灰色
                    shininess: 30,
                    specular: new THREE.Color(0x333333)
                });
                const kbo = new THREE.Mesh(kboGeometry, kboMaterial);
                
                // 随机位置在柯伊伯带区域（盘状分布，主要在黄道面附近）
                const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 5; // 轻微垂直分散
                
                kbo.position.x = Math.cos(angle) * radius;
                kbo.position.z = Math.sin(angle) * radius;
                kbo.position.y = height;
                
                // 随机旋转
                kbo.rotation.x = Math.random() * Math.PI * 2;
                kbo.rotation.y = Math.random() * Math.PI * 2;
                
                kbo.userData = {
                    type: 'kuiperBeltObject',
                    size: 'large',
                    distance: radius,
                    angle: angle,
                    speed: (0.002 + Math.random() * 0.002), // 比小行星带慢得多
                    rotationSpeedX: (Math.random() - 0.5) * 0.01,
                    rotationSpeedY: (Math.random() - 0.5) * 0.01
                };
                
                kuiperBelt.push(kbo);
                solarSystem.add(kbo);
            }
            
            // 2. 创建柯伊伯带冰粒云（粒子系统）
            const iceParticleCount = 2000;
            const iceGeometry = new THREE.BufferGeometry();
            const icePositions = new Float32Array(iceParticleCount * 3);
            const iceColors = new Float32Array(iceParticleCount * 3);
            const iceAngles = new Float32Array(iceParticleCount);
            const iceRadii = new Float32Array(iceParticleCount);
            
            for (let i = 0; i < iceParticleCount; i++) {
                const radius = innerRadius + Math.random() * (outerRadius - innerRadius);
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 8; // 柯伊伯带有一定厚度
                
                iceAngles[i] = angle;
                iceRadii[i] = radius;
                
                icePositions[i * 3] = Math.cos(angle) * radius;
                icePositions[i * 3 + 1] = height;
                icePositions[i * 3 + 2] = Math.sin(angle) * radius;
                
                // 冰粒颜色：蓝白色
                const brightness = 0.2 + Math.random() * 0.3;
                const h = 0.6 + Math.random() * 0.1; // 蓝色调
                const s = 0.3 + Math.random() * 0.3;
                const c = new THREE.Color().setHSL(h, s, brightness);
                iceColors[i * 3] = c.r;
                iceColors[i * 3 + 1] = c.g;
                iceColors[i * 3 + 2] = c.b;
            }
            
            iceGeometry.setAttribute('position', new THREE.BufferAttribute(icePositions, 3));
            iceGeometry.setAttribute('color', new THREE.BufferAttribute(iceColors, 3));
            iceGeometry.userData = {
                angles: iceAngles,
                radii: iceRadii
            };
            
            const iceMaterial = new THREE.PointsMaterial({
                size: 0.12,
                vertexColors: true,
                transparent: true,
                opacity: 0.5,
                map: sphereParticleTexture,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const iceCloud = new THREE.Points(iceGeometry, iceMaterial);
            iceCloud.userData = { type: 'kuiperBeltIce' };
            kuiperBelt.push(iceCloud);
            solarSystem.add(iceCloud);
        }
        
        // 创建奥尔特云（太阳系最外围的球形云）
        function createOortCloud() {
            const innerRadius = 150; // 约150天文单位（缩放后）
            const outerRadius = 300; // 约300天文单位
            
            // 创建奥尔特云粒子（球形分布）
            const oortParticleCount = 3000;
            const oortGeometry = new THREE.BufferGeometry();
            const oortPositions = new Float32Array(oortParticleCount * 3);
            const oortColors = new Float32Array(oortParticleCount * 3);
            const oortAngles = new Float32Array(oortParticleCount * 2); // 经度和纬度
            const oortDistances = new Float32Array(oortParticleCount);
            
            for (let i = 0; i < oortParticleCount; i++) {
                // 球面随机分布
                const distance = innerRadius + Math.random() * (outerRadius - innerRadius);
                const theta = Math.random() * Math.PI * 2; // 经度
                const phi = Math.acos(2 * Math.random() - 1); // 纬度
                
                oortAngles[i * 2] = theta;
                oortAngles[i * 2 + 1] = phi;
                oortDistances[i] = distance;
                
                oortPositions[i * 3] = distance * Math.sin(phi) * Math.cos(theta);
                oortPositions[i * 3 + 1] = distance * Math.cos(phi); // Y轴
                oortPositions[i * 3 + 2] = distance * Math.sin(phi) * Math.sin(theta);
                
                // 奥尔特云冰核颜色：非常暗的蓝灰色
                const brightness = 0.1 + Math.random() * 0.15;
                const h = 0.55 + Math.random() * 0.1; // 冷色调
                const s = 0.2 + Math.random() * 0.2;
                const c = new THREE.Color().setHSL(h, s, brightness);
                oortColors[i * 3] = c.r;
                oortColors[i * 3 + 1] = c.g;
                oortColors[i * 3 + 2] = c.b;
            }
            
            oortGeometry.setAttribute('position', new THREE.BufferAttribute(oortPositions, 3));
            oortGeometry.setAttribute('color', new THREE.BufferAttribute(oortColors, 3));
            oortGeometry.userData = {
                angles: oortAngles,
                distances: oortDistances
            };
            
            const oortMaterial = new THREE.PointsMaterial({
                size: 0.08,
                vertexColors: true,
                transparent: true,
                opacity: 0.4,
                map: sphereParticleTexture,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            const oortCloudObj = new THREE.Points(oortGeometry, oortMaterial);
            oortCloudObj.userData = { type: 'oortCloud' };
            oortCloudObj.visible = false; // 默认隐藏，避免遮挡内太阳系
            oortCloudObj.userData.visibleThreshold = 0.3; // 缩放阈值
            oortCloudObj.userData.baseOpacity = 0.4;
            oortCloudObj.userData.baseSize = 0.08;
            oortCloudObj.userData.baseDistance = (innerRadius + outerRadius) / 2;
            
            oortCloud.push(oortCloudObj);
            solarSystem.add(oortCloudObj);
        }
        
        // 创建不规则小行星
        function createIrregularAsteroid() {
            const baseSize = 0.12 + Math.random() * 0.08;
            const geometry = new THREE.DodecahedronGeometry(baseSize, 0);
            
            // 随机变形使其不规则
            const positions = geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const scale = 0.6 + Math.random() * 0.8;
                positions[i] *= scale;
                positions[i + 1] *= scale * (0.7 + Math.random() * 0.6);
                positions[i + 2] *= scale;
            }
            geometry.computeVertexNormals();
            
            // 创建小行星纹理
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // 基础灰褐色
            const baseColor = `rgb(${100 + Math.random() * 40}, ${80 + Math.random() * 30}, ${60 + Math.random() * 20})`;
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, 128, 128);
            
            // 添加陨石坑和纹理
            for (let i = 0; i < 30; i++) {
                const x = Math.random() * 128;
                const y = Math.random() * 128;
                const radius = Math.random() * 8 + 3;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
                gradient.addColorStop(0, `rgba(40, 30, 20, 0.6)`);
                gradient.addColorStop(1, `rgba(80, 60, 40, 0.2)`);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            
            const material = new THREE.MeshPhongMaterial({
                map: texture,
                color: new THREE.Color().setHSL(0.08 + Math.random() * 0.05, 0.4, 0.35),
                shininess: 3,
                flatShading: true
            });
            
            return new THREE.Mesh(geometry, material);
        }
        
        // ===== 地球系统创建（整合原始地球模型） =====
        function createEarthSystem() {
            earthSystem = new THREE.Group();
            earthSystem.visible = false;

            // 创建星空背景（仅在地球层级显示）
            createStarfieldBackground();

            // 创建地球组
            earthGroup = new THREE.Group();
            
            // 纹理URL（使用在线纹理）
            const textureUrls = {
                earth: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_atmos_2048.jpg',
                earthSpecular: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg',
                earthNormal: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg',
                clouds: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_clouds_1024.png'
            };
            
            // 加载纹理
            const textureLoader = new THREE.TextureLoader();
            
            const earthTexture = textureLoader.load(textureUrls.earth);
            const specularTexture = textureLoader.load(textureUrls.earthSpecular);
            const normalTexture = textureLoader.load(textureUrls.earthNormal);
            const cloudTexture = textureLoader.load(textureUrls.clouds);
            
            // 创建地球材质（提高亮度）
            const earthMaterial = new THREE.MeshPhongMaterial({
                map: earthTexture,
                specularMap: specularTexture,
                specular: new THREE.Color(0x666666), // 提高亮度
                shininess: 10, // 提高光泽
                normalMap: normalTexture,
                normalScale: new THREE.Vector2(0.85, 0.85)
            });
            
            // 创建地球几何体
            const earthGeometry = new THREE.SphereGeometry(5, 64, 64);
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            earthGroup.add(earth);
            
            // 创建云层
            const cloudMaterial = new THREE.MeshPhongMaterial({
                map: cloudTexture,
                transparent: true,
                opacity: 0.4,
                depthWrite: false
            });
            
            const cloudGeometry = new THREE.SphereGeometry(5.1, 64, 64);
            clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
            earthGroup.add(clouds);
            
            earthSystem.add(earthGroup);
            
            // 创建所有地球特征（城市、山峰、湖泊等）
            createAllEarthFeatures();
            
            scene.add(earthSystem);
        }

        // 创建星空背景（仅用于地球层级，使用球型粒子）
        function createStarfieldBackground() {
            const starCount = 20000; // 从10000增加到20000
            const starsGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 2000;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 2000;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 2000;

                // 添加颜色变化，模拟不同类型的恒星
                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.2 + 0.5, 0.3, Math.random() * 0.4 + 0.6);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const starsMaterial = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.85,
                map: sphereParticleTexture, // 使用球型纹理
                blending: THREE.AdditiveBlending,
                alphaTest: 0.01,
                depthWrite: false
            });

            earthStarfield = new THREE.Points(starsGeometry, starsMaterial);
            earthStarfield.visible = false; // 默认隐藏，只在地球层级显示
            scene.add(earthStarfield);

            // 创建月球（围绕地球）- 使用高质量纹理
            const moonGeometry = new THREE.SphereGeometry(1, 64, 64);
            const moonTexture = createMoonTexture();
            const moonMaterial = new THREE.MeshPhongMaterial({
                map: moonTexture,
                shininess: 5,
                specular: new THREE.Color(0x222222)
            });
            const moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.position.set(80, 0, 0); // 距离地球80（原来的8倍）
            moon.userData = {
                name: '月球',
                englishName: 'Moon',
                orbitRadius: 80,
                orbitSpeed: 0.001, // 转速降低到原来的10%（0.01 * 0.1）
                angle: 0
            };
            moon.visible = false; // 默认隐藏，只在地球层级显示
            scene.add(moon);

            // 将月球添加到动画更新中
            window.earthMoon = moon;
        }

        // 创建太阳系层级星空背景
        function createSolarStarfieldBackground() {
            const starCount = 15000; // 从8000增加到15000
            const starsGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);

            for (let i = 0; i < starCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 1500;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 1500;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 1500;

                // 添加颜色变化
                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.2 + 0.5, 0.3, Math.random() * 0.4 + 0.6);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const starsMaterial = new THREE.PointsMaterial({
                size: 0.4,
                vertexColors: true,
                transparent: true,
                opacity: 0.85,
                map: sphereParticleTexture, // 使用球型纹理
                blending: THREE.AdditiveBlending,
                alphaTest: 0.01,
                depthWrite: false
            });

            solarStarfield = new THREE.Points(starsGeometry, starsMaterial);
            solarStarfield.visible = false; // 默认隐藏，只在太阳系层级显示
            scene.add(solarStarfield);
        }

        // 创建所有地球特征
        function createAllEarthFeatures() {
            // 城市
            createCityMarkers();
            
            // 山峰和极点
            createPeakMarkers();
            
            // 湖泊
            createLakeMarkers();
            
            // 河流
            createRiverMarkers();
            
            // 赤道和回归线
            createEquatorAndTropics();
        }
        
        // 回归线转三维坐标
        function latLonToVector3(lat, lon, radius) {
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            
            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);
            
            return new THREE.Vector3(x, y, z);
        }
        
        // 创建文字标签Sprite
        function createTextSprite(text, color = '#ffffff') {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            // 清除画布，保持透明背景
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // 添加文字阴影效果，提高可读性
            context.shadowColor = 'rgba(0, 0, 0, 0.8)';
            context.shadowBlur = 4;
            context.shadowOffsetX = 2;
            context.shadowOffsetY = 2;
            
            context.font = 'Bold 24px Arial';
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                depthTest: true,  // 启用深度测试，被遮挡时不显示
                depthWrite: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(0.8, 0.2, 1);
            sprite.renderOrder = 1;  // 改为1，与标记相同的渲染顺序
            
            return sprite;
        }
        
        // 创建城市标记（整合原始代码）
        function createCityMarkers() {
            citiesGroup = new THREE.Group();
            namesGroup = new THREE.Group();
            
            const majorCities = {
                beijing: { name: "北京", englishName: "Beijing", country: "中国", englishCountry: "China", continent: "亚洲", englishContinent: "Asia", coordinates: [116.4074, 39.9042], population: 21540000 },
                shanghai: { name: "上海", englishName: "Shanghai", country: "中国", englishCountry: "China", continent: "亚洲", englishContinent: "Asia", coordinates: [121.4737, 31.2304], population: 24281400 },
                xian: { name: "西安", englishName: "Xi'an", country: "中国", englishCountry: "China", continent: "亚洲", englishContinent: "Asia", coordinates: [108.9398, 34.3416], population: 12952000 },
                tokyo: { name: "东京", englishName: "Tokyo", country: "日本", englishCountry: "Japan", continent: "亚洲", englishContinent: "Asia", coordinates: [139.6917, 35.6895], population: 37400068 },
                newyork: { name: "纽约", englishName: "New York", country: "美国", englishCountry: "USA", continent: "北美洲", englishContinent: "North America", coordinates: [-74.0060, 40.7128], population: 8336817 },
                london: { name: "伦敦", englishName: "London", country: "英国", englishCountry: "UK", continent: "欧洲", englishContinent: "Europe", coordinates: [-0.1276, 51.5074], population: 9002488 },
                paris: { name: "巴黎", englishName: "Paris", country: "法国", englishCountry: "France", continent: "欧洲", englishContinent: "Europe", coordinates: [2.3522, 48.8566], population: 2161000 },
                moscow: { name: "莫斯科", englishName: "Moscow", country: "俄罗斯", englishCountry: "Russia", continent: "欧洲", englishContinent: "Europe", coordinates: [37.6173, 55.7558], population: 12506400 },
                sydney: { name: "悉尼", englishName: "Sydney", country: "澳大利亚", englishCountry: "Australia", continent: "大洋洲", englishContinent: "Oceania", coordinates: [151.2093, -33.8688], population: 5312000 },
                cairo: { name: "开罗", englishName: "Cairo", country: "埃及", englishCountry: "Egypt", continent: "非洲", englishContinent: "Africa", coordinates: [31.2357, 30.0444], population: 20076000 },
                mumbai: { name: "孟买", englishName: "Mumbai", country: "印度", englishCountry: "India", continent: "亚洲", englishContinent: "Asia", coordinates: [72.8777, 19.0760], population: 20411000 },
                saopaulo: { name: "圣保罗", englishName: "Sao Paulo", country: "巴西", englishCountry: "Brazil", continent: "南美洲", englishContinent: "South America", coordinates: [-46.6333, -23.5505], population: 12325200 },
                losangeles: { name: "洛杉矶", englishName: "Los Angeles", country: "美国", englishCountry: "USA", continent: "北美洲", englishContinent: "North America", coordinates: [-118.2437, 34.0522], population: 3990000 },
                chicago: { name: "芝加哥", englishName: "Chicago", country: "美国", englishCountry: "USA", continent: "北美洲", englishContinent: "North America", coordinates: [-87.6298, 41.8781], population: 2697000 },
                toronto: { name: "多伦多", englishName: "Toronto", country: "加拿大", englishCountry: "Canada", continent: "北美洲", englishContinent: "North America", coordinates: [-79.3832, 43.6532], population: 2930000 },
                mexicocity: { name: "墨西哥城", englishName: "Mexico City", country: "墨西哥", englishCountry: "Mexico", continent: "北美洲", englishContinent: "North America", coordinates: [-99.1332, 19.4326], population: 21581000 },
                buenosaires: { name: "布宜诺斯艾利斯", englishName: "Buenos Aires", country: "阿根廷", englishCountry: "Argentina", continent: "南美洲", englishContinent: "South America", coordinates: [-58.3816, -34.6037], population: 15153000 },
                lagos: { name: "拉各斯", englishName: "Lagos", country: "尼日利亚", englishCountry: "Nigeria", continent: "非洲", englishContinent: "Africa", coordinates: [3.3792, 6.5244], population: 15388000 },
                kinshasa: { name: "金沙萨", englishName: "Kinshasa", country: "刚果民主共和国", englishCountry: "DRC", continent: "非洲", englishContinent: "Africa", coordinates: [15.2663, -4.4419], population: 16154000 },
                jakarta: { name: "雅加达", englishName: "Jakarta", country: "印度尼西亚", englishCountry: "Indonesia", continent: "亚洲", englishContinent: "Asia", coordinates: [106.8456, -6.2088], population: 10770400 },
                seoul: { name: "首尔", englishName: "Seoul", country: "韩国", englishCountry: "South Korea", continent: "亚洲", englishContinent: "Asia", coordinates: [126.9780, 37.5665], population: 9776000 },
                bangkok: { name: "曼谷", englishName: "Bangkok", country: "泰国", englishCountry: "Thailand", continent: "亚洲", englishContinent: "Asia", coordinates: [100.5018, 13.7563], population: 10539000 },
                singapore: { name: "新加坡", englishName: "Singapore", country: "新加坡", englishCountry: "Singapore", continent: "亚洲", englishContinent: "Asia", coordinates: [103.8198, 1.3521], population: 5850000 },
                dubai: { name: "迪拜", englishName: "Dubai", country: "阿联酋", englishCountry: "UAE", continent: "亚洲", englishContinent: "Asia", coordinates: [55.2708, 25.2048], population: 3331000 },
                istanbul: { name: "伊斯坦布尔", englishName: "Istanbul", country: "土耳其", englishCountry: "Turkey", continent: "欧洲", englishContinent: "Europe", coordinates: [28.9784, 41.0082], population: 15462400 },
                berlin: { name: "柏林", englishName: "Berlin", country: "德国", englishCountry: "Germany", continent: "欧洲", englishContinent: "Europe", coordinates: [13.4050, 52.5200], population: 3769495 },
                rome: { name: "罗马", englishName: "Rome", country: "意大利", englishCountry: "Italy", continent: "欧洲", englishContinent: "Europe", coordinates: [12.4964, 41.9028], population: 2873000 },
                madrid: { name: "马德里", englishName: "Madrid", country: "西班牙", englishCountry: "Spain", continent: "欧洲", englishContinent: "Europe", coordinates: [-3.7038, 40.4168], population: 6671000 }
            };
            
            Object.keys(majorCities).forEach(cityKey => {
                const city = majorCities[cityKey];
                const position = latLonToVector3(city.coordinates[1], city.coordinates[0], 5.08);
                
                // 城市球体（白色）
                const sphereGeometry = new THREE.SphereGeometry(0.06, 16, 16);
                const sphereMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.9,
                    depthTest: true,   // 启用深度测试
                    depthWrite: true   // 启用深度写入
                });
                
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.copy(position);
                sphere.userData = {
                    cityKey: cityKey,
                    cityData: city,
                    type: 'city'
                };
                sphere.renderOrder = 1;
                citiesGroup.add(sphere);
                
                // 碰撞体
                const hitSphereGeometry = new THREE.SphereGeometry(0.072, 16, 16);
                const hitSphereMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0,
                    depthWrite: false,
                    side: THREE.FrontSide
                });
                const hitSphere = new THREE.Mesh(hitSphereGeometry, hitSphereMaterial);
                hitSphere.position.copy(position);
                hitSphere.userData = {
                    cityKey: cityKey,
                    cityData: city,
                    isHitTest: true
                };
                hitSphere.renderOrder = 1;
                citiesGroup.add(hitSphere);
                
                // 光环
                const ringGeometry = new THREE.RingGeometry(0.1, 0.15, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true, 
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(position);
                ring.lookAt(new THREE.Vector3(0, 0, 0));
                citiesGroup.add(ring);
                
                // 发光点
                const glowGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(position);
                citiesGroup.add(glow);
                
                // 添加名称标签
                const label = createTextSprite(currentLang === 'zh' ? city.name : city.englishName, '#ffffff');
                const labelPosition = position.clone().normalize().multiplyScalar(5.3);
                label.position.copy(labelPosition);
                label.userData = {
                    type: 'city',
                    key: cityKey,
                    data: city
                };
                namesGroup.visible = false;
                namesGroup.add(label);
                citiesGroup.add(label);
                cityLabels.push(label);
            });

            earthGroup.add(citiesGroup); // 改为添加到earthGroup，跟随地球旋转
        }
        
        // 创建山峰标记（整合原始代码）
        function createPeakMarkers() {
            peaksGroup = new THREE.Group();
            
            const highestPeaks = {
                everest: { name: "珠穆朗玛峰", englishName: "Mount Everest", elevation: 8848.86, coordinates: [86.9250, 27.9881], description: "世界第1高峰，海拔8848.86米，位于中国-尼泊尔边境", englishDescription: "The world's highest peak, with an elevation of 8,848.86 meters, located on the China-Nepal border" },
                k2: { name: "乔戈里峰", englishName: "K2", elevation: 8611, coordinates: [76.5133, 35.8816], description: "世界第2高峰，海拔8611米，位于中国-巴基斯坦边境", englishDescription: "The world's second highest peak, with an elevation of 8,611 meters, located on the China-Pakistan border" },
                kangchenjunga: { name: "干城章嘉峰", englishName: "Kangchenjunga", elevation: 8586, coordinates: [88.1475, 27.7025], description: "世界第3高峰，海拔8586米，位于中国-尼泊尔边境", englishDescription: "The world's third highest peak, with an elevation of 8,586 meters, located on the China-Nepal border" },
                acconcagua: { name: "阿空加瓜山", englishName: "Aconcagua", elevation: 6961, coordinates: [-70.0109, -32.6532], description: "南美洲最高峰，海拔6961米，位于阿根廷", englishDescription: "The highest peak in South America, with an elevation of 6,961 meters, located in Argentina" },
                denali: { name: "迪纳利峰", englishName: "Denali", elevation: 6190, coordinates: [-151.0074, 63.0692], description: "北美洲最高峰，海拔6190米，位于美国阿拉斯加", englishDescription: "The highest peak in North America, with an elevation of 6,190 meters, located in Alaska, USA" },
                kilimanjaro: { name: "乞力马扎罗山", englishName: "Kilimanjaro", elevation: 5895, coordinates: [37.3556, -3.0674], description: "非洲最高峰，海拔5895米，位于坦桑尼亚", englishDescription: "The highest peak in Africa, with an elevation of 5,895 meters, located in Tanzania" },
                elbrus: { name: "厄尔布鲁士山", englishName: "Mount Elbrus", elevation: 5642, coordinates: [42.4392, 43.3499], description: "欧洲最高峰，海拔5642米，位于俄罗斯", englishDescription: "The highest peak in Europe, with an elevation of 5,642 meters, located in Russia" },
                vinson: { name: "文森峰", englishName: "Vinson Massif", elevation: 4892, coordinates: [-85.6172, -78.5254], description: "南极洲最高峰，海拔4892米，位于南极洲", englishDescription: "The highest peak in Antarctica, with an elevation of 4,892 meters, located in Antarctica" },
                puncakjaya: { name: "查亚峰", englishName: "Puncak Jaya", elevation: 4884, coordinates: [137.1583, -4.0783], description: "大洋洲及澳大利亚最高峰，海拔4884米，位于印度尼西亚", englishDescription: "The highest peak in Oceania and Australia, with an elevation of 4,884 meters, located in Indonesia" },
                maunakea: { name: "冒纳凯阿火山", englishName: "Mauna Kea", elevation: 4207, coordinates: [-155.4681, 19.8207], description: "从海底算起的最高峰，海拔4207米，总高度超10000米，位于夏威夷", englishDescription: "The highest peak measured from the ocean floor, with an elevation of 4,207 meters, total height over 10,000 meters, located in Hawaii" },
                montblanc: { name: "勃朗峰", englishName: "Mont Blanc", elevation: 4807, coordinates: [6.8649, 45.8326], description: "阿尔卑斯山脉最高峰，海拔4807米，位于法-意边境", englishDescription: "The highest peak in the Alps, with an elevation of 4,807 meters, located on the France-Italy border" },
                northpole: { name: "北极点", englishName: "North Pole", elevation: 0, coordinates: [0, 90], description: "地球最北端，地理北极点，位于北冰洋中心，全年被海冰覆盖", englishDescription: "The northernmost point on Earth, the geographic North Pole, located at the center of the Arctic Ocean, covered by sea ice year-round" },
                southpole: { name: "南极点", englishName: "South Pole", elevation: 2800, coordinates: [0, -90], description: "地球最南端，地理南极点，位于南极高原上，海拔约2800米，是阿蒙森-斯科特南极考察站所在地", englishDescription: "The southernmost point on Earth, the geographic South Pole, located on the Antarctic Plateau at an elevation of approximately 2,800 meters, home to the Amundsen-Scott South Pole Station" }
            };
            
            Object.keys(highestPeaks).forEach(peakKey => {
                const peak = highestPeaks[peakKey];
                const position = latLonToVector3(peak.coordinates[1], peak.coordinates[0], 5.08);
                
                const isPole = peakKey === 'northpole' || peakKey === 'southpole';
                const sphereColor = isPole ? 0xff8800 : 0xff0000;
                
                // 山峰球体
                const sphereGeometry = new THREE.SphereGeometry(0.06, 16, 16);
                const sphereMaterial = new THREE.MeshPhongMaterial({
                    color: sphereColor,
                    transparent: true,
                    opacity: 0.9,
                    emissive: isPole ? 0x442200 : 0x330000,
                    shininess: 100,
                    depthTest: true,   // 启用深度测试
                    depthWrite: true   // 启用深度写入
                });
                
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.copy(position);
                sphere.userData = {
                    peakKey: peakKey,
                    peakData: peak,
                    type: 'peak'
                };
                sphere.renderOrder = 1;
                peaksGroup.add(sphere);
                
                // 碰撞体
                const hitSphereGeometry = new THREE.SphereGeometry(0.072, 16, 16);
                const hitSphereMaterial = new THREE.MeshBasicMaterial({
                    color: sphereColor,
                    transparent: true,
                    opacity: 0,
                    depthWrite: false,
                    side: THREE.FrontSide
                });
                const hitSphere = new THREE.Mesh(hitSphereGeometry, hitSphereMaterial);
                hitSphere.position.copy(position);
                hitSphere.userData = {
                    peakKey: peakKey,
                    peakData: peak,
                    isHitTest: true
                };
                hitSphere.renderOrder = 1;
                peaksGroup.add(hitSphere);
                
                // 光环
                const ringGeometry = new THREE.RingGeometry(0.12, 0.18, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: sphereColor,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(position);
                ring.lookAt(new THREE.Vector3(0, 0, 0));
                peaksGroup.add(ring);
                
                // 发光点
                const glowGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: sphereColor,
                    transparent: true,
                    opacity: 0.8
                });
                
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(position);
                peaksGroup.add(glow);
                
                // 添加名称标签
                const label = createTextSprite(currentLang === 'zh' ? peak.name : peak.englishName, sphereColor === 0xff8800 ? '#ff8800' : '#ff0000');
                const labelPosition = position.clone().normalize().multiplyScalar(5.3);
                label.position.copy(labelPosition);
                label.userData = {
                    type: 'peak',
                    key: peakKey,
                    data: peak
                };
                peaksGroup.add(label);
                peakLabels.push(label);
            });
            
            peaksGroup.visible = showPeaks; // 设置初始可见状态
            earthGroup.add(peaksGroup); // 改为添加到earthGroup，跟随地球旋转
        }
        
        // 创建湖泊标记（整合原始代码）
        function createLakeMarkers() {
            lakesGroup = new THREE.Group();
            
            const majorLakes = {
                caspian: { name: "里海", englishName: "Caspian Sea", area: 371000, maxDepth: 1025, coordinates: [52, 42], description: "世界最大内陆湖，面积37.1万平方公里，最大深度1025米，位于欧洲和亚洲之间", englishDescription: "The largest inland lake in the world, with an area of 371,000 square kilometers, maximum depth of 1,025 meters, located between Europe and Asia" },
                baikal: { name: "贝加尔湖", englishName: "Lake Baikal", area: 31500, maxDepth: 1642, coordinates: [108, 53], description: "世界最深湖泊，面积3.15万平方公里，最大深度1642米，位于俄罗斯西伯利亚，蓄水量世界最大", englishDescription: "The world's deepest lake, with an area of 31,500 square kilometers, maximum depth of 1,642 meters, located in Siberia, Russia, with the largest water storage in the world" },
                victoria: { name: "维多利亚湖", englishName: "Lake Victoria", area: 68800, maxDepth: 84, coordinates: [33, -1], description: "非洲最大湖泊，面积6.88万平方公里，最大深度84米，位于东非高原，是尼罗河发源地", englishDescription: "The largest lake in Africa, with an area of 68,800 square kilometers, maximum depth of 84 meters, located on the East African Plateau, the source of the Nile River" },
                tanganyika: { name: "坦噶尼喀湖", englishName: "Lake Tanganyika", area: 32900, maxDepth: 1470, coordinates: [29, -6], description: "世界第二深湖，面积3.29万平方公里，最大深度1470米，位于东非大裂谷", englishDescription: "The second deepest lake in the world, with an area of 32,900 square kilometers, maximum depth of 1,470 meters, located in the East African Rift Valley" },
                superior: { name: "苏必利尔湖", englishName: "Lake Superior", area: 82100, maxDepth: 406, coordinates: [-87, 47], description: "北美洲最大湖，面积8.21万平方公里，最大深度406米，位于美国-加拿大边境", englishDescription: "The largest lake in North America, with an area of 82,100 square kilometers, maximum depth of 406 meters, located on the US-Canada border" },
                huron: { name: "休伦湖", englishName: "Lake Huron", area: 59600, maxDepth: 229, coordinates: [-81, 44], description: "北美洲第二大湖，面积5.96万平方公里，最大深度229米，位于美国-加拿大边境", englishDescription: "The second largest lake in North America, with an area of 59,600 square kilometers, maximum depth of 229 meters, located on the US-Canada border" },
                michigan: { name: "密歇根湖", englishName: "Lake Michigan", area: 58000, maxDepth: 281, coordinates: [-87, 43], description: "完全位于美国境内的最大湖，面积5.8万平方公里，最大深度281米", englishDescription: "The largest lake entirely within the United States, with an area of 58,000 square kilometers, maximum depth of 281 meters" }
            };
            
            Object.keys(majorLakes).forEach(lakeKey => {
                const lake = majorLakes[lakeKey];
                const position = latLonToVector3(lake.coordinates[1], lake.coordinates[0], 5.08);
                
                // 湖泊球体（蓝色）
                const lakeGeometry = new THREE.SphereGeometry(0.06, 16, 16);
                const lakeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x0000ff,
                    transparent: true,
                    opacity: 0.9,
                    emissive: 0x000033,
                    shininess: 100,
                    depthTest: true,   // 启用深度测试
                    depthWrite: true   // 启用深度写入
                });
                
                const lakeMesh = new THREE.Mesh(lakeGeometry, lakeMaterial);
                lakeMesh.position.copy(position);
                lakeMesh.userData = {
                    lakeKey: lakeKey,
                    lakeData: lake,
                    type: 'lake'
                };
                lakeMesh.renderOrder = 1;
                lakesGroup.add(lakeMesh);
                
                // 碰撞体
                const hitSphereGeometry = new THREE.SphereGeometry(0.072, 16, 16);
                const hitSphereMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0000ff,
                    transparent: true,
                    opacity: 0,
                    depthWrite: false,
                    side: THREE.FrontSide
                });
                const hitSphere = new THREE.Mesh(hitSphereGeometry, hitSphereMaterial);
                hitSphere.position.copy(position);
                hitSphere.userData = {
                    lakeKey: lakeKey,
                    lakeData: lake,
                    isHitTest: true
                };
                hitSphere.renderOrder = 1;
                lakesGroup.add(hitSphere);
                
                // 蓝色光环
                const ringGeometry = new THREE.RingGeometry(0.12, 0.18, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0000ff,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(position);
                ring.lookAt(new THREE.Vector3(0, 0, 0));
                lakesGroup.add(ring);
                
                // 蓝色发光点
                const glowGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0000ff,
                    transparent: true,
                    opacity: 0.8
                });
                
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(position);
                lakesGroup.add(glow);
                
                // 添加名称标签
                const label = createTextSprite(currentLang === 'zh' ? lake.name : lake.englishName, '#0099ff');
                const labelPosition = position.clone().normalize().multiplyScalar(5.3);
                label.position.copy(labelPosition);
                label.userData = {
                    type: 'lake',
                    key: lakeKey,
                    data: lake
                };
                lakesGroup.add(label);
                lakeLabels.push(label);
            });
            
            lakesGroup.visible = showLakes; // 设置初始可见状态
            earthGroup.add(lakesGroup); // 改为添加到earthGroup，跟随地球旋转
        }
        
        // 创建河流标记（整合原始代码）
        function createRiverMarkers() {
            riversGroup = new THREE.Group();
            
            const majorRivers = {
                nile: { name: "尼罗河", englishName: "Nile River", length: 6650, coordinates: [32.0, 30.0], description: "世界最长河流，全长6650公里，流经11个国家，是古埃及文明的摇篮", englishDescription: "The world's longest river, stretching 6,650 kilometers, flowing through 11 countries, the cradle of ancient Egyptian civilization" },
                amazon: { name: "亚马逊河", englishName: "Amazon River", length: 6400, coordinates: [-60.0, -3.0], description: "世界第二长河，流量最大，全长6400公里，流经南美洲7个国家", englishDescription: "The world's second longest river with the largest water flow, stretching 6,400 kilometers, flowing through 7 countries in South America" },
                yangtze: { name: "长江", englishName: "Yangtze River", length: 6300, coordinates: [117.0, 30.0], description: "亚洲第一长河，全长6300公里，中国母亲河，世界第三长河", englishDescription: "The longest river in Asia, stretching 6,300 kilometers, the mother river of China, the third longest river in the world" },
                mississippi: { name: "密西西比河", englishName: "Mississippi River", length: 6275, coordinates: [-90.0, 35.0], description: "北美洲第一长河，全长6275公里，美国最重要的河流系统", englishDescription: "The longest river in North America, stretching 6,275 kilometers, the most important river system in the United States" },
                yenisei: { name: "叶尼塞河", englishName: "Yenisei River", length: 5539, coordinates: [92.0, 58.0], description: "西伯利亚三大河之一，全长5539公里，流入北冰洋", englishDescription: "One of the three great rivers of Siberia, stretching 5,539 kilometers, flowing into the Arctic Ocean" },
                yellow: { name: "黄河", englishName: "Yellow River", length: 5464, coordinates: [110.0, 37.0], description: "中国第二长河，全长5464公里，中华文明的发源地", englishDescription: "The second longest river in China, stretching 5,464 kilometers, the birthplace of Chinese civilization" },
                ob: { name: "鄂毕河", englishName: "Ob River", length: 5410, coordinates: [75.0, 60.0], description: "西伯利亚三大河之一，全长5410公里，俄罗斯重要河流", englishDescription: "One of the three great rivers of Siberia, stretching 5,410 kilometers, an important river in Russia" }
            };
            
            Object.keys(majorRivers).forEach(riverKey => {
                const river = majorRivers[riverKey];
                const position = latLonToVector3(river.coordinates[1], river.coordinates[0], 5.08);
                
                // 河流球体（绿色）
                const riverGeometry = new THREE.SphereGeometry(0.06, 16, 16);
                const riverMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.9,
                    emissive: 0x003300,
                    shininess: 100,
                    depthTest: true,   // 启用深度测试
                    depthWrite: true   // 启用深度写入
                });
                
                const riverMesh = new THREE.Mesh(riverGeometry, riverMaterial);
                riverMesh.position.copy(position);
                riverMesh.userData = {
                    riverKey: riverKey,
                    riverData: river,
                    type: 'river'
                };
                riverMesh.renderOrder = 1;
                riversGroup.add(riverMesh);
                
                // 碰撞体
                const hitSphereGeometry = new THREE.SphereGeometry(0.072, 16, 16);
                const hitSphereMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0,
                    depthWrite: false,
                    side: THREE.FrontSide
                });
                const hitSphere = new THREE.Mesh(hitSphereGeometry, hitSphereMaterial);
                hitSphere.position.copy(position);
                hitSphere.userData = {
                    riverKey: riverKey,
                    riverData: river,
                    isHitTest: true
                };
                hitSphere.renderOrder = 1;
                riversGroup.add(hitSphere);
                
                // 绿色光环
                const ringGeometry = new THREE.RingGeometry(0.12, 0.18, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.4,
                    side: THREE.DoubleSide
                });
                
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(position);
                ring.lookAt(new THREE.Vector3(0, 0, 0));
                riversGroup.add(ring);
                
                // 绿色发光点
                const glowGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.8
                });
                
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.copy(position);
                riversGroup.add(glow);
                
                // 添加名称标签
                const label = createTextSprite(currentLang === 'zh' ? river.name : river.englishName, '#00ff00');
                const labelPosition = position.clone().normalize().multiplyScalar(5.3);
                label.position.copy(labelPosition);
                label.userData = {
                    type: 'river',
                    key: riverKey,
                    data: river
                };
                riversGroup.add(label);
                riverLabels.push(label);
            });
            
            riversGroup.visible = showRivers; // 设置初始可见状态
            earthGroup.add(riversGroup); // 改为添加到earthGroup，跟随地球旋转
        }
        
        // 创建赤道和回归线
        function createEquatorAndTropics() {
            equatorGroup = new THREE.Group(); //赤道组
            tropicGroup = new THREE.Group();  //回归线组
            latLonGroup = new THREE.Group();  //经纬线组
            arcAntGroup = new THREE.Group();  //极圈组
            
            // 赤道线
            const equatorPoints = [];
            for (let i = 0; i <= 64; i++) {
                const angle = (i / 64) * Math.PI * 2;
                equatorPoints.push(new THREE.Vector3(
                    Math.cos(angle) * 5.05,
                    0,
                    Math.sin(angle) * 5.05
                ));
            }
            
            const equatorGeometry = new THREE.BufferGeometry().setFromPoints(equatorPoints);
            const equatorMaterial = new THREE.LineBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.6
            });
            
            const equatorLine = new THREE.Line(equatorGeometry, equatorMaterial);
            equatorGroup.add(equatorLine);
            equatorGroup.visible = false;
            earthGroup.add(equatorGroup); // 改为添加到earthGroup，跟随地球旋转
            
            // 南北回归线
            const tropicLatitudes = [23.5, -23.5];
            tropicLatitudes.forEach((lat, index) => {
                const tropicPoints = [];
                const radius = Math.cos(lat * Math.PI / 180) * 5.05;
                const y = Math.sin(lat * Math.PI / 180) * 5.05;
                
                for (let i = 0; i <= 64; i++) {
                    const angle = (i / 64) * Math.PI * 2;
                    tropicPoints.push(new THREE.Vector3(
                        Math.cos(angle) * radius,
                        y,
                        Math.sin(angle) * radius
                    ));
                }
                
                const tropicGeometry = new THREE.BufferGeometry().setFromPoints(tropicPoints);
                const tropicMaterial = new THREE.LineBasicMaterial({
                    color: 0xff00ff,
                    transparent: true,
                    opacity: 0.6
                });
                
                const tropicLine = new THREE.Line(tropicGeometry, tropicMaterial);
                tropicGroup.add(tropicLine);
            });
            
            tropicGroup.visible = false;
            earthGroup.add(tropicGroup); // 改为添加到earthGroup，跟随地球旋转

            // 北极圈 (纬度 66.5°N)
            const arcticCirclePoints = [];
            for (let lon = 0; lon <= 360; lon += 5) {
                const point = latLonToVector3(66.5, lon, 5.05);
                arcticCirclePoints.push(point);
            }
            const arcticCircleGeometry = new THREE.BufferGeometry().setFromPoints(arcticCirclePoints);
            const arcticCircleMaterial = new THREE.LineBasicMaterial({
                color: 0x0088ff,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });
            const arcticCircleLine = new THREE.Line(arcticCircleGeometry, arcticCircleMaterial);
            arcAntGroup.add(arcticCircleLine);

            // 南极圈 (纬度 66.5°S)
            const antarcticCirclePoints = [];
            for (let lon = 0; lon <= 360; lon += 5) {
                const point = latLonToVector3(-66.5, lon, 5.05);
                antarcticCirclePoints.push(point);
            }
            const antarcticCircleGeometry = new THREE.BufferGeometry().setFromPoints(antarcticCirclePoints);
            const antarcticCircleMaterial = new THREE.LineBasicMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });
            const antarcticCircleLine = new THREE.Line(antarcticCircleGeometry, antarcticCircleMaterial);
            arcAntGroup.add(antarcticCircleLine);
            arcAntGroup.visible = false;
            earthGroup.add(arcAntGroup); // 改为添加到earthGroup，跟随地球旋转
            // 创建经纬度网格
            // 经度线（每30度一条）
            for (let lon = 0; lon < 360; lon += 30) {
                const lonPoints = [];
                for (let lat = -90; lat <= 90; lat += 5) {
                    const position = latLonToVector3(lat, lon, 5.05);
                    lonPoints.push(position);
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(lonPoints);
                const material = new THREE.LineBasicMaterial({
                    color: 0x888888,
                    transparent: true,
                    opacity: 0.3
                });
                
                const line = new THREE.Line(geometry, material);
                latLonGroup.add(line);
            }
            
            // 纬度线（每30度一条，不包括赤道和回归线）
            for (let lat = -60; lat <= 60; lat += 30) {
                const latPoints = [];
                const radius = Math.cos(lat * Math.PI / 180) * 5.05;
                const y = Math.sin(lat * Math.PI / 180) * 5.05;
                
                for (let lon = 0; lon <= 360; lon += 10) {
                    const angle = lon * Math.PI / 180;
                    latPoints.push(new THREE.Vector3(
                        Math.cos(angle) * radius,
                        y,
                        Math.sin(angle) * radius
                    ));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(latPoints);
                const material = new THREE.LineBasicMaterial({
                    color: 0xaaaaaa,
                    transparent: true,
                    opacity: 0.3
                });
                
                const line = new THREE.Line(geometry, material);
                latLonGroup.add(line);
            }
            latLonGroup.visible = false;
            earthSystem.add(latLonGroup);
        }
        
        // 创建标记
        function createMarker(position, color, name, type) {
            const group = new THREE.Group();
            group.position.copy(position);
            
            // 标记球体
            const geometry = new THREE.SphereGeometry(1, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8
            });
            const sphere = new THREE.Mesh(geometry, material);
            group.add(sphere);
            
            // 发光环
            const ringGeometry = new THREE.RingGeometry(1.5, 2, 16);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.lookAt(new THREE.Vector3(0, 0, 0));
            group.add(ring);
            
            // 标记数据
            group.userData = {
                name: name,
                englishName: name,
                type: type,
                isMarker: true
            };
            
            return group;
        }
        
        // ===== 事件处理 =====
        function onMouseMove(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // 检测悬停并高亮（包括地球层级）
            checkHover();
        }
        
        function onClick(event) {
            raycaster.setFromCamera(mouse, camera);

            // 地球层级的点击处理
            if (currentLevel === 'earth' && earthSystem.visible) {
                const allEarthObjects = [];
                if (citiesGroup) allEarthObjects.push(...citiesGroup.children);
                if (peaksGroup) allEarthObjects.push(...peaksGroup.children);
                if (lakesGroup) allEarthObjects.push(...lakesGroup.children);
                if (riversGroup) allEarthObjects.push(...riversGroup.children);

                const intersects = raycaster.intersectObjects(allEarthObjects, true);

                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    const worldPosition = new THREE.Vector3();
                    object.getWorldPosition(worldPosition);

                    const cameraPosition = camera.position.clone();
                    const objectToCamera = worldPosition.clone().sub(cameraPosition).normalize();
                    const objectToCenter = worldPosition.clone().normalize();
                    const dotProduct = objectToCamera.dot(objectToCenter);

                    if (dotProduct < 0) {
                        let data = null;
                        let key = null;
                        let obj = null;

                        if (object.userData.cityKey) {
                            data = object.userData.cityData;
                            key = object.userData.cityKey;
                            obj = object;
                            showCityTooltip(data, key, obj);
                        } else if (object.userData.peakKey) {
                            data = object.userData.peakData;
                            key = object.userData.peakKey;
                            obj = object;
                            showPeakTooltip(data, key, obj);
                        } else if (object.userData.lakeKey) {
                            data = object.userData.lakeData;
                            key = object.userData.lakeKey;
                            obj = object;
                            showLakeTooltip(data, key, obj);
                        } else if (object.userData.riverKey) {
                            data = object.userData.riverData;
                            key = object.userData.riverKey;
                            obj = object;
                            showRiverTooltip(data, key, obj);
                        }

                        if (data) {
                            isRotating = false;
                            const toggleButton = document.getElementById('toggleRotation');
                            if (toggleButton) {
                                toggleButton.textContent = texts[currentLang].toggleButtons.rotation[2]; // 恢复旋转
                            }
                        }
                    }
                }
                return;
            }

            let intersects;

            if (currentLevel === 'galaxy') {
                intersects = raycaster.intersectObjects(galaxy.children, true);
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    if (object.parent && object.parent.userData.isMarker) {
                        if (object.parent.userData.type === 'solar') {
                            transitionToSolarSystem();
                        }
                    }
                }
            } else if (currentLevel === 'solar') {
                intersects = raycaster.intersectObjects(solarSystem.children, true);
                
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    if (object.userData.isEarth) {
                        transitionToEarth();
                    }
                }
            }
        }
        
        // 检测鼠标悬停
        function checkHover() {
            raycaster.setFromCamera(mouse, camera);

            // 地球层级的悬停检测
            if (currentLevel === 'earth' && earthSystem.visible) {
                const allEarthObjects = [];
                if (citiesGroup) allEarthObjects.push(...citiesGroup.children);
                if (peaksGroup) allEarthObjects.push(...peaksGroup.children);
                if (lakesGroup) allEarthObjects.push(...lakesGroup.children);
                if (riversGroup) allEarthObjects.push(...riversGroup.children);

                const intersects = raycaster.intersectObjects(allEarthObjects, true);

                // 重置所有高亮
                [citiesGroup, peaksGroup, lakesGroup, riversGroup].forEach(group => {
                    if (group) {
                        group.children.forEach(child => {
                            if (child.userData && (child.userData.cityKey || child.userData.peakKey || child.userData.lakeKey || child.userData.riverKey) && !child.userData.isHitTest) {
                                child.scale.setScalar(1);
                            }
                        });
                    }
                });

                // 处理悬停（地球层级也支持自动弹窗）
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    const worldPosition = new THREE.Vector3();
                    object.getWorldPosition(worldPosition);

                    // 检查是否在地球正面
                    const cameraPosition = camera.position.clone();
                    const objectToCamera = worldPosition.clone().sub(cameraPosition).normalize();
                    const objectToCenter = worldPosition.clone().normalize();
                    const dotProduct = objectToCamera.dot(objectToCenter);

                    if (dotProduct < 0) { // 在正面
                        let data = null;
                        let type = '';
                        let key = null;

                        if (object.userData.cityKey) {
                            data = object.userData.cityData;
                            type = 'city';
                            key = object.userData.cityKey;
                        } else if (object.userData.peakKey) {
                            data = object.userData.peakData;
                            type = 'peak';
                            key = object.userData.peakKey;
                        } else if (object.userData.lakeKey) {
                            data = object.userData.lakeData;
                            type = 'lake';
                            key = object.userData.lakeKey;
                        } else if (object.userData.riverKey) {
                            data = object.userData.riverData;
                            type = 'river';
                            key = object.userData.riverKey;
                        }

                        if (data) {
                            // 检查标记组是否可见
                            let isVisible = false;
                            if (type === 'city') isVisible = showCities;
                            else if (type === 'peak') isVisible = showPeaks;
                            else if (type === 'lake') isVisible = showLakes;
                            else if (type === 'river') isVisible = showRivers;

                            if (!isVisible) {
                                // 标记组隐藏，不显示弹窗
                                document.body.style.cursor = 'default';
                                document.getElementById('instructions').innerHTML = texts[currentLang].instructions.earth;
                                return;
                            }

                            // 高亮
                            object.scale.setScalar(1.3);
                            document.body.style.cursor = 'pointer';
                            document.getElementById('instructions').innerHTML = texts[currentLang].instructions.hover.replace('%s', currentLang === 'zh' ? data.name : (data.englishName || data.name));

                            // 自动显示弹窗（悬停时立即显示）
                            let showFunction = null;
                            if (type === 'city') showFunction = showCityTooltip;
                            else if (type === 'peak') showFunction = showPeakTooltip;
                            else if (type === 'lake') showFunction = showLakeTooltip;
                            else if (type === 'river') showFunction = showRiverTooltip;

                            if (showFunction && (!currentTooltip || currentTooltip !== getActiveTooltip(type, key))) {
                                showFunction(data, key, object);

                                // 弹窗显示时暂停地球旋转
                                isRotating = false;
                                const toggleButton = document.getElementById('toggleRotation');
                                if (toggleButton) {
                                    toggleButton.textContent = texts[currentLang].toggleButtons.rotation[2]; // 恢复旋转
                                }
                            }

                            // 鼠标仍在标识上，取消延迟关闭
                            cancelTooltipHide();
                        }
                    } else {
                        document.body.style.cursor = 'default';
                        document.getElementById('instructions').innerHTML = texts[currentLang].instructions.earth;
                        // 鼠标移开后，开始1秒倒计时关闭弹窗
                        if (currentTooltip) {
                            scheduleTooltipHide();
                        }
                    }
                } else {
                    document.body.style.cursor = 'default';
                    document.getElementById('instructions').innerHTML = texts[currentLang].instructions.earth;
                    // 鼠标移开后，开始1秒倒计时关闭弹窗
                    if (currentTooltip) {
                        scheduleTooltipHide();
                    }
                }

                return;
            }

            if (currentLevel === 'galaxy') {
                const intersects = raycaster.intersectObjects(galaxy.children, true);
                
                // 重置所有高亮
                [citiesGroup, peaksGroup, lakesGroup, riversGroup].forEach(group => {
                    if (group) {
                        group.children.forEach(child => {
                            if (child.userData && (child.userData.cityKey || child.userData.peakKey || child.userData.lakeKey || child.userData.riverKey) && !child.userData.isHitTest) {
                                child.scale.setScalar(1);
                            }
                        });
                    }
                });
                
                // 处理悬停
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    const worldPosition = new THREE.Vector3();
                    object.getWorldPosition(worldPosition);
                    
                    // 检查是否在地球正面
                    const cameraPosition = camera.position.clone();
                    const objectToCamera = worldPosition.clone().sub(cameraPosition).normalize();
                    const objectToCenter = worldPosition.clone().normalize();
                    const dotProduct = objectToCamera.dot(objectToCenter);
                    
                    if (dotProduct < 0) { // 在正面
                        let data = null;
                        let type = '';
                        
                        if (object.userData.cityKey) {
                            data = object.userData.cityData;
                            type = 'city';
                        } else if (object.userData.peakKey) {
                            data = object.userData.peakData;
                            type = 'peak';
                        } else if (object.userData.lakeKey) {
                            data = object.userData.lakeData;
                            type = 'lake';
                        } else if (object.userData.riverKey) {
                            data = object.userData.riverData;
                            type = 'river';
                        }
                        
                        if (data) {
                            // 高亮
                            object.scale.setScalar(1.3);
                            document.body.style.cursor = 'pointer';
                            document.getElementById('instructions').innerHTML = texts[currentLang].instructions.hover.replace('%s', currentLang === 'zh' ? data.name : (data.englishName || data.name));
                            
                            // 自动显示弹窗（悬停时立即显示）
                            let showFunction = null;
                            if (type === 'city') showFunction = showCityTooltip;
                            else if (type === 'peak') showFunction = showPeakTooltip;
                            else if (type === 'lake') showFunction = showLakeTooltip;
                            else if (type === 'river') showFunction = showRiverTooltip;
                            
                            if (showFunction && (!currentTooltip || currentTooltip !== getActiveTooltip(type, key))) {
                                showFunction(data, key, object);
                            }
                            
                            // 设置延迟关闭计时器
                            scheduleTooltipHide();
                        }
                } else {
                    document.body.style.cursor = 'default';
                    document.getElementById('instructions').innerHTML = texts[currentLang].instructions.galaxy;
                    // 鼠标移开后，开始1秒倒计时关闭弹窗
                    if (currentTooltip) {
                        scheduleTooltipHide();
                    }
                }
            } else {
                document.body.style.cursor = 'default';
                document.getElementById('instructions').innerHTML = texts[currentLang].instructions.galaxy;
                // 鼠标移开后，开始1秒倒计时关闭弹窗
                if (currentTooltip) {
                    scheduleTooltipHide();
                }
            }
                
                return;
            }
            
            if (currentLevel === 'galaxy') {
                const intersects = raycaster.intersectObjects(galaxy.children, true);
                
                // 重置所有标记
                galaxy.children.forEach(child => {
                    if (child.userData.isMarker) {
                        child.children[0].material.opacity = 0.8;
                        child.children[1].material.opacity = 0.3;
                        child.scale.setScalar(1);
                    }
                });
                
                // 高亮悬停的标记
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    if (object.parent && object.parent.userData.isMarker) {
                        object.parent.children[0].material.opacity = 1;
                        object.parent.children[1].material.opacity = 0.6;
                        object.parent.scale.setScalar(1.2);
                        document.body.style.cursor = 'pointer';
                        document.getElementById('instructions').innerHTML = texts[currentLang].instructions.click.replace('%s', currentLang === 'zh' ? object.parent.userData.name : (object.parent.userData.englishName || object.parent.userData.name));
                    } else {
                        document.body.style.cursor = 'default';
                        document.getElementById('instructions').innerHTML = texts[currentLang].instructions.galaxy;
                    }
                } else {
                    document.body.style.cursor = 'default';
                    document.getElementById('instructions').innerHTML = texts[currentLang].instructions.galaxy;
                }
                
            } else if (currentLevel === 'solar') {
                const intersects = raycaster.intersectObjects(solarSystem.children, true);
                
                // 重置行星
                planets.forEach(planet => {
                    planet.material.opacity = 0.9;
                    planet.scale.setScalar(1);
                });
                
                // 高亮悬停的行星
                if (intersects.length > 0) {
                    const object = intersects[0].object;
                    if (object.userData.isEarth) {
                        object.material.opacity = 1;
                        object.scale.setScalar(1.3);
                        document.body.style.cursor = 'pointer';
                        document.getElementById('instructions').innerHTML = texts[currentLang].instructions.click.replace('%s', currentLang === 'zh' ? '地球' : 'Earth');
                    } else {
                        document.body.style.cursor = 'default';
                        document.getElementById('instructions').innerHTML = texts[currentLang].instructions.solar;
                    }
                } else {
                    document.body.style.cursor = 'default';
                    document.getElementById('instructions').innerHTML = texts[currentLang].instructions.solar;
                }
            }
        }
        
        // 过渡到太阳系
        function transitionToSolarSystem() {
            currentLevel = 'solar';
            
            // 隐藏银河系，显示太阳系
            galaxy.visible = false;
            solarSystem.visible = true;
            
            // 显示太阳系星空背景
            if (solarStarfield) {
                solarStarfield.visible = true;
            }
            
            // 平滑移动相机
            animateCamera(
                cameraPositions.solar.position,
                cameraPositions.solar.target,
                2000
            );
            
                // 显示返回按钮
                document.getElementById('back-button').style.display = 'block';
                
                // 显示太阳系控制面板
                document.getElementById('solar-controls').classList.add('visible');
                document.getElementById('galaxy-controls').classList.remove('visible');
                
                // 设置太阳系层级控制
                setupSolarControls();

                document.getElementById('instructions').innerHTML = texts[currentLang].instructions.solar;
                
                // 更新导航按钮
                updateNavButtons();
        }
        
        // 过渡到地球
        function transitionToEarth() {
            currentLevel = 'earth';

            // 隐藏太阳系，显示地球
            solarSystem.visible = false;
            earthSystem.visible = true;

            // 隐藏太阳系星空背景
            if (solarStarfield) {
                solarStarfield.visible = false;
            }

            // 显示地球星空背景
            if (earthStarfield) {
                earthStarfield.visible = true;
            }

            // 显示月球
            if (window.earthMoon) {
                window.earthMoon.visible = true;
            }

            // 显示地球控制面板
            document.getElementById('earth-controls').classList.add('visible');

                // 设置地球层级控制
                setupEarthControls();

                // 隐藏其他控制面板
                document.getElementById('galaxy-controls').classList.remove('visible');
                document.getElementById('solar-controls').classList.remove('visible');
                
                // 重置控制面板状态
                panelToggleCount = 0;
                isPanelVisible = true;
                showingCredits = false;
                document.getElementById('normalInfo').style.display = 'block';
				document.getElementById('normalInfo2').style.display = 'block';
                document.getElementById('creditsInfo').style.display = 'none';

            // 平滑移动相机
            animateCamera(
                cameraPositions.earth.position,
                cameraPositions.earth.target,
                2000
            );

            document.getElementById('instructions').innerHTML = texts[currentLang].instructions.earth;
            
            // 更新导航按钮
            updateNavButtons();
        }
        
        // 返回上一层级
        window.goBack = function() {
            if (currentLevel === 'earth') {
                // 返回太阳系
                currentLevel = 'solar';
                earthSystem.visible = false;
                solarSystem.visible = true;

                // 隐藏星空背景
                if (earthStarfield) {
                    earthStarfield.visible = false;
                }

                // 隐藏月球
                if (window.earthMoon) {
                    window.earthMoon.visible = false;
                }

                // 隐藏地球控制面板
                document.getElementById('earth-controls').classList.remove('visible');
                
                // 重置控制面板状态
                panelToggleCount = 0;
                isPanelVisible = true;
                showingCredits = false;
                document.getElementById('normalInfo').style.display = 'block';
				document.getElementById('normalInfo2').style.display = 'block';
                document.getElementById('creditsInfo').style.display = 'none';

                // 显示太阳系控制面板
                document.getElementById('solar-controls').classList.add('visible');
                
                // 显示太阳系星空背景
                if (solarStarfield) {
                    solarStarfield.visible = true;
                }
                
                animateCamera(
                    cameraPositions.solar.position,
                    cameraPositions.solar.target,
                    1500
                );

                document.getElementById('instructions').innerHTML = texts[currentLang].instructions.solar;
                
                // 更新导航按钮
                updateNavButtons();
            } else if (currentLevel === 'solar') {
                // 返回银河系
                currentLevel = 'galaxy';
                solarSystem.visible = false;
                galaxy.visible = true;
                
                // 隐藏太阳系星空背景
                if (solarStarfield) {
                    solarStarfield.visible = false;
                }

                // 隐藏太阳系控制面板
                document.getElementById('solar-controls').classList.remove('visible');

                // 显示银河系控制面板
                document.getElementById('galaxy-controls').classList.add('visible');
                
                // 设置银河系层级控制
                setupGalaxyControls();

                animateCamera(
                    cameraPositions.galaxy.position,
                    cameraPositions.galaxy.target,
                    2000
                );

                document.getElementById('back-button').style.display = 'none';
                document.getElementById('instructions').innerHTML = texts[currentLang].instructions.galaxy;
                
                // 更新导航按钮
                updateNavButtons();
            }
        };
        
        // 进入太阳系
        window.enterSolarSystem = function() {
            transitionToSolarSystem();
        };
        
        // 进入地球
        window.enterEarth = function() {
            transitionToEarth();
        };
        
        // 更新导航按钮显示状态
        function updateNavButtons() {
            const backBtn = document.getElementById('back-button');
            const enterSolarBtn = document.getElementById('enter-solar-button');
            const enterEarthBtn = document.getElementById('enter-earth-button');
            const togglePanelBtn = document.getElementById('toggle-panel-button');
            
            // 根据当前层级显示/隐藏按钮
            if (currentLevel === 'galaxy') {
                // 银河系层级：显示进入太阳系按钮
                if (enterSolarBtn) enterSolarBtn.style.display = 'block';
                if (enterEarthBtn) enterEarthBtn.style.display = 'none';
                if (backBtn) backBtn.style.display = 'none';
                if (togglePanelBtn) togglePanelBtn.style.display = 'none';
            } else if (currentLevel === 'solar') {
                // 太阳系层级：显示返回按钮和进入地球按钮
                if (backBtn) backBtn.style.display = 'block';
                if (enterEarthBtn) enterEarthBtn.style.display = 'block';
                if (enterSolarBtn) enterSolarBtn.style.display = 'none';
                if (togglePanelBtn) togglePanelBtn.style.display = 'none';
            } else if (currentLevel === 'earth') {
                // 地球层级：显示返回按钮和控制面板切换按钮
                if (backBtn) backBtn.style.display = 'block';
                if (enterSolarBtn) enterSolarBtn.style.display = 'none';
                if (enterEarthBtn) enterEarthBtn.style.display = 'none';
                if (togglePanelBtn) togglePanelBtn.style.display = 'block';
            }

            // 更新按钮文本
            if (backBtn) backBtn.textContent = texts[currentLang].navButtons.back;
            if (enterSolarBtn) enterSolarBtn.textContent = texts[currentLang].navButtons.enterSolar;
            if (enterEarthBtn) enterEarthBtn.textContent = texts[currentLang].navButtons.enterEarth;
            if (togglePanelBtn) togglePanelBtn.textContent = texts[currentLang].navButtons.togglePanel;
        }
        
        // 切换控制面板显示/隐藏
        window.toggleControlPanel = function() {
            const panel = document.getElementById('earth-controls');
            const toggleBtn = document.getElementById('toggle-panel-button');
            const normalInfo = document.getElementById('normalInfo');
			const normalInfo2 = document.getElementById('normalInfo2');
            const creditsInfo = document.getElementById('creditsInfo');
            
            if (showingCredits) {
                // 如果正在显示制作人员信息，点击后恢复正常显示
                showingCredits = false;
                normalInfo.style.display = 'block';
				normalInfo2.style.display = 'block';
                creditsInfo.style.display = 'none';
                panelToggleCount = 0;
				panelToggleFlag = false;
                isPanelVisible = true;
                panel.classList.add('visible');
                toggleBtn.textContent = texts[currentLang].navButtons.togglePanel;
            } else {
			if (panelToggleFlag)
			{
                panelToggleCount++;
			}

                if (panelToggleCount === 5) {
                    // 第5次点击：显示制作人员信息
                    showingCredits = true;
                    normalInfo.style.display = 'none';
					normalInfo2.style.display = 'none';
                    creditsInfo.style.display = 'block';
                    panel.classList.add('visible');
                    isPanelVisible = true;
                    toggleBtn.textContent = texts[currentLang].navButtons.togglePanel;
                } else {
                    // 普通切换
                    isPanelVisible = !isPanelVisible;
                    if (isPanelVisible) {
                        panel.classList.add('visible');
                        toggleBtn.textContent = texts[currentLang].navButtons.togglePanel;
                    } else {
                        panel.classList.remove('visible');
                        toggleBtn.textContent = currentLang === 'zh' ? (texts[currentLang].navButtons.togglePanel === '隐藏控制面板' ? '显示控制面板' : 'Show Panel') : (texts[currentLang].navButtons.togglePanel === '显示控制面板' ? 'Hide Panel' : 'Hide Panel');
                    }
                }
            }
        };
        
        // 平滑移动相机
        function animateCamera(targetPosition, targetLookAt, duration) {
            const startPosition = camera.position.clone();
            const startLookAt = controls.target.clone();
            const startTime = Date.now();
            
            function updateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                camera.position.lerpVectors(startPosition, targetPosition, easeProgress);
                controls.target.lerpVectors(startLookAt, targetLookAt, easeProgress);
                controls.update();
                
                if (progress < 1) {
                    requestAnimationFrame(updateCamera);
                }
            }
            
            updateCamera();
        }
        
        // 设置银河系层级控制
        function setupGalaxyControls() {
            const galaxySpeedSlider = document.getElementById('galaxySpeed');
            
            // 更新银河系转速
            galaxySpeedSlider.addEventListener('input', function() {
                galaxyRotationSpeed = parseFloat(this.value);
                document.getElementById('galaxySpeedValue').textContent = galaxyRotationSpeed.toFixed(1);
            });
        }
        
        // 设置太阳系层级控制
        function setupSolarControls() {
            const solarSpeedSlider = document.getElementById('solarSpeed');
            
            // 更新太阳系转速
            solarSpeedSlider.addEventListener('input', function() {
                solarRotationSpeed = parseFloat(this.value);
                document.getElementById('solarSpeedValue').textContent = solarRotationSpeed.toFixed(1);
            });
        }
        
        // 设置地球层级控制
        function setupEarthControls() {
            const rotationSlider = document.getElementById('rotationSpeed');
            const cloudSlider = document.getElementById('cloudOpacity');
            const toggleButton = document.getElementById('toggleRotation');
            const resetButton = document.getElementById('resetView');
            
            // 更新旋转速度
            rotationSlider.addEventListener('input', function() {
                rotationSpeed = parseFloat(this.value);
                document.getElementById('speedValue').textContent = rotationSpeed.toFixed(1);
            });
            
            // 更新云层透明度
            cloudSlider.addEventListener('input', function() {
                const opacity = parseFloat(this.value);
                document.getElementById('cloudValue').textContent = opacity.toFixed(1);
                if (clouds && clouds.material) {
                    clouds.material.opacity = opacity;
                }
            });
            
            // 切换旋转
            toggleButton.addEventListener('click', function() {
                isRotating = !isRotating;
                this.textContent = isRotating ? texts[currentLang].toggleButtons.rotation[0] : texts[currentLang].toggleButtons.rotation[1];
            });
            
            // 重置视图
            resetButton.addEventListener('click', function() {
                controls.reset();
                camera.position.set(0, 0, 10);
                controls.update();
            });
            
            // 城市显示切换
            const toggleCitiesBtn = document.getElementById('toggleCities');
            toggleCitiesBtn.addEventListener('click', function() {
                showCities = !showCities;
                if (citiesGroup) {
                    citiesGroup.visible = showCities;
                }
                this.textContent = showCities ? texts[currentLang].toggleButtons.cities[0] : texts[currentLang].toggleButtons.cities[1];
                const citiesStatus = document.getElementById('citiesStatus');
                if (citiesStatus) {
                    citiesStatus.textContent = showCities ? texts[currentLang].statusText.cities[0] : texts[currentLang].statusText.cities[1];
                }
            });
            
            // 山峰显示切换
            const togglePeaksBtn = document.getElementById('togglePeaks');
            togglePeaksBtn.addEventListener('click', function() {
                showPeaks = !showPeaks;
                if (peaksGroup) {
                    peaksGroup.visible = showPeaks;
                }
                this.textContent = showPeaks ? texts[currentLang].toggleButtons.peaks[0] : texts[currentLang].toggleButtons.peaks[1];
                const peaksStatus = document.getElementById('peaksStatus');
                if (peaksStatus) {
                    peaksStatus.textContent = showPeaks ? texts[currentLang].statusText.peaks[0] : texts[currentLang].statusText.peaks[1];
                }
            });
            
            // 湖泊显示切换
            const toggleLakesBtn = document.getElementById('toggleLakes');
            toggleLakesBtn.addEventListener('click', function() {
                showLakes = !showLakes;
                if (lakesGroup) {
                    lakesGroup.visible = showLakes;
                }
                this.textContent = showLakes ? texts[currentLang].toggleButtons.lakes[0] : texts[currentLang].toggleButtons.lakes[1];
                const lakesStatus = document.getElementById('lakesStatus');
                if (lakesStatus) {
                    lakesStatus.textContent = showLakes ? texts[currentLang].statusText.lakes[0] : texts[currentLang].statusText.lakes[1];
                }
            });
            
            // 河流显示切换
            const toggleRiversBtn = document.getElementById('toggleRivers');
            toggleRiversBtn.addEventListener('click', function() {
                showRivers = !showRivers;
                if (riversGroup) {
                    riversGroup.visible = showRivers;
                }
                this.textContent = showRivers ? texts[currentLang].toggleButtons.rivers[0] : texts[currentLang].toggleButtons.rivers[1];
                const riversStatus = document.getElementById('riversStatus');
                if (riversStatus) {
                    riversStatus.textContent = showRivers ? texts[currentLang].statusText.rivers[0] : texts[currentLang].statusText.rivers[1];
                }
            });
            
            // 赤道显示切换
            const toggleEquatorBtn = document.getElementById('toggleEquator');
            toggleEquatorBtn.addEventListener('click', function() {
                showEquator = !showEquator;
                if (equatorGroup) {
                    equatorGroup.visible = showEquator;
                }
                this.textContent = showEquator ? texts[currentLang].toggleButtons.equator[0] : texts[currentLang].toggleButtons.equator[1];
            });
            
            // 回归线显示切换
            const toggleCanCapBtn = document.getElementById('toggleCanCap');
            toggleCanCapBtn.addEventListener('click', function() {
                showTropic = !showTropic;
                if (tropicGroup) {
                    tropicGroup.visible = showTropic;
                }
                this.textContent = showTropic ? texts[currentLang].toggleButtons.tropic[0] : texts[currentLang].toggleButtons.tropic[1];
            });

            // 经纬线显示切换
            const toggleLatLonBtn = document.getElementById('toggleLatLon');
            toggleLatLonBtn.addEventListener('click', function() {
                showTonLat = !showTonLat;
                if (latLonGroup) {
                    latLonGroup.visible = showTonLat;
                }
                this.textContent = showTonLat ? texts[currentLang].toggleButtons.latLon[0] : texts[currentLang].toggleButtons.latLon[1];
            });

            // 极圈显示切换
            const toggleArcAntBtn = document.getElementById('toggleArcAnt');
            toggleArcAntBtn.addEventListener('click', function() {
                showArcAnt = !showArcAnt;
                if (arcAntGroup) {
                    arcAntGroup.visible = showArcAnt;
                }
                this.textContent = showArcAnt ? texts[currentLang].toggleButtons.arcAnt[0] : texts[currentLang].toggleButtons.arcAnt[1];
            });
        }
        
        // 窗口大小调整
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // 全局变量管理弹窗
        let currentTooltip = null;
        let tooltipTimer = null;
        let lastMouseMoveTime = 0;
        let activeCityTooltip = null;
        let activeCityKey = null;
        let activePeakTooltip = null;
        let activePeakKey = null;
        let activeLakeTooltip = null;
        let activeLakeKey = null;
        let activeRiverTooltip = null;
        let activeRiverKey = null;

        // 获取当前活动的弹窗
        function getActiveTooltip(type, key) {
            if (type === 'city') return activeCityKey === key ? activeCityTooltip : null;
            if (type === 'peak') return activePeakKey === key ? activePeakTooltip : null;
            if (type === 'lake') return activeLakeKey === key ? activeLakeTooltip : null;
            if (type === 'river') return activeRiverKey === key ? activeRiverTooltip : null;
            return null;
        }

        // 重置弹窗计时器
        function resetTooltipTimer() {
            if (tooltipTimer) {
                clearTimeout(tooltipTimer);
                tooltipTimer = null;
            }
            lastMouseMoveTime = Date.now();
        }

        // 设置延迟关闭弹窗（鼠标移开标记1秒后关闭）
        function scheduleTooltipHide() {
            if (tooltipTimer) {
                clearTimeout(tooltipTimer);
            }
            tooltipTimer = setTimeout(() => {
                const timeSinceLastMove = Date.now() - lastMouseMoveTime;
                if (timeSinceLastMove >= 1000) { // 1秒后关闭
                    hideCurrentTooltip();
                }
            }, 1000);
        }

        // 取消延迟关闭（如果鼠标仍在标识上）
        function cancelTooltipHide() {
            if (tooltipTimer) {
                clearTimeout(tooltipTimer);
                tooltipTimer = null;
            }
        }

        // 恢复所有图标颜色
        function restoreAllIconColors() {
            if (citiesGroup) {
                citiesGroup.children.forEach(child => {
                    if (child.userData && child.userData.cityKey && !child.userData.isHitTest) {
                        if (child.geometry && child.geometry.type === 'SphereGeometry') {
                            child.material.color.setHex(0xffffff);
                            child.scale.setScalar(1.0);
                        }
                    }
                });
            }
            if (peaksGroup) {
                peaksGroup.children.forEach(child => {
                    if (child.userData && child.userData.peakKey) {
                        if (child.geometry && child.geometry.type === 'SphereGeometry') {
                            const isPole = child.userData.peakKey === 'northpole' || child.userData.peakKey === 'southpole';
                            const restoreColor = isPole ? 0xff8800 : 0xff0000;
                            child.material.color.setHex(restoreColor);
                            child.scale.setScalar(1.0);
                        }
                    }
                });
            }
            if (lakesGroup) {
                lakesGroup.children.forEach(child => {
                    if (child.userData && child.userData.lakeKey) {
                        if (child.geometry && child.geometry.type === 'SphereGeometry') {
                            child.material.color.setHex(0x0000ff);
                            child.scale.setScalar(1.0);
                        }
                    }
                });
            }
            if (riversGroup) {
                riversGroup.children.forEach(child => {
                    if (child.userData && child.userData.riverKey) {
                        if (child.geometry && child.geometry.type === 'SphereGeometry') {
                            child.material.color.setHex(0x00ff00);
                            child.scale.setScalar(1.0);
                        }
                    }
                });
            }
        }

        // 隐藏当前弹窗
        function hideCurrentTooltip() {
            restoreAllIconColors();
            if (currentTooltip && currentTooltip.parentNode) {
                document.body.removeChild(currentTooltip);
                currentTooltip = null;
            }
            if (activeCityTooltip) {
                activeCityTooltip = null;
            }
            if (activePeakTooltip) {
                activePeakTooltip = null;
            }
            if (activeLakeTooltip) {
                activeLakeTooltip = null;
            }
            if (activeRiverTooltip) {
                activeRiverTooltip = null;
            }
            if (tooltipTimer) {
                clearTimeout(tooltipTimer);
                tooltipTimer = null;
            }
            // 弹窗关闭后恢复地球旋转
            isRotating = true;
            const toggleButton = document.getElementById('toggleRotation');
            if (toggleButton) {
                toggleButton.textContent = texts[currentLang].toggleButtons.rotation[0]; // 暂停旋转
            }
        }

        // 创建科幻风格介绍弹窗
        function createSciFiTooltip(data, type) {
            const tooltip = document.createElement('div');
            tooltip.className = 'sci-fi-tooltip';
            tooltip.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 30, 60, 0.3);
                border: none;
                border-radius: 15px;
                padding: 25px;
                color: #ffffff;
                font-family: 'Arial', sans-serif;
                max-width: 400px;
                z-index: 1000;
                box-shadow: 0 0 40px rgba(0, 242, 254, 0.6);
                backdrop-filter: blur(15px);
                animation: fadeIn 0.3s ease-in-out;
            `;

            if (!document.getElementById('tooltip-animation-style')) {
                const style = document.createElement('style');
                style.id = 'tooltip-animation-style';
                style.textContent = `
                    @keyframes fadeIn {
                        from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    }
                `;
                document.head.appendChild(style);
            }

            const title = document.createElement('div');
            title.style.cssText = `
                font-size: 24px;
                font-weight: bold;
                color: #00f2fe;
                margin-bottom: 10px;
                text-align: center;
                text-shadow: 0 0 15px rgba(0, 242, 254, 0.9);
            `;
            title.textContent = currentLang === 'zh' ? data.name : (data.englishName || data.name);
            tooltip.appendChild(title);

            if (data.englishName && currentLang === 'zh') {
                const englishTitle = document.createElement('div');
                englishTitle.style.cssText = `
                    font-size: 16px;
                    color: #cccccc;
                    margin-bottom: 15px;
                    text-align: center;
                `;
                englishTitle.textContent = data.englishName;
                tooltip.appendChild(englishTitle);
            }

            const info = document.createElement('div');
            info.style.cssText = 'font-size: 14px; line-height: 1.6;';

            if (type === 'peak') {
                info.innerHTML = `
                    <div style="margin-bottom: 10px;">
                        <span style="color: #ffff00; font-weight: bold; text-shadow: 0 0 5px rgba(255, 255, 0, 0.8);">${currentLang === 'zh' ? "海拔高度：" : "Elevation:"}</span>
                        <span style="color: #ffffff; font-size: 18px; text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);">${data.elevation.toLocaleString()} ${currentLang === 'zh' ? "米" : "m"}</span>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <span style="color: #ff6600; font-weight: bold; text-shadow: 0 0 5px rgba(255, 102, 0, 0.8);">${currentLang === 'zh' ? "地理位置：" : "Location:"}</span>
                        <span style="color: #ffffff;">${currentLang === 'zh' ? "东经" : "E"} ${data.coordinates[0].toFixed(4)}°, ${currentLang === 'zh' ? "北纬" : "N"} ${data.coordinates[1].toFixed(4)}°</span>
                    </div>
                    <div style="color: #cccccc; font-style: italic; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; margin-top: 10px; box-shadow: 0 0 10px rgba(255,255,255,0.2);">
                        ${currentLang === 'zh' ? data.description : (data.englishDescription || data.description)}
                    </div>
                `;
            } else if (type === 'city') {
                info.innerHTML = `
                    <div style="margin-bottom: 10px;">
                        <span style="color: #00f2fe; font-weight: bold; text-shadow: 0 0 5px rgba(0, 242, 254, 0.8);">${currentLang === 'zh' ? "所属国家：" : "Country:"}</span>
                        <span style="color: #ffffff; font-size: 16px; text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);">${currentLang === 'zh' ? data.country : data.englishCountry}</span>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <span style="color: #ff00ff; font-weight: bold; text-shadow: 0 0 5px rgba(255, 0, 255, 0.8);">${currentLang === 'zh' ? "所属大洲：" : "Continent:"}</span>
                        <span style="color: #ffffff; font-size: 16px; text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);">${currentLang === 'zh' ? data.continent : data.englishContinent}</span>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <span style="color: #ffff00; font-weight: bold; text-shadow: 0 0 5px rgba(255, 255, 0, 0.8);">${currentLang === 'zh' ? "人口数量：" : "Population:"}</span>
                        <span style="color: #ffffff; font-size: 18px; text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);">${(data.population / 1000000).toFixed(1)} ${currentLang === 'zh' ? "百万" : "Million"}</span>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <span style="color: #ff6600; font-weight: bold; text-shadow: 0 0 5px rgba(255, 102, 0, 0.8);">${currentLang === 'zh' ? "地理位置：" : "Location:"}</span>
                        <span style="color: #ffffff;">${currentLang === 'zh' ? "东经" : "E"} ${data.coordinates[0].toFixed(4)}°, ${currentLang === 'zh' ? "北纬" : "N"} ${data.coordinates[1].toFixed(4)}°</span>
                    </div>
                `;
            } else if (type === 'lake') {
                info.innerHTML = `
                    <div style="margin-bottom: 10px;">
                        <span style="color: #0000ff; font-weight: bold; text-shadow: 0 0 5px rgba(0, 0, 255, 0.8);">${currentLang === 'zh' ? "面积：" : "Area:"}</span>
                        <span style="color: #ffffff; font-size: 18px; text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);">${data.area.toLocaleString()} ${currentLang === 'zh' ? "平方公里" : "km²"}</span>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <span style="color: #0088ff; font-weight: bold; text-shadow: 0 0 5px rgba(0, 136, 255, 0.8);">${currentLang === 'zh' ? "最大深度：" : "Max Depth:"}</span>
                        <span style="color: #ffffff; font-size: 18px; text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);">${data.maxDepth.toLocaleString()} ${currentLang === 'zh' ? "米" : "m"}</span>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <span style="color: #ff6600; font-weight: bold; text-shadow: 0 0 5px rgba(255, 102, 0, 0.8);">${currentLang === 'zh' ? "地理位置：" : "Location:"}</span>
                        <span style="color: #ffffff;">${currentLang === 'zh' ? "东经" : "E"} ${data.coordinates[0].toFixed(4)}°, ${currentLang === 'zh' ? "北纬" : "N"} ${data.coordinates[1].toFixed(4)}°</span>
                    </div>
                    <div style="color: #cccccc; font-style: italic; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; margin-top: 10px; box-shadow: 0 0 10px rgba(255,255,255,0.2);">
                        ${currentLang === 'zh' ? data.description : (data.englishDescription || data.description)}
                    </div>
                `;
            } else if (type === 'river') {
                info.innerHTML = `
                    <div style="margin-bottom: 10px;">
                        <span style="color: #00ff00; font-weight: bold; text-shadow: 0 0 5px rgba(0, 255, 0, 0.8);">${currentLang === 'zh' ? "长度：" : "Length:"}</span>
                        <span style="color: #ffffff; font-size: 18px; text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);">${data.length.toLocaleString()} ${currentLang === 'zh' ? "公里" : "km"}</span>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <span style="color: #ff6600; font-weight: bold; text-shadow: 0 0 5px rgba(255, 102, 0, 0.8);">${currentLang === 'zh' ? "地理位置：" : "Location:"}</span>
                        <span style="color: #ffffff;">${currentLang === 'zh' ? "东经" : "E"} ${data.coordinates[0].toFixed(4)}°, ${currentLang === 'zh' ? "北纬" : "N"} ${data.coordinates[1].toFixed(4)}°</span>
                    </div>
                    <div style="color: #cccccc; font-style: italic; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; margin-top: 10px; box-shadow: 0 0 10px rgba(255,255,255,0.2);">
                        ${currentLang === 'zh' ? data.description : (data.englishDescription || data.description)}
                    </div>
                `;
            }

            tooltip.appendChild(info);

            const closeBtn = document.createElement('div');
            closeBtn.style.cssText = `
                position: absolute;
                top: 10px;
                right: 15px;
                color: #00f2fe;
                font-size: 20px;
                cursor: pointer;
                font-weight: bold;
                text-shadow: 0 0 5px rgba(0, 242, 254, 0.8);
            `;
            closeBtn.textContent = '×';
            closeBtn.onclick = () => {
                hideCurrentTooltip();
            };
            tooltip.appendChild(closeBtn);

            document.body.appendChild(tooltip);

            return tooltip;
        }

        // 显示城市弹窗
        function showCityTooltip(cityData, cityKey, cityObject) {
            hideCurrentTooltip();
            activeCityTooltip = createSciFiTooltip(cityData, 'city');
            activeCityKey = cityKey;
            currentTooltip = activeCityTooltip;
            activePeakTooltip = activeCityTooltip;
            resetTooltipTimer();
        }

        // 显示山峰弹窗
        function showPeakTooltip(peakData, peakKey, peakObject) {
            hideCurrentTooltip();
            activePeakTooltip = createSciFiTooltip(peakData, 'peak');
            activePeakKey = peakKey;
            currentTooltip = activePeakTooltip;
            resetTooltipTimer();
        }

        // 显示湖泊弹窗
        function showLakeTooltip(lakeData, lakeKey, lakeObject) {
            hideCurrentTooltip();
            activeLakeTooltip = createSciFiTooltip(lakeData, 'lake');
            activeLakeKey = lakeKey;
            currentTooltip = activeLakeTooltip;
            resetTooltipTimer();
        }

        // 显示河流弹窗
        function showRiverTooltip(riverData, riverKey, riverObject) {
            hideCurrentTooltip();
            activeRiverTooltip = createSciFiTooltip(riverData, 'river');
            activeRiverKey = riverKey;
            currentTooltip = activeRiverTooltip;
            resetTooltipTimer();
        }

        // ===== 动画循环 =====
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // 旋转银河系和黑洞（应用转速控制）
            if (galaxy && galaxy.visible) {
                // 银河系整体逆时针旋转
                galaxy.rotation.y += 0.0005 * galaxyRotationSpeed;

                // 黑洞三维动画系统
                const blackHoleGroup = galaxy.children.find(child =>
                    child.type === 'Group' &&
                    child.children.length > 0 &&
                    child.children[0].material &&
                    child.children[0].material.color.getHex() === 0x000000
                );
                if (blackHoleGroup) {
                    let childIndex = 0;
                    
                    // 0. 事件视界（静止）
                    childIndex++;
                    
                    // 1. 光子球层 - 极快旋转 + 脉动
                    if (blackHoleGroup.children[childIndex]) {
                        blackHoleGroup.children[childIndex].rotation.z += 0.04 * galaxyRotationSpeed;
                        const pulse = Math.sin(time * 2) * 0.1 + 1;
                        blackHoleGroup.children[childIndex].scale.set(pulse, pulse, 1);
                    }
                    childIndex++;
                    
                    // 2-4. 三维扭曲吸积盘（内、主、外）
                    for (let i = 0; i < 3; i++) {
                        if (blackHoleGroup.children[childIndex]) {
                            const disk = blackHoleGroup.children[childIndex];
                            // 差异化旋转速度
                            const rotSpeed = (0.03 - i * 0.008) * galaxyRotationSpeed;
                            disk.rotation.y += rotSpeed;
                            
                            // 添加轻微的波动效果
                            const wobble = Math.sin(time * 1.5 + i) * 0.02;
                            disk.rotation.z = wobble;
                            
                            // 动态扭曲效果
                            if (disk.geometry && disk.geometry.attributes.position) {
                                const positions = disk.geometry.attributes.position.array;
                                for (let j = 0; j < positions.length; j += 3) {
                                    const x = positions[j];
                                    const z = positions[j + 2];
                                    const angle = Math.atan2(z, x);
                                    const radius = Math.sqrt(x * x + z * z);
                                    const heightOffset = Math.sin(angle * 2 + time * 0.5) * radius * 0.08;
                                    positions[j + 1] = heightOffset;
                                }
                                disk.geometry.attributes.position.needsUpdate = true;
                            }
                        }
                        childIndex++;
                    }
                    
                    // 5. 吸积粒子流 - 螺旋运动
                    if (blackHoleGroup.children[childIndex] && blackHoleGroup.children[childIndex].type === 'Points') {
                        const particles = blackHoleGroup.children[childIndex];
                        const positions = particles.geometry.attributes.position.array;
                        const angles = particles.geometry.userData.angles;
                        const radii = particles.geometry.userData.radii;
                        const heights = particles.geometry.userData.heights;
                        
                        for (let i = 0; i < positions.length / 3; i++) {
                            // 螺旋向内运动
                            angles[i] += (0.02 + (1 / radii[i]) * 0.5) * galaxyRotationSpeed;
                            // 角度归一化，防止浮点数精度误差
                            angles[i] = ((angles[i] % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
                            radii[i] -= 0.015 * galaxyRotationSpeed; // 逐渐接近黑洞
                            
                            // 重置到外围
                            if (radii[i] < 7) {
                                radii[i] = 7 + Math.random() * 25;
                                heights[i] = (Math.random() - 0.5) * radii[i] * 0.3;
                            }
                            
                            positions[i * 3] = Math.cos(angles[i]) * radii[i];
                            positions[i * 3 + 1] = heights[i] * (1 - (32 - radii[i]) / 25);
                            positions[i * 3 + 2] = Math.sin(angles[i]) * radii[i];
                        }
                        particles.geometry.attributes.position.needsUpdate = true;
                    }
                    childIndex++;
                    
                    // 6-15. 引力透镜多层光环 (10个环，上下各5个)
                    for (let i = 0; i < 10; i++) {
                        if (blackHoleGroup.children[childIndex]) {
                            const ring = blackHoleGroup.children[childIndex];
                            ring.rotation.y += (0.01 + i * 0.002) * galaxyRotationSpeed;
                            // 波浪式上下摆动
                            const offset = i < 5 ? i : (i - 5);
                            ring.rotation.z = Math.sin(time * 0.8 + offset * 0.3) * 0.15;
                            // 脉动透明度
                            if (ring.material) {
                                const baseopacity = 0.4 - offset * 0.06;
                                ring.material.opacity = baseopacity * (0.7 + Math.sin(time * 2 + i) * 0.3);
                            }
                        }
                        childIndex++;
                    }
                    
                    // 16-17. 喷流粒子系统（上下两个）- 更新为更长的喷流
                    for (let j = 0; j < 2; j++) {
                        if (blackHoleGroup.children[childIndex] && blackHoleGroup.children[childIndex].type === 'Points') {
                            const jet = blackHoleGroup.children[childIndex];
                            const positions = jet.geometry.attributes.position.array;
                            const speeds = jet.geometry.userData.speeds;
                            const direction = jet.geometry.userData.direction;
                            
                            for (let i = 0; i < positions.length / 3; i++) {
                                // 粒子向外喷射
                                positions[i * 3 + 1] += speeds[i] * 0.3 * galaxyRotationSpeed * direction;
                                
                                const currentHeight = Math.abs(positions[i * 3 + 1]);
                                
                                // 重置粒子（适配新的长度80）
                                if (currentHeight > 80) {
                                    positions[i * 3 + 1] = 0;
                                    const angle = Math.random() * Math.PI * 2;
                                    const radius = Math.random() * 0.3;
                                    positions[i * 3] = Math.cos(angle) * radius;
                                    positions[i * 3 + 2] = Math.sin(angle) * radius;
                                }
                                
                                // 添加螺旋效果和径向扩散
                                const angle = Math.atan2(positions[i * 3 + 2], positions[i * 3]);
                                let radius = Math.sqrt(positions[i * 3] * positions[i * 3] + positions[i * 3 + 2] * positions[i * 3 + 2]);
                                
                                // 随高度增加而扩散
                                const expansionRate = 0.015;
                                radius += expansionRate * galaxyRotationSpeed;
                                
                                const newAngle = angle + 0.015 * galaxyRotationSpeed;
                                positions[i * 3] = Math.cos(newAngle) * radius;
                                positions[i * 3 + 2] = Math.sin(newAngle) * radius;
                            }
                            jet.geometry.attributes.position.needsUpdate = true;
                            
                            // 喷流整体脉冲效果
                            const jetPulse = Math.sin(time * 3 + j * Math.PI) * 0.3 + 0.7;
                            jet.material.opacity = 0.75 * jetPulse;
                        }
                        childIndex++;
                    }
                    
                    // 17.5-18.5 喷流核心光柱（上下两个）
                    for (let j = 0; j < 2; j++) {
                        if (blackHoleGroup.children[childIndex] && blackHoleGroup.children[childIndex].type === 'Mesh') {
                            const core = blackHoleGroup.children[childIndex];
                            // 轻微旋转
                            core.rotation.y += 0.02 * galaxyRotationSpeed;
                            // 脉动效果
                            const corePulse = Math.sin(time * 2.5 + j * Math.PI) * 0.2 + 0.8;
                            core.material.opacity = 0.5 * corePulse;
                            core.scale.set(corePulse, 1, corePulse);
                        }
                        childIndex++;
                    }
                    
                    // 19-26. 体积雾层 - 缓慢旋转和脉动
                    for (let i = 0; i < 8; i++) {
                        if (blackHoleGroup.children[childIndex]) {
                            const fog = blackHoleGroup.children[childIndex];
                            fog.rotation.y += (0.001 + i * 0.0002) * galaxyRotationSpeed;
                            fog.rotation.z += (0.0008 - i * 0.0001) * galaxyRotationSpeed;
                            // 脉动效果
                            const pulse = 1 + Math.sin(time * 0.5 + i * 0.5) * 0.1;
                            fog.scale.set(pulse, pulse, pulse);
                        }
                        childIndex++;
                    }
                    
                    // 27. 外部光晕 - 慢速旋转
                    if (blackHoleGroup.children[childIndex]) {
                        blackHoleGroup.children[childIndex].rotation.z += 0.005 * galaxyRotationSpeed;
                        // 透明度脉动
                        if (blackHoleGroup.children[childIndex].material) {
                            const haloOpacity = 0.15 * (1 + Math.sin(time * 0.8) * 0.3);
                            blackHoleGroup.children[childIndex].material.opacity = haloOpacity;
                        }
                    }
                }

                // 开普勒旋转：基于距离的恒星差异化转速
                galaxy.children.forEach(child => {
                    if (child.type === 'Points' && child.geometry.userData && child.geometry.userData.distances) {
                        const positions = child.geometry.attributes.position.array;
                        const distances = child.geometry.userData.distances;
                        const angles = child.geometry.userData.angles;
                        const offsets = child.geometry.userData.offsets;

                        for (let i = 0; i < positions.length / 3; i++) {
                            const radius = distances[i];
                            // 银河系旋转曲线（近似平坦）：角速度 ω ∝ 1/r
                            const angularSpeed = 0.002 / (radius / 10) * galaxyRotationSpeed;

                            // 更新角度（逆时针旋转，从上方俯视）
                            angles[i] += angularSpeed;
                            // 角度归一化，防止浮点数精度误差导致方向异常
                            // 保证角度在 [0, 2π) 范围内，正确处理负角度
                            angles[i] = ((angles[i] % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);

                            // 计算新位置（保持螺旋结构和相对偏移）
                            const x = Math.cos(angles[i]) * radius + offsets[i * 2];
                            const z = Math.sin(angles[i]) * radius + offsets[i * 2 + 1];

                            positions[i * 3] = x;
                            positions[i * 3 + 2] = z;
                        }

                        child.geometry.attributes.position.needsUpdate = true;

                        // 星星闪烁效果
                        child.material.opacity = 0.6 + Math.sin(time * 2) * 0.2;
                    }
                });
            }
            
            // 旋转太阳系（按实际比例设置转速）
            if (solarSystem && solarSystem.visible) {
                // ===== 太阳动画系统 =====
                const sunGroup = solarSystem.children[0]; // 太阳组是第一个子对象
                if (sunGroup && sunGroup.type === 'Group') {
                    let sunChildIndex = 0;
                    
                    // 0. 太阳核心自转
                    if (sunGroup.children[sunChildIndex]) {
                        sunGroup.children[sunChildIndex].rotation.y += 0.005 * solarRotationSpeed;
                    }
                    sunChildIndex++;
                    
                    // 1. 表面纹理层自转（速度稍慢）
                    if (sunGroup.children[sunChildIndex]) {
                        sunGroup.children[sunChildIndex].rotation.y += 0.004 * solarRotationSpeed;
                    }
                    sunChildIndex++;
                    
                    // 2-8. 日冕层脉动和旋转
                    for (let i = 0; i < 7; i++) {
                        if (sunGroup.children[sunChildIndex]) {
                            const corona = sunGroup.children[sunChildIndex];
                            // 差异化旋转
                            corona.rotation.y += (0.003 + i * 0.0002) * solarRotationSpeed;
                            corona.rotation.z += (0.001 - i * 0.0001) * solarRotationSpeed;
                            
                            // 脉动效果
                            const layerIndex = corona.userData.layerIndex || i;
                            const pulse = 1 + Math.sin(time * 1.5 + layerIndex * 0.5) * 0.08;
                            corona.scale.setScalar(pulse);
                            
                            // 透明度闪烁
                            const baseOpacity = [0.4, 0.35, 0.3, 0.25, 0.18, 0.12, 0.08][layerIndex];
                            corona.material.opacity = baseOpacity * (0.8 + Math.sin(time * 2 + layerIndex) * 0.2);
                        }
                        sunChildIndex++;
                    }
                    
                    // 9. 太阳黑子随表面旋转
                    if (sunGroup.children[sunChildIndex] && sunGroup.children[sunChildIndex].type === 'Points') {
                        sunGroup.children[sunChildIndex].rotation.y += 0.005 * solarRotationSpeed;
                    }
                    sunChildIndex++;
                    
                    // 10. 太阳耀斑动画（跳动闪烁）
                    if (sunGroup.children[sunChildIndex] && sunGroup.children[sunChildIndex].type === 'Points') {
                        const flares = sunGroup.children[sunChildIndex];
                        flares.rotation.y += 0.006 * solarRotationSpeed;
                        
                        // 随机闪烁效果
                        const positions = flares.geometry.attributes.position.array;
                        const colors = flares.geometry.attributes.color.array;
                        const angles = flares.geometry.userData.angles;
                        
                        for (let i = 0; i < positions.length / 3; i++) {
                            // 动态半径变化
                            const theta = angles[i * 2];
                            const phi = angles[i * 2 + 1];
                            const radiusVariation = Math.sin(time * 5 + i * 0.1) * 0.15;
                            const radius = 3.08 + 0.3 * Math.random() + radiusVariation;
                            
                            positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                            positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                            positions[i * 3 + 2] = radius * Math.cos(phi);
                            
                            // 颜色闪烁
                            const brightness = 0.8 + Math.sin(time * 8 + i * 0.2) * 0.4;
                            const c = new THREE.Color(0xffff88);
                            c.multiplyScalar(brightness);
                            colors[i * 3] = c.r;
                            colors[i * 3 + 1] = c.g;
                            colors[i * 3 + 2] = c.b;
                        }
                        
                        flares.geometry.attributes.position.needsUpdate = true;
                        flares.geometry.attributes.color.needsUpdate = true;
                    }
                    sunChildIndex++;
                    
                    // 11-15. 日珥动画（5个）
                    for (let i = 0; i < 5; i++) {
                        if (sunGroup.children[sunChildIndex] && sunGroup.children[sunChildIndex].type === 'Points') {
                            const prominence = sunGroup.children[sunChildIndex];
                            const positions = prominence.geometry.attributes.position.array;
                            const baseAngle = prominence.geometry.userData.angle;
                            const speeds = prominence.geometry.userData.speeds;
                            
                            // 日珥缓慢运动和波动
                            for (let j = 0; j < positions.length / 3; j++) {
                                const t = j / (positions.length / 3);
                                const arcHeight = Math.sin(t * Math.PI) * (1.5 + Math.random() * 1.0);
                                const radius = 3 + arcHeight + Math.sin(time * 2 + j * 0.1) * 0.2;
                                
                                const theta = baseAngle + (Math.random() - 0.5) * 0.3 + speeds[j] * time;
                                const phi = Math.PI / 2 + (t - 0.5) * 0.8;
                                
                                positions[j * 3] = radius * Math.sin(phi) * Math.cos(theta);
                                positions[j * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                                positions[j * 3 + 2] = radius * Math.cos(phi);
                            }
                            
                            prominence.geometry.attributes.position.needsUpdate = true;
                            
                            // 透明度脉动
                            prominence.material.opacity = 0.8 * (0.7 + Math.sin(time * 1.5 + i) * 0.3);
                        }
                        sunChildIndex++;
                    }
                    
                    // 16. 太阳风粒子流（向外辐射）
                    if (sunGroup.children[sunChildIndex] && sunGroup.children[sunChildIndex].type === 'Points') {
                        const solarWind = sunGroup.children[sunChildIndex];
                        const positions = solarWind.geometry.attributes.position.array;
                        const speeds = solarWind.geometry.userData.speeds;
                        
                        for (let i = 0; i < positions.length / 3; i++) {
                            const x = positions[i * 3];
                            const y = positions[i * 3 + 1];
                            const z = positions[i * 3 + 2];
                            
                            let radius = Math.sqrt(x * x + y * y + z * z);
                            const theta = Math.atan2(y, x);
                            const phi = Math.acos(z / radius);
                            
                            // 向外扩散
                            radius += speeds[i] * solarRotationSpeed;
                            
                            // 重置粒子
                            if (radius > 11.5) {
                                radius = 3.5 + Math.random() * 0.5;
                            }
                            
                            positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                            positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                            positions[i * 3 + 2] = radius * Math.cos(phi);
                        }
                        
                        solarWind.geometry.attributes.position.needsUpdate = true;
                    }
                }
                
                // 行星公转（按开普勒第三定律，周期^2 ∝ 距离^3）
                // 基准：地球公转周期 = 1年 = 0.02弧度/帧
                planets.forEach(planet => {
                    const distance = planet.userData.distance;
                    // 公转速度 = 基准速度 / 距离^(3/2)（开普勒定律）
                    const orbitalSpeed = 0.02 / Math.pow(distance / 16, 1.5);
                    planet.userData.angle += orbitalSpeed * solarRotationSpeed;
                    // 角度归一化，防止浮点数精度误差
                    planet.userData.angle = ((planet.userData.angle % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
                    planet.position.x = Math.cos(planet.userData.angle) * distance;
                    planet.position.z = Math.sin(planet.userData.angle) * distance;
                    
                    // 行星自转（设为不同速度）
                    const rotationSpeeds = {
                        '水星': 0.02,  // 水星自转很慢
                        '金星': 0.005, // 金星自转极慢且反向
                        '地球': 0.05,  // 地球24小时
                        '火星': 0.048, // 火星24.6小时
                        '木星': 0.12,  // 木星自转最快
                        '土星': 0.11,  // 土星次之
                        '天王星': 0.08, // 天王星
                        '海王星': 0.08  // 海王星
                    };
                    const rotationSpeed = rotationSpeeds[planet.userData.name] || 0.05;
                    planet.rotation.y += rotationSpeed * solarRotationSpeed;
                    
                    // 土星光环旋转
                    if (planet.userData.name === '土星' || planet.userData.englishName === 'Saturn') {
                        if (planet.children.length > 0) {
                            planet.children[0].rotation.z += 0.005 * solarRotationSpeed;
                        }
                    }
                    
                    // 气态巨行星大气层效果（轻微脉动）
                    if (planet.userData.name === '木星' || planet.userData.name === '土星' || 
                        planet.userData.name === '天王星' || planet.userData.name === '海王星' ||
                        planet.userData.englishName === 'Jupiter' || planet.userData.englishName === 'Saturn' || 
                        planet.userData.englishName === 'Uranus' || planet.userData.englishName === 'Neptune') {
                        const pulse = 1 + Math.sin(time * 0.5 + planet.userData.angle) * 0.02;
                        planet.scale.setScalar(pulse);
                    }
                });
                
                // 月球围绕地球（约27.3天一圈，相对地球设为0.4）
                if (moon && planets[2]) { // 地球是第3个行星
                    moon.userData.angle += 0.04 * solarRotationSpeed; // 月球公转
                    // 角度归一化，防止浮点数精度误差
                    moon.userData.angle = ((moon.userData.angle % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
                    const earthX = planets[2].position.x;
                    const earthZ = planets[2].position.z;
                    moon.position.x = earthX + Math.cos(moon.userData.angle) * moon.userData.distance;
                    moon.position.z = earthZ + Math.sin(moon.userData.angle) * moon.userData.distance;
                    
                    // 月球自转（潮汐锁定，与公转同步）
                    moon.rotation.y += 0.04 * solarRotationSpeed;
                }
                
                // 小行星带动画系统
                asteroidBelt.forEach(asteroid => {
                    if (asteroid.type === 'Points') {
                        // 粒子系统（尘埃云和碎片）
                        const positions = asteroid.geometry.attributes.position.array;
                        const angles = asteroid.geometry.userData.angles;
                        const radii = asteroid.geometry.userData.radii;
                        
                        if (angles && radii) {
                            for (let i = 0; i < positions.length / 3; i++) {
                                // 公转
                                const speed = asteroid.userData.type === 'asteroidDust' ? 0.003 : 0.005;
                                angles[i] += speed * solarRotationSpeed;
                                // 角度归一化，防止浮点数精度误差
                                angles[i] = ((angles[i] % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
                                
                                positions[i * 3] = Math.cos(angles[i]) * radii[i];
                                positions[i * 3 + 2] = Math.sin(angles[i]) * radii[i];
                            }
                            asteroid.geometry.attributes.position.needsUpdate = true;
                        }
                        
                        // 尘埃云整体缓慢旋转
                        if (asteroid.userData.type === 'asteroidDust') {
                            asteroid.rotation.y += 0.0001 * solarRotationSpeed;
                        }
                    } else if (asteroid.userData && asteroid.userData.type === 'asteroid') {
                        // 大型和中型小行星
                        asteroid.userData.angle += asteroid.userData.speed * solarRotationSpeed;
                        // 角度归一化，防止浮点数精度误差
                        asteroid.userData.angle = ((asteroid.userData.angle % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
                        asteroid.position.x = Math.cos(asteroid.userData.angle) * asteroid.userData.distance;
                        asteroid.position.z = Math.sin(asteroid.userData.angle) * asteroid.userData.distance;
                        
                        // 不规则自转
                        if (asteroid.userData.rotationSpeedX) {
                            asteroid.rotation.x += asteroid.userData.rotationSpeedX * solarRotationSpeed;
                            asteroid.rotation.y += asteroid.userData.rotationSpeedY * solarRotationSpeed;
                            if (asteroid.userData.rotationSpeedZ) {
                                asteroid.rotation.z += asteroid.userData.rotationSpeedZ * solarRotationSpeed;
                            }
                        } else {
                            // 简单旋转（中型小行星）
                            asteroid.rotation.x += 0.01 * solarRotationSpeed;
                            asteroid.rotation.y += 0.015 * solarRotationSpeed;
                        }
                    }
                });
                
                // 柯伊伯带动画系统
                kuiperBelt.forEach(kbo => {
                    if (kbo.type === 'Points') {
                        // 冰粒粒子系统
                        const positions = kbo.geometry.attributes.position.array;
                        const angles = kbo.geometry.userData.angles;
                        const radii = kbo.geometry.userData.radii;
                        
                        if (angles && radii) {
                            for (let i = 0; i < positions.length / 3; i++) {
                                // 公转（非常缓慢）
                                const speed = 0.001 + Math.random() * 0.001;
                                angles[i] += speed * solarRotationSpeed;
                                // 角度归一化，防止浮点数精度误差
                                angles[i] = ((angles[i] % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
                                
                                positions[i * 3] = Math.cos(angles[i]) * radii[i];
                                positions[i * 3 + 2] = Math.sin(angles[i]) * radii[i];
                            }
                            kbo.geometry.attributes.position.needsUpdate = true;
                        }
                    } else if (kbo.userData && kbo.userData.type === 'kuiperBeltObject') {
                        // 大型柯伊伯带天体
                        kbo.userData.angle += kbo.userData.speed * solarRotationSpeed;
                        // 角度归一化，防止浮点数精度误差
                        kbo.userData.angle = ((kbo.userData.angle % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
                        kbo.position.x = Math.cos(kbo.userData.angle) * kbo.userData.distance;
                        kbo.position.z = Math.sin(kbo.userData.angle) * kbo.userData.distance;
                        
                        // 自转
                        if (kbo.userData.rotationSpeedX) {
                            kbo.rotation.x += kbo.userData.rotationSpeedX * solarRotationSpeed;
                            kbo.rotation.y += kbo.userData.rotationSpeedY * solarRotationSpeed;
                        }
                    }
                });
                
                // 奥尔特云动画和可见性控制
                oortCloud.forEach(oortObj => {
                    if (oortObj.userData && oortObj.userData.type === 'oortCloud') {
                        // 根据相机缩放调整可见性和透明度
                        // camera.position.length() 表示相机距离原点的距离
                        const cameraDistance = camera.position.length();
                        const baseDistance = oortObj.userData.baseDistance;
                        
                        // 当相机距离超过基础距离的 visibleThreshold 倍时显示
                        const shouldBeVisible = cameraDistance > baseDistance * oortObj.userData.visibleThreshold;
                        
                        if (shouldBeVisible) {
                            // 计算透明度：相机越远，奥尔特云越明显
                            const opacityFactor = Math.min(1, (cameraDistance - baseDistance * oortObj.userData.visibleThreshold) / (baseDistance * 0.5));
                            oortObj.material.opacity = oortObj.userData.baseOpacity * opacityFactor;
                            oortObj.material.size = oortObj.userData.baseSize * opacityFactor;
                            
                            if (!oortObj.visible) {
                                oortObj.visible = true;
                            }
                            
                            // 奥尔特云缓慢旋转（球形）
                            oortObj.rotation.y += 0.00005 * solarRotationSpeed;
                            oortObj.rotation.x += 0.00003 * solarRotationSpeed;
                        } else {
                            oortObj.visible = false;
                        }
                    }
                });
            }

            // 彗星动画系统（沿椭圆轨道运行）
            if (solarSystem && solarSystem.visible) {
                comets.forEach((comet, cometIndex) => {
                    if (comet.userData && comet.userData.type === 'comet') {
                        // 更新彗星轨道角度（椭圆轨道）
                        comet.userData.angle += comet.userData.speed * solarRotationSpeed;
                        // 角度归一化，防止浮点数精度误差
                        comet.userData.angle = ((comet.userData.angle % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);

                        // 计算椭圆轨道位置
                        // 椭圆轨道参数
                        const a = comet.userData.semiMajorAxis; // 半长轴
                        const e = comet.userData.eccentricity; // 离心率
                        const i = comet.userData.inclination; // 轨道倾角

                        // 轨道周期速度变化（在近日点快，远日点慢）
                        // 使用简化模型：速度与距离成反比
                        const currentAngle = comet.userData.angle;

                        // 计算当前距离 r = a(1-e²) / (1 + e cos(θ))
                        const r = a * (1 - e * e) / (1 + e * Math.cos(currentAngle));

                        // 轨道平面旋转（考虑倾角）
                        const orbitX = Math.cos(currentAngle) * r;
                        const orbitZ = Math.sin(currentAngle) * r;
                        const orbitY = Math.sin(i) * orbitZ; // 倾角影响Y轴

                        // 设置彗星组位置
                        comet.position.set(orbitX, orbitY, orbitZ);

                        // 彗核自转
                        if (comet.children[0]) {
                            comet.children[0].rotation.y += comet.userData.rotationSpeed * solarRotationSpeed;
                        }

                        // 离子尾动画（蓝色，笔直指向远离太阳的方向）
                        if (comet.userData.ionTail) {
                            const ionTail = comet.userData.ionTail;
                            const positions = ionTail.geometry.attributes.position.array;

                            // 计算指向远离太阳的方向（彗尾方向）
                            const cometPos = new THREE.Vector3(orbitX, orbitY, orbitZ);
                            const tailDirection = cometPos.clone().normalize().multiplyScalar(1); // 指向远离太阳的方向（从彗核向外）
                            
                            // 彗尾长度根据距离调整（距离越近彗尾越长）
                            const tailLength = 3.0 * (30.0 / Math.max(cometPos.length(), 10.0)); // 最大3单位长度

                            for (let j = 0; j < positions.length / 3; j++) {
                                // 沿着彗尾方向布置粒子
                                const distanceAlongTail = (j / (positions.length / 3)) * tailLength;
                                const spread = Math.random() * 0.1 * distanceAlongTail;
                                
                                // 计算粒子位置（沿着彗尾方向，加上一些随机扩散）
                                const tailPos = tailDirection.clone().multiplyScalar(distanceAlongTail);
                                
                                // 添加垂直方向的随机扩散
                                const perpendicular = new THREE.Vector3(
                                    Math.random() - 0.5,
                                    Math.random() - 0.5,
                                    Math.random() - 0.5
                                ).cross(tailDirection).normalize().multiplyScalar(spread);
                                
                                positions[j * 3] = tailPos.x + perpendicular.x;
                                positions[j * 3 + 1] = tailPos.y + perpendicular.y;
                                positions[j * 3 + 2] = tailPos.z + perpendicular.z;

                                // 粒子闪烁效果，距离彗核越远越暗
                                const distanceFactor = distanceAlongTail / tailLength;
                                const brightness = 0.7 * (1 - distanceFactor * 0.5) + Math.sin(time * 5 + j * 0.1) * 0.2;
                                ionTail.geometry.attributes.opacity.array[j] = brightness;
                            }

                            ionTail.geometry.attributes.position.needsUpdate = true;
                            ionTail.geometry.attributes.opacity.needsUpdate = true;
                        }

                        // 尘埃尾动画（黄白色，弯曲扩散）
                        if (comet.userData.dustTail) {
                            const dustTail = comet.userData.dustTail;
                            const positions = dustTail.geometry.attributes.position.array;
                            const curves = dustTail.geometry.userData.curves;

                            // 计算指向远离太阳的方向（彗尾方向）
                            const cometPos = new THREE.Vector3(orbitX, orbitY, orbitZ);
                            const tailDirection = cometPos.clone().normalize().multiplyScalar(1); // 指向远离太阳的方向（从彗核向外）
                            
                            // 彗尾长度根据距离调整（距离越近彗尾越长）
                            const tailLength = 4.0 * (30.0 / Math.max(cometPos.length(), 10.0)); // 最大4单位长度

                            for (let j = 0; j < positions.length / 3; j++) {
                                const distanceAlongTail = (j / (positions.length / 3)) * tailLength;
                                const curve = curves[j] || 0.3;
                                
                                // 计算基本彗尾位置
                                const tailPos = tailDirection.clone().multiplyScalar(distanceAlongTail);
                                
                                // 添加弯曲效果（垂直于彗尾方向和彗星速度方向）
                                const bendAmount = distanceAlongTail * 0.1 * curve;
                                const bendDirection = new THREE.Vector3(0, 1, 0).cross(tailDirection).normalize();
                                
                                // 添加动态弯曲（随时间变化）
                                const dynamicBend = Math.sin(time * 2 + j * 0.05) * bendAmount * 0.3;
                                
                                positions[j * 3] = tailPos.x + bendDirection.x * bendAmount + Math.random() * 0.05 * distanceAlongTail;
                                positions[j * 3 + 1] = tailPos.y + bendDirection.y * bendAmount + Math.random() * 0.05 * distanceAlongTail + dynamicBend;
                                positions[j * 3 + 2] = tailPos.z + bendDirection.z * bendAmount + Math.random() * 0.05 * distanceAlongTail;

                                // 尘埃闪烁和颜色变化
                                const distanceFactor = distanceAlongTail / tailLength;
                                const hue = 0.1 + Math.random() * 0.03 - distanceFactor * 0.02;
                                const lightness = 0.6 + Math.sin(time * 4 + j * 0.08) * 0.2 - distanceFactor * 0.3;
                                const c = new THREE.Color().setHSL(hue, 0.5, lightness);
                                dustTail.geometry.attributes.color.array[j * 3] = c.r;
                                dustTail.geometry.attributes.color.array[j * 3 + 1] = c.g;
                                dustTail.geometry.attributes.color.array[j * 3 + 2] = c.b;
                            }

                            dustTail.geometry.attributes.position.needsUpdate = true;
                            dustTail.geometry.attributes.color.needsUpdate = true;
                        }
                    }
                });
            }

            // 旋转星空背景（地球层级）
            if (earthStarfield && earthStarfield.visible) {
                earthStarfield.rotation.y += 0.0002;
            }

            // 地球层级月球轨道运动
            if (window.earthMoon && currentLevel === 'earth') {
                window.earthMoon.userData.angle += window.earthMoon.userData.orbitSpeed * rotationSpeed;
                // 角度归一化，防止浮点数精度误差
                window.earthMoon.userData.angle = ((window.earthMoon.userData.angle % (Math.PI * 2)) + (Math.PI * 2)) % (Math.PI * 2);
                const moonRadius = window.earthMoon.userData.orbitRadius;
                const moonAngle = window.earthMoon.userData.angle;
                window.earthMoon.position.x = Math.cos(moonAngle) * moonRadius;
                window.earthMoon.position.z = Math.sin(moonAngle) * moonRadius;

                // 月球自转（潮汐锁定，与公转同步）
                window.earthMoon.rotation.y += window.earthMoon.userData.orbitSpeed * rotationSpeed;
            }

            // 旋转地球和云层
            if (earthSystem && earthSystem.visible) {
                if (isRotating) {
                    earthGroup.rotation.y += 0.005 * rotationSpeed;
                    if (clouds) {
                        clouds.rotation.y += 0.007 * rotationSpeed;
                    }
                }
                
                // 城市光环脉冲
                if (citiesGroup && showCities) {
                    const time = Date.now() * 0.002;
                    citiesGroup.children.forEach((child, index) => {
                        if (child.geometry && child.geometry.type === 'RingGeometry') {
                            const scale = 1 + Math.sin(time * 4 + index * 0.3) * 0.3;
                            child.scale.setScalar(scale);
                            child.material.opacity = 0.4 * (1 + Math.sin(time * 4 + index * 0.3)) * 0.5;
                        }
                    });
                }
                
                // 山峰光环脉冲
                if (peaksGroup && showPeaks) {
                    const time = Date.now() * 0.001;
                    peaksGroup.children.forEach((child, index) => {
                        if (child.geometry && child.geometry.type === 'RingGeometry') {
                            const scale = 1 + Math.sin(time * 3 + index * 0.5) * 0.4;
                            child.scale.setScalar(scale);
                            child.material.opacity = 0.4 * (1 + Math.sin(time * 3 + index * 0.5)) * 0.5;
                        }
                    });
                }
                
                // 湖泊光环脉冲
                if (lakesGroup && showLakes) {
                    const time = Date.now() * 0.0015;
                    lakesGroup.children.forEach((child, index) => {
                        if (child.geometry && child.geometry.type === 'RingGeometry') {
                            const scale = 1 + Math.sin(time * 3.5 + index * 0.4) * 0.35;
                            child.scale.setScalar(scale);
                            child.material.opacity = 0.4 * (1 + Math.sin(time * 3.5 + index * 0.4)) * 0.5;
                        }
                    });
                }
                
                // 河流光环脉冲
                if (riversGroup && showRivers) {
                    const time = Date.now() * 0.0012;
                    riversGroup.children.forEach((child, index) => {
                        if (child.geometry && child.geometry.type === 'RingGeometry') {
                            const scale = 1 + Math.sin(time * 3.2 + index * 0.45) * 0.38;
                            child.scale.setScalar(scale);
                            child.material.opacity = 0.4 * (1 + Math.sin(time * 3.2 + index * 0.45)) * 0.5;
                        }
                    });
                }
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // 启动应用
        window.addEventListener('DOMContentLoaded', init);
    </script>
    
    <!-- 音乐播放器 -->
    <div id="music-player" style="
        position: absolute;
        bottom: 80px;
        right: 20px;
        z-index: 300;
        background: rgba(0, 30, 60, 0.8);
        border: 1px solid #00f2fe;
        border-radius: 5px;
        padding: 10px;
        backdrop-filter: blur(10px);
    ">
        <div style="display: flex; align-items: center; gap: 10px;">
            <button id="music-toggle" style="
                background: rgba(0, 242, 254, 0.2);
                color: #00f2fe;
                border: 1px solid #00f2fe;
                border-radius: 3px;
                padding: 5px 10px;
                cursor: pointer;
                font-size: 14px;
            ">🎵 音乐: 开</button>
            <input type="range" id="music-volume" min="0" max="1" step="0.1" value="0.5" style="
                width: 80px;
            ">
            <span style="color: #00f2fe; font-size: 12px;">音量</span>
        </div>
    </div>

    <script>
        // 音乐播放功能
        let musicEnabled = true;
        let currentMusic = null;
        let currentLevel = 'galaxy'; // 默认层级
        
        // 音乐资源 - 使用免版权太空音乐
        // 实际使用时，请替换为真正的太空音乐URL
        const musicTracks = {
            galaxy: 'https://www.soundjay.com/misc/sounds/bell-ringing-05.wav', // 示例音乐 - 替换为真正的银河系音乐
            solar: 'https://www.soundjay.com/misc/sounds/bell-ringing-05.wav', // 示例音乐 - 替换为真正的太阳系音乐
            earth: 'https://www.soundjay.com/misc/sounds/bell-ringing-05.wav'  // 示例音乐 - 替换为真正的地球音乐
        };
        
        // 创建音频元素
        function createAudioElement(trackName) {
            const audio = new Audio();
            audio.src = musicTracks[trackName];
            audio.loop = true;
            audio.volume = 0.5;
            return audio;
        }
        
        // 播放指定层级的音乐
        function playLevelMusic(level) {
            if (!musicEnabled) return;
            
            // 停止当前音乐
            if (currentMusic) {
                currentMusic.pause();
                currentMusic.currentTime = 0;
            }
            
            // 创建并播放新音乐
            currentMusic = createAudioElement(level);
            currentMusic.play().catch(e => console.log("音乐自动播放被阻止:", e));
        }
        
        // 更新音乐状态
        function updateMusicForLevel(newLevel) {
            currentLevel = newLevel;
            if (musicEnabled) {
                playLevelMusic(newLevel);
            }
        }
        
        // 音乐开关
        document.getElementById('music-toggle').addEventListener('click', function() {
            musicEnabled = !musicEnabled;
            this.textContent = musicEnabled ? '🎵 音乐: 开' : '🔇 音乐: 关';
            
            if (musicEnabled) {
                playLevelMusic(currentLevel);
            } else if (currentMusic) {
                currentMusic.pause();
            }
        });
        
        // 音量控制
        document.getElementById('music-volume').addEventListener('input', function(e) {
            const volume = parseFloat(e.target.value);
            if (currentMusic) {
                currentMusic.volume = volume;
            }
        });
        
        // 重写层级切换函数以集成音乐
        const originalTransitionToSolarSystem = window.transitionToSolarSystem;
        const originalTransitionToEarth = window.transitionToEarth;
        const originalGoBack = window.goBack;
        
        window.transitionToSolarSystem = function() {
            originalTransitionToSolarSystem();
            updateMusicForLevel('solar');
        };
        
        window.transitionToEarth = function() {
            originalTransitionToEarth();
            updateMusicForLevel('earth');
        };
        
        window.goBack = function() {
            originalGoBack();
            // 根据当前层级设置音乐
            setTimeout(() => {
                if (currentLevel === 'solar') {
                    updateMusicForLevel('solar');
                } else if (currentLevel === 'galaxy') {
                    updateMusicForLevel('galaxy');
                }
            }, 100); // 短暂延迟以确保层级切换完成
        };
        
        // 页面加载完成后开始播放银河系音乐
        window.addEventListener('load', function() {
            setTimeout(() => {
                if (musicEnabled) {
                    playLevelMusic('galaxy');
                }
            }, 2000); // 延迟2秒开始播放
        });
    </script>
</body>
</html>